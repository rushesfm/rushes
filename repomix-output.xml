This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  lib/
    components/
      dashboard/
        DashboardPanel.svelte
      home/
        AuthSection.svelte
        FeaturedChannels.svelte
        GeneratedChannels.svelte
        HeroSection.svelte
        StatsSection.svelte
      Barcode.svelte
      CollapsibleHeading.svelte
      Header.svelte
      LocationPicker.svelte
      Map.svelte
      MuxVideoPlayer.svelte
      PersistentVideoPlayer.svelte
      Playing.svelte
      PlayingDesktopColumn.svelte
      Sidebar.svelte
      VideoCard.svelte
      VideoInfo.svelte
      VideoInfoContainer.svelte
      VideoPlayer.svelte
      VideoTimeline.svelte
    data/
      comments.ts
    server/
      db/
        index.ts
        schema.ts
        users.ts
        videos.ts
    stores/
      appStore.ts
      auth.ts
      library.ts
      playerStore.svelte.ts
      selectedVideo.ts
      theme.ts
      video.ts
    types/
      content.ts
      dashboard.ts
    utils/
      waveform.ts
    workers/
      videoMetadata.worker.ts
    index.ts
  routes/
    live/
      +page.svelte
    map/
      +page.svelte
    upload/
      +page.server.ts
      +page.svelte
    users/
      [id]/
        +page.svelte
      +page.svelte
    video/
      [id].svelte
      +page.svelte
    videos/
      [id]/
        +page.svelte
      +page.svelte
      +page.svelte.backup
    +layout.server.ts
    +layout.svelte
    +page.svelte
    +page.svelte.backup
    page copy.svelte
  app.css
  app.d.ts
  app.html
static/
  .assetsignore
  favicon.png
  logo.png
  robots.txt
  rushes.svg
.env.example
.gitignore
.npmrc
.prettierignore
.prettierrc
drizzle.config.ts
package.json
README.md
svelte.config.js
tsconfig.json
vite.config.ts
vitest-setup-client.ts
wrangler.jsonc
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/lib/components/dashboard/DashboardPanel.svelte">
<script lang="ts">
	import { slide } from 'svelte/transition';
	import { SHADOW_ITEM_MARKER_PROPERTY_NAME } from 'svelte-dnd-action';
	import { selectedVideo } from '$lib/stores/selectedVideo';
	import Map from '$lib/components/Map.svelte';
	import { authStore } from '$lib/stores/auth';
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		TableKey,
		TableState
	} from '$lib/types/dashboard';

	interface ProfileMetrics {
		videos: number;
		sounds: number;
		duration: string;
		likes: number;
	}

	interface ActivityItem {
		id: string;
		user: string;
		action: string;
		content: string;
		type: 'like' | 'comment' | string;
		time: string;
	}

	const {
		item,
		collapsed,
		toggleCollapse,
		tableState,
		sortedVideoRows,
		sortedSoundRows,
		sortedMemberRows,
		sortedKeywordRows,
		toggleSort,
		openVideo,
		handleVideoRowKey,
		liveActivity,
		formatStat,
		latestLocations,
		locationCenter,
		profileStats
	} = $props<{
		item: DashboardItem;
		collapsed: Record<DashboardComponentKey, boolean>;
		toggleCollapse: (component: DashboardComponentKey) => void;
		tableState: Record<TableKey, TableState>;
		sortedVideoRows: any[];
		sortedSoundRows: any[];
		sortedMemberRows: any[];
		sortedKeywordRows: any[];
		toggleSort: (table: TableKey, columnKey: string) => void;
		openVideo: (video: any, event?: MouseEvent) => void;
		handleVideoRowKey: (event: KeyboardEvent, video: any) => void;
		liveActivity: ActivityItem[];
		formatStat: (num: number) => string;
		latestLocations: LatestLocationPin[];
		locationCenter: LocationCenter;
		profileStats: ProfileMetrics;
	}>();

	const isShadow = $derived(Boolean(item[SHADOW_ITEM_MARKER_PROPERTY_NAME]));

	const mapPins = $derived(() =>
		latestLocations.map((loc) => ({
			mapLat: loc.lat,
			mapLon: loc.lon,
			setting: loc.setting,
			name: loc.setting,
			videoTitle: loc.videoTitle,
			videoAuthor: loc.videoAuthor
		}))
	);

	const auth = $derived($authStore);

	function createUserId() {
		if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
			return crypto.randomUUID();
		}
		return `user-${Math.random().toString(36).slice(2, 10)}`;
	}

	function resolveAvatar(email: string, avatarUrl?: string) {
		if (avatarUrl) return avatarUrl;
		return `https://i.pravatar.cc/150?u=${encodeURIComponent(email)}`;
	}

	let displayName = $state('');
	let email = $state('');
	let isSubmitting = $state(false);
	let errorMessage = $state<string | null>(null);

	const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
	const MAX_NAME_LENGTH = 100;
	const MAX_EMAIL_LENGTH = 254; // RFC 5321

	function handleAuthSubmit(event: Event) {
		event.preventDefault();
		const nameValue = displayName.trim();
		const emailValue = email.trim().toLowerCase();
		errorMessage = null;

		// Validate name
		if (!nameValue) {
			errorMessage = 'Please enter your name.';
			return;
		}

		if (nameValue.length > MAX_NAME_LENGTH) {
			errorMessage = `Name must be ${MAX_NAME_LENGTH} characters or less.`;
			return;
		}

		// Validate email
		if (!emailValue) {
			errorMessage = 'Please enter your email address.';
			return;
		}

		if (emailValue.length > MAX_EMAIL_LENGTH) {
			errorMessage = 'Email address is too long.';
			return;
		}

		if (!EMAIL_REGEX.test(emailValue)) {
			errorMessage = 'Please enter a valid email address.';
			return;
		}

		isSubmitting = true;
		try {
			authStore.login({
				id: createUserId(),
				name: nameValue,
				email: emailValue,
				avatarUrl: resolveAvatar(emailValue)
			});
			displayName = '';
			email = '';
		} finally {
			isSubmitting = false;
		}
	}

	function handleLogout() {
		authStore.logout();
	}
</script>

{#if isShadow}
	<div class="panel-placeholder" />
{:else if item.component === 'videos'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">{$selectedVideo.id ? 'Next in Queue' : 'Suggested Rushes'}</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.videos.sortKey.toUpperCase()} [{tableState.videos.sortDirection.toUpperCase()}]</span>
				<button on:click={() => toggleCollapse('videos')}>{collapsed.videos ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.videos}
			<div transition:slide>
				{#if sortedVideoRows.length === 0}
					<p class="mt-6 text-[11px] text-slate-500">The queue is clear‚Äîadd new rushes to keep production moving.</p>
				{:else}
					{@const next = sortedVideoRows[0]}
					<div class="mt-6 min-w-0 rounded-2xl overflow-hidden border border-white/10 bg-black/30">
						<div class="flex w-full flex-col gap-5 ">
							<img
								src={next.original.thumbnailUrl ?? 'https://placehold.co/640x360?text=Rushes'}
								alt={next.title}
								class="h-30 w-full object-cover transition duration-300 group-hover:scale-105"
								loading="lazy"
							/>
							<div class="flex min-w-0 flex-1 flex-col justify-between pb-4 px-4">
								<h3 class=" text-lg font-medium text-white">{next.title}</h3>

								<div class="grid min-w-0 mt-0 gap-2 text-[11px] text-slate-300 sm:grid-cols-2">
									<span class="flex items-center gap-2"><span class="h-1.5 w-1.5 rounded-full bg-sky-400"></span> By {next.author}</span>
									<span>{next.uploaded}</span>
								</div>
							</div>
						</div>
					</div>
					<div class="mt-6 min-w-0 space-y-4">
						<div class="grid min-w-0 gap-3 sm:grid-cols-2">
							{#each sortedVideoRows.slice(1, 5) as row, index (row.id)}
								<button
									type="button"
									class="group flex min-w-0 items-center gap-4 rounded-lg overflow-hidden border border-white/5 bg-white/[0.06] text-left transition hover:border-white/15 hover:bg-white/[0.1]"
									on:click={(event) => openVideo(row.original, event)}
									on:keydown={(event) => handleVideoRowKey(event, row.original)}
								>
								<div class="flex flex-col items-center">
										<img
											src={row.original.thumbnailUrl ?? 'https://placehold.co/160x90?text=Rushes'}
											alt={row.title}
											class="h-20 w-full object-cover transition duration-300 group-hover:scale-105"
											loading="lazy"
										/>
										
									<div class="flex flex-col w-full p-3">
										<p class="text-sm font-medium m-0 text-white">{row.title}</p>
										<div class="flex flex-col text-[11px] text-slate-400">
											<span>{row.author}</span>
										</div>
									</div>
									</div>

								</button>
							{/each}
						</div>
						{#if sortedVideoRows.length <= 1}<p class="text-[11px] text-slate-500">No additional items in the queue.</p>{/if}
					</div>
				{/if}
			</div>
		{/if}
	</section>
{:else if item.component === 'profile'}
	<section class="min-w-0  border border-white/10 bg-white/[0.06] p-6 shadow-[0_24px_80px_-48px_rgba(8,47,73,0.85)] backdrop-blur-md">
		{#if auth.user}
			<div class="space-y-6">
				<div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
					<div class="flex items-center gap-4">
						<img
							src={resolveAvatar(auth.user.email, auth.user.avatarUrl)}
							alt="User avatar"
							class="h-16 w-16 rounded-full border-2 border-white/20 object-cover shadow-[0_12px_32px_-18px_rgba(56,189,248,0.65)]"
						/>
						<div>
							<h3 class="text-lg font-semibold text-white">Welcome back, {auth.user.name}</h3>
							<p class="text-sm text-slate-400">{auth.user.email}</p>
						</div>
					</div>
					<button
						class="rounded-full border border-white/15 bg-white/[0.08] px-5 py-2 text-[11px] uppercase tracking-[0.3em] text-slate-200 transition hover:border-white/30 hover:bg-white/[0.14] hover:text-white"
						type="button"
						on:click={handleLogout}
					>
						Sign out
					</button>
				</div>

				<div class="grid grid-cols-2 gap-4">
					{#each [
						{ label: 'VIDEOS', value: formatStat(profileStats.videos) },
						{ label: 'SOUNDS', value: formatStat(profileStats.sounds) },
						{ label: 'TOTAL DURATION', value: profileStats.duration },
						{ label: 'LIKES', value: formatStat(profileStats.likes) }
					] as metric (metric.label)}
						<div class="rounded-2xl border border-white/10 bg-black/25 px-4 py-3 text-left shadow-[0_12px_48px_-36px_rgba(56,189,248,0.45)]">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-400">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>

				<p class="text-[11px] uppercase tracking-[0.3em] text-slate-500">Account controls coming soon.</p>
			</div>
		{:else}
			<div class="space-y-6">
				<div>
					<h3 class="text-lg font-semibold text-white">Join Rushes</h3>
					<p class="mt-1 text-sm text-slate-400">Create an account to sync playlists, follow curators, and save notes.</p>
				</div>
				<form class="space-y-4" on:submit|preventDefault={handleAuthSubmit}>
					<div class="space-y-2">
						<label class="text-[10px] uppercase tracking-[0.3em] text-slate-500" for="dashboard-name">Name</label>
						<input
							id="dashboard-name"
							name="name"
							type="text"
							bind:value={displayName}
							placeholder="Alex Rivera"
							class="w-full rounded-xl border border-white/15 bg-white/[0.08] px-3 py-2 text-sm text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/40 focus:border-transparent"
						/>
					</div>
					<div class="space-y-2">
						<label class="text-[10px] uppercase tracking-[0.3em] text-slate-500" for="dashboard-email">Email</label>
						<input
							id="dashboard-email"
							name="email"
							type="email"
							bind:value={email}
							placeholder="alex@rushes.fm"
							class="w-full rounded-xl border border-white/15 bg-white/[0.08] px-3 py-2 text-sm text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/40 focus:border-transparent"
						/>
					</div>
					{#if errorMessage}
						<p class="text-xs text-rose-400">{errorMessage}</p>
					{/if}
					<button
						type="submit"
						class="w-full rounded-full bg-gradient-to-r from-sky-500 to-purple-500 px-5 py-2 text-[11px] uppercase tracking-[0.35em] text-white shadow-[0_18px_48px_-24px_rgba(56,189,248,0.8)] transition hover:opacity-90 disabled:opacity-50"
						disabled={isSubmitting}
					>
						{isSubmitting ? "Creating account‚Ä¶" : "Create account"}
					</button>
				</form>
				<p class="text-xs text-slate-500">
					We‚Äôll remember your session in this workspace. No actual emails are sent‚Äîthis is a mock authentication flow.
				</p>
			</div>
		{/if}
	</section>
{:else if item.component === 'activity'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex items-center justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Live Activity</p>
			</div>
			<button on:click={() => toggleCollapse('activity')}>{collapsed.activity ? '+' : '-'}</button>
		</header>
		{#if !collapsed.activity}
			<div class="mt-4 space-y-3" transition:slide>
				{#each liveActivity as event (event.id)}
					<div class="flex items-center gap-4 rounded-xl bg-black/20 p-3">
						<div class="flex h-8 w-8 items-center justify-center rounded-full bg-white/5">
							{#if event.type === 'like'}
								<svg class="h-4 w-4 text-pink-400" viewBox="0 0 20 20" fill="currentColor">
									<path d="M9.653 16.915l-.005-.003-.019-.01a20.759 20.759 0 01-1.162-.682 22.045 22.045 0 01-2.582-1.9 22.045 22.045 0 01-2.582-1.9A20.759 20.759 0 013 12.311l-.01-.019a1.002 1.002 0 010-1.415l.006-.006a1 1 0 011.414 0l.006.006a6.67 6.67 0 001.036.634 8.67 8.67 0 005.188 0 6.67 6.67 0 001.036-.634l.006-.006a1 1 0 011.414 0l.006.006a1.002 1.002 0 010 1.415l-.01.019a20.759 20.759 0 01-1.162.682 22.045 22.045 0 01-2.582 1.9 22.045 22.045 0 01-2.582 1.9 20.759 20.759 0 01-1.162.682zM10 11.973a8.67 8.67 0 00-5.188 0 6.67 6.67 0 00-1.036.634l-.006.006a1 1 0 01-1.414 0l-.006-.006a1.002 1.002 0 010-1.415l.01-.019a20.759 20.759 0 011.162-.682 22.045 22.045 0 012.582-1.9 22.045 22.045 0 012.582-1.9A20.759 20.759 0 0110 3.689a1 1 0 011.415 0l.01.01a20.759 20.759 0 011.162.682 22.045 22.045 0 012.582 1.9 22.045 22.045 0 012.582 1.9 20.759 20.759 0 011.162.682l.01.019a1.002 1.002 0 010 1.415l-.006.006a1 1 0 01-1.414 0l-.006-.006a6.67 6.67 0 00-1.036-.634 8.67 8.67 0 00-5.188 0z" />
								</svg>
							{:else}
								<svg class="h-4 w-4 text-sky-400" viewBox="0 0 20 20" fill="currentColor">
									<path fill-rule="evenodd" d="M10 2c-4.418 0-8 3.134-8 7 0 2.033.944 3.863 2.451 5.116a.75.75 0 00.916-1.185A6.47 6.47 0 014.5 9c0-2.899 2.529-5.25 5.5-5.25s5.5 2.351 5.5 5.25c0 1.258-.468 2.404-1.255 3.284a.75.75 0 101.185.916A7.962 7.962 0 0018 9c0-3.866-3.582-7-8-7z" clip-rule="evenodd" />
									<path d="M12.249 14.126a.75.75 0 01.393.972l-1.5 3a.75.75 0 01-1.284-.64l1.5-3a.75.75 0 01.891-.332z" />
									<path d="M14 11.25a.75.75 0 01.75.75v2.5a.75.75 0 01-1.5 0v-2.5a.75.75 0 01.75-.75z" />
									<path d="M8.25 15.126a.75.75 0 01.891.332l1.5 3a.75.75 0 11-1.284.64l-1.5-3a.75.75 0 01.393-.972z" />
									<path d="M6.25 12a.75.75 0 011.5 0v2.5a.75.75 0 01-1.5 0v-2.5z" />
								</svg>
							{/if}
						</div>
						<div class="flex-1 text-xs">
							<p class="text-slate-300">
								<span class="font-semibold text-white">{event.user}</span> {event.action} <span class="font-semibold text-white">‚Äú{event.content}‚Äù</span>
							</p>
							<p class="text-slate-500">{event.time}</p>
						</div>
					</div>
				{/each}
			</div>
		{/if}
	</section>
{:else if item.component === 'sounds'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Latest Sounds</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.sounds.sortKey.toUpperCase()} [{tableState.sounds.sortDirection.toUpperCase()}]</span>
				<button on:click={() => toggleCollapse('sounds')}>{collapsed.sounds ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.sounds}
			<div class="mt-4 min-w-0 rounded-2xl border border-white/10 bg-black/20" transition:slide>
				<div class="min-w-0 overflow-x-auto rounded-2xl">
					<table class="min-w-full border-collapse text-left text-[12px] leading-snug">
						<thead class="bg-white/5 text-slate-500">
							<tr>
								{#each tableState.sounds.columns as column}
									<th scope="col" class={`px-4 py-3 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
										<button
											type="button"
											class="flex items-center gap-2 text-[11px] uppercase tracking-[0.25em] text-slate-500 transition hover:text-slate-200"
											on:click={() => toggleSort('sounds', column.key)}
										>
											<span>{column.label}</span>
											{#if tableState.sounds.sortKey === column.key}<span aria-hidden="true">{tableState.sounds.sortDirection === 'asc' ? '‚ñ≤' : '‚ñº'}</span>{/if}
										</button>
									</th>
								{/each}
							</tr>
						</thead>
						<tbody class="bg-black/20">
							{#each sortedSoundRows as row, index (row.id)}
								<tr class={`${index % 2 === 0 ? 'bg-white/[0.04]' : ''}`}>
									{#each tableState.sounds.columns as column}
										<td class={`px-4 py-3 text-slate-200 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
											{#if column.key === 'title'}<span class="text-slate-100">{row.title}</span>
											{:else if column.key === 'recordist'}<span>{row.recordist}</span>
											{:else if column.key === 'captured'}<span>{row.captured}</span>
											{:else if column.key === 'duration'}<span>{row.duration}</span>{/if}
										</td>
									{/each}
								</tr>
							{/each}
						</tbody>
					</table>
				</div>
			</div>
		{/if}
	</section>
{:else if item.component === 'members'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Members</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.members.sortKey.toUpperCase()} [{tableState.members.sortDirection.toUpperCase()}]</span>
				<button on:click={() => toggleCollapse('members')}>{collapsed.members ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.members}
			<div class="mt-4 min-w-0 rounded-2xl border border-white/10 bg-black/20" transition:slide>
				<div class="min-w-0 overflow-x-auto rounded-2xl">
					<table class="min-w-full border-collapse text-left text-[12px] leading-snug">
						<thead class="bg-white/5 text-slate-500">
							<tr>
								{#each tableState.members.columns as column}
									<th scope="col" class={`px-4 py-3 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
										<button
											type="button"
											class="flex items-center gap-2 text-[11px] uppercase tracking-[0.25em] text-slate-500 transition hover:text-slate-200"
											on:click={() => toggleSort('members', column.key)}
										>
											<span>{column.label}</span>
											{#if tableState.members.sortKey === column.key}<span aria-hidden="true">{tableState.members.sortDirection === 'asc' ? '‚ñ≤' : '‚ñº'}</span>{/if}
										</button>
									</th>
								{/each}
							</tr>
						</thead>
						<tbody class="bg-black/20">
							{#each sortedMemberRows as row, index (row.id)}
								<tr class={`${index % 2 === 0 ? 'bg-white/[0.04]' : ''}`}>
									{#each tableState.members.columns as column}
										<td class={`px-4 py-3 text-slate-200 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
											{#if column.key === 'name'}<span class="text-slate-100">{row.name}</span>
											{:else if column.key === 'videos'}<span>{row.videos}</span>
											{:else if column.key === 'followers'}<span>{row.followers}</span>
											{:else if column.key === 'following'}<span>{row.following}</span>
											{:else if column.key === 'joined'}<span>{row.joined}</span>{/if}
										</td>
									{/each}
								</tr>
							{/each}
						</tbody>
					</table>
				</div>
			</div>
		{/if}
	</section>
{:else if item.component === 'keywords'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Keywords</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.keywords.sortKey.toUpperCase()} [{tableState.keywords.sortDirection.toUpperCase()}]</span>
				<button on:click={() => toggleCollapse('keywords')}>{collapsed.keywords ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.keywords}
			<div class="mt-4 min-w-0 rounded-2xl border border-white/10 bg-black/20" transition:slide>
				<div class="min-w-0 overflow-x-auto rounded-2xl">
					<table class="min-w-full border-collapse text-left text-[12px] leading-snug">
						<thead class="bg-white/5 text-slate-500">
							<tr>
								{#each tableState.keywords.columns as column}
									<th scope="col" class={`px-4 py-3 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
										<button
											type="button"
											class="flex items-center gap-2 text-[11px] uppercase tracking-[0.25em] text-slate-500 transition hover:text-slate-200"
											on:click={() => toggleSort('keywords', column.key)}
										>
											<span>{column.label}</span>
											{#if tableState.keywords.sortKey === column.key}<span aria-hidden="true">{tableState.keywords.sortDirection === 'asc' ? '‚ñ≤' : '‚ñº'}</span>{/if}
										</button>
									</th>
								{/each}
							</tr>
						</thead>
						<tbody class="bg-black/20">
							{#each sortedKeywordRows as row, index (row.keyword)}
								<tr class={`${index % 2 === 0 ? 'bg-white/[0.04]' : ''}`}>
									{#each tableState.keywords.columns as column}
										<td class={`px-4 py-3 text-slate-200 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
											{#if column.key === 'keyword'}<span class="text-slate-100">{row.keyword}</span>
											{:else if column.key === 'usage'}<span>{row.usage.toString().padStart(2, '0')}</span>
											{:else if column.key === 'related'}<span class="text-[10px] text-slate-400/80">{row.related}</span>{/if}
										</td>
									{/each}
								</tr>
							{/each}
						</tbody>
					</table>
				</div>
			</div>
		{/if}
	</section>
{:else if item.component === 'locations'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Latest Locations</p>
					<p class="text-[11px] text-slate-500/70">Recent shoots plotted across the Rushes.fm map.</p>
				</div>
			</div>
			<button on:click={() => toggleCollapse('locations')}>{collapsed.locations ? '+' : '-'}</button>
		</header>
		{#if !collapsed.locations}
			<div class="mt-5 grid gap-6 lg:grid-cols-5" transition:slide>
				<div class="relative min-h-[18rem] overflow-hidden rounded-2xl border border-white/10 bg-black/30 lg:col-span-3">
					<Map
						locations={mapPins}
						initialCenterLat={locationCenter.lat}
						initialCenterLon={locationCenter.lon}
						initialZoom={locationCenter.zoom}
					/>
				</div>
				<div class="space-y-4 lg:col-span-2">
					{#if latestLocations.length === 0}
						<p class="text-[11px] text-slate-500">No geo-tagged videos yet. Pins appear here once locations are available.</p>
					{:else}
						<ul class="space-y-3">
							{#each latestLocations as loc (loc.id)}
								<li class="flex items-start gap-3 rounded-2xl border border-white/10 bg-white/[0.05] p-3">
									{#if loc.thumbnailUrl}
										<img src={loc.thumbnailUrl} alt={loc.videoTitle} class="h-12 w-12 flex-shrink-0 rounded-xl object-cover" loading="lazy" />
									{:else}
										<div class="flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-xl bg-white/10 text-[11px] uppercase tracking-[0.3em] text-white">
											{loc.videoTitle.slice(0, 2)}
										</div>
									{/if}
									<div class="min-w-0 flex-1 space-y-1">
										<p class="text-sm font-medium text-white">{loc.videoTitle}</p>
										<p class="text-[11px] uppercase tracking-[0.25em] text-slate-500">{loc.setting ?? 'On location'}</p>
										<div class="flex flex-wrap gap-3 text-[11px] text-slate-400">
											{#if loc.videoAuthor}<span>{loc.videoAuthor}</span>{/if}
											<span>{loc.uploadedLabel}</span>
										</div>
									</div>
								</li>
							{/each}
						</ul>
					{/if}
				</div>
			</div>
		{/if}
	</section>
{/if}

<style>
	.panel-placeholder {
		min-height: 4rem;
		border-radius: 1rem;
		border: 1px dashed rgba(148, 163, 184, 0.3);
		background-color: rgba(15, 23, 42, 0.2);
	}
</style>
</file>

<file path="src/lib/components/home/AuthSection.svelte">
<script lang="ts">
  let showSignIn = $state(false);
  let showSignUp = $state(false);
  
  // Form states
  let signInForm = $state({
    email: '',
    password: ''
  });
  
  let signUpForm = $state({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  function toggleSignIn() {
    showSignIn = !showSignIn;
    showSignUp = false;
  }
  
  function toggleSignUp() {
    showSignUp = !showSignUp;
    showSignIn = false;
  }
  
  function handleSignIn(e: Event) {
    e.preventDefault();
    console.log('Sign in:', signInForm);
    // TODO: Implement sign in logic
  }
  
  function handleSignUp(e: Event) {
    e.preventDefault();
    console.log('Sign up:', signUpForm);
    // TODO: Implement sign up logic
  }

  // Export functions for external use
  export function openSignIn() {
    showSignIn = true;
    showSignUp = false;
  }

  export function openSignUp() {
    showSignUp = true;
    showSignIn = false;
  }
</script>

<section class="mb-16">
  <div class="text-center mb-8">
    <h2 class="text-2xl font-semibold text-gray-900 dark:text-white mb-4">
      Join the Community
    </h2>
    <p class="text-gray-600 dark:text-gray-400 mb-6">
      Sign up to share your videos, discover new content, and connect with creators
    </p>
    
    <!-- Auth Toggle Buttons -->
    <div class="flex items-center justify-center gap-4">
      <button 
        onclick={toggleSignUp}
        class="rounded-full bg-blue-600 px-6 py-3 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
      >
        Create Account
      </button>
      <button 
        onclick={toggleSignIn}
        class="rounded-full border border-gray-300 dark:border-gray-600 px-6 py-3 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
      >
        Sign In
      </button>
    </div>
  </div>

  <!-- Sign Up Form -->
  {#if showSignUp}
    <div class="mx-auto max-w-md">
      <div class="rounded-xl bg-gray-50 dark:bg-gray-900 p-6 border border-gray-200 dark:border-gray-800">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Create Your Account</h3>
        <form onsubmit={handleSignUp} class="space-y-4">
          <div>
            <label for="signup-name" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Full Name
            </label>
            <input
              id="signup-name"
              type="text"
              bind:value={signUpForm.name}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your full name"
            />
          </div>
          
          <div>
            <label for="signup-email" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Email Address
            </label>
            <input
              id="signup-email"
              type="email"
              bind:value={signUpForm.email}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your email"
            />
          </div>
          
          <div>
            <label for="signup-password" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Password
            </label>
            <input
              id="signup-password"
              type="password"
              bind:value={signUpForm.password}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Create a password"
            />
          </div>
          
          <div>
            <label for="signup-confirm" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Confirm Password
            </label>
            <input
              id="signup-confirm"
              type="password"
              bind:value={signUpForm.confirmPassword}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Confirm your password"
            />
          </div>
          
          <button
            type="submit"
            class="w-full rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
          >
            Create Account
          </button>
        </form>
        
        <button 
          onclick={() => showSignUp = false}
          class="mt-4 w-full text-sm text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 transition-colors"
        >
          Cancel
        </button>
      </div>
    </div>
  {/if}

  <!-- Sign In Form -->
  {#if showSignIn}
    <div class="mx-auto max-w-md">
      <div class="rounded-xl bg-gray-50 dark:bg-gray-900 p-6 border border-gray-200 dark:border-gray-800">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Welcome Back</h3>
        <form onsubmit={handleSignIn} class="space-y-4">
          <div>
            <label for="signin-email" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Email Address
            </label>
            <input
              id="signin-email"
              type="email"
              bind:value={signInForm.email}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your email"
            />
          </div>
          
          <div>
            <label for="signin-password" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Password
            </label>
            <input
              id="signin-password"
              type="password"
              bind:value={signInForm.password}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your password"
            />
          </div>
          
          <button
            type="submit"
            class="w-full rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
          >
            Sign In
          </button>
        </form>
        
        <div class="mt-4 text-center">
          <button class="text-sm text-blue-600 dark:text-blue-400 hover:text-blue-500 dark:hover:text-blue-300 transition-colors">
            Forgot your password?
          </button>
        </div>
        
        <button 
          onclick={() => showSignIn = false}
          class="mt-4 w-full text-sm text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 transition-colors"
        >
          Cancel
        </button>
      </div>
    </div>
  {/if}
</section>
</file>

<file path="src/lib/components/home/FeaturedChannels.svelte">
<script lang="ts">
  import { usersStore } from '$lib/stores/library';

  function formatCount(value: number) {
    if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1)}M`;
    if (value >= 1_000) return `${(value / 1_000).toFixed(1)}K`;
    return value.toString();
  }

  const featuredChannels = $derived(
    $usersStore.slice(0, 4).map((user) => ({
      id: user.id,
      name: user.name,
      description: user.bio,
      avatar: user.avatar,
      subscribers: formatCount(user.stats?.followers ?? 0),
      videos: user.stats?.videos ?? 0
    }))
  );
</script>

<section class="py-16 bg-gray-50 dark:bg-gray-900">
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    <div class="mx-auto max-w-2xl text-center">
      <h2 class="text-3xl font-bold tracking-tight text-gray-900 dark:text-white sm:text-4xl">
        Featured Channels
      </h2>
      <p class="mt-4 text-lg leading-8 text-gray-600 dark:text-gray-300">
        Discover amazing creators and their unique perspectives
      </p>
    </div>
    
    <div class="mx-auto mt-12 grid max-w-2xl grid-cols-1 gap-8 lg:mx-0 lg:max-w-none lg:grid-cols-2">
      {#each featuredChannels as channel}
        <div class="group relative overflow-hidden rounded-2xl bg-white dark:bg-gray-800 p-6 shadow-sm hover:shadow-lg transition-all duration-300">
          <div class="flex items-start gap-4">
      
            
            <div class="flex-1 min-w-0">
              <div class="flex items-center gap-2">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-white group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">
                  {channel.name}
                </h3>
           
              </div>
              
              <p class="mt-1 text-sm text-gray-600 dark:text-gray-400">
                {channel.description}
              </p>
              
              <div class="mt-3 flex items-center gap-4 text-sm text-gray-500 dark:text-gray-400">
                <span class="flex items-center gap-1">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
                  </svg>
                  {channel.subscribers} subscribers
                </span>
                <span class="flex items-center gap-1">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                  </svg>
                  {channel.videos} videos
                </span>
              </div>
              
            
            </div>
          </div>
          
          <div class="mt-6 flex gap-3">
            <a 
              href={`/users/${channel.id}`}
              class="flex-1 rounded-lg border border-gray-300 dark:border-gray-600 px-4 py-2 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors text-center"
            >
              View Channel
            </a>
          </div>
        </div>
      {/each}
    </div>
  </div>
</section>
</file>

<file path="src/lib/components/home/GeneratedChannels.svelte">
<script lang="ts">
  // Generate channels based on different criteria
  const generatedChannels = [
    {
      id: 'tokyo-streets',
      title: 'Around Tokyo - This Year',
      type: 'location',
      description: 'Unedited footage from Tokyo',
      location: 'Tokyo, Japan',
      videoCount: 12,
      thumbnails: [
        'https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1513407030348-c983a97b98d8?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1542051841857-5f90071e7989?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1503899036084-c55cdd92da26?w=200&h=112&fit=crop'
      ],
      generatedAt: '2024-01-15',
      badge: 'üìç'
    },
    {
      id: 'digital-art-week',
      title: 'Digital Art Week',
      type: 'keyword',
      description: 'Creative digital art processes and studio sessions',
      keyword: 'digital art',
      videoCount: 8,
      thumbnails: [
        'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1561736778-92e52a7769ef?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1550745165-9bc0b252726f?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=200&h=112&fit=crop'
      ],
      generatedAt: '2024-01-14',
      badge: 'üé®'
    },
    {
      id: 'urban-exploration',
      title: 'Urban Exploration',
      type: 'vibe',
      description: 'Raw footage of abandoned places and hidden urban gems',
      query: 'abandoned urban exploration architecture',
      videoCount: 15,
      thumbnails: [
        'https://images.unsplash.com/photo-1449824913935-59a10b8d2000?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1487958449943-2429e8be8625?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1511818966892-d7d671e672a2?w=200&h=112&fit=crop'
      ],
      generatedAt: '2024-01-13',
      badge: 'üèóÔ∏è'
    }
  ];

  function handleChannelClick(channelId: string) {
    // For now, just navigate to a channel page
    window.location.href = `/channels/${channelId}`;
  }

  function formatDate(dateString: string) {
    return new Date(dateString).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    });
  }
</script>

<section class="mb-16">
  <div class="text-center mb-8">
    <h2 class="text-2xl font-semibold text-gray-900 dark:text-white mb-2">
      This Week's Featured Channels
    </h2>
  
  </div>

  <div class="space-y-4">
    {#each generatedChannels as channel}
      <div class="group cursor-pointer">
        <button
          onclick={() => handleChannelClick(channel.id)}
          class="w-full text-left border-t p-4 pb-1 transition-colors  border-gray-200/10 "
        >
          <div class="flex items-center justify-between w-full gap-4">
            <!-- Channel Badge -->
            <!--<div class="text-xl flex-shrink-0">{channel.badge}</div>
-->
            <!-- Overlapping Thumbnails -->
            <div class="flex -space-x-2 flex-shrink-0">
              {#each channel.thumbnails.slice(0, 5) as thumbnail, index}
                <div class="relative h-8 w-8  overflow-hidden rounded-full bg-gray-900 border-2 border-white dark:border-gray-900 shadow-sm">
                  <img
                    src={thumbnail}
                    alt="Video thumbnail {index + 1}"
                    class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                  />
                </div>
              {/each}
            </div>

            <!-- Channel Info -->
            <div class="flex-1 min-w-0">
              <div class="flex items-center justify-end gap-2 mb-1">
                <h3 class="text-base font-semibold text-gray-900 dark:text-white group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors truncate">
                  {channel.title}
                </h3>

                <!-- Type Badge -->
                {#if channel.type === 'location'}
                  <span class="inline-flex items-center rounded-full bg-green-100 dark:bg-green-900 px-2 py-0.5 text-xs font-medium text-green-800 dark:text-green-200 flex-shrink-0">
                    Location
                  </span>
                {:else if channel.type === 'keyword'}
                  <span class="inline-flex items-center rounded-full bg-blue-100 dark:bg-blue-900 px-2 py-0.5 text-xs font-medium text-blue-800 dark:text-blue-200 flex-shrink-0">
                    Keyword
                  </span>
                {:else if channel.type === 'vibe'}
                  <span class="inline-flex items-center rounded-full bg-purple-100 dark:bg-purple-900 px-2 py-0.5 text-xs font-medium text-purple-800 dark:text-purple-200 flex-shrink-0">
                    Vibe
                  </span>
                {/if}
              </div>

              

               <div class="flex items-center justify-end gap-3 text-xs text-gray-500 dark:text-gray-400">
                <span>{channel.videoCount} videos</span>
                <span>‚Ä¢</span>
                <span>Generated {formatDate(channel.generatedAt)}</span>
                {#if channel.type === 'location'}
                  <span>‚Ä¢</span>
                  <span>{channel.location}</span>
                {:else if channel.type === 'keyword'}
                  <span>‚Ä¢</span>
                  <span>#{channel.keyword}</span>
                {/if}
              </div>
  <!-- <p class="text-sm text-gray-600 dark:text-gray-400 truncate mb-1">
                {channel.description}
              </p> -->

              
            
            </div>

            <!-- Arrow -->
            <div class="flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
              <svg class="h-5 w-5 text-gray-400 group-hover:text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </div>
          </div>
        </button>
      </div>
    {/each}
  </div>

  
</section>
</file>

<file path="src/lib/components/home/HeroSection.svelte">
<script lang="ts">
  import { videosStore } from '$lib/stores/library';

  const fallbackVideo = {
    id: 'placeholder',
    title: 'Featured Video',
    author: 'Creator',
    thumbnailUrl: 'https://placehold.co/800x450?text=Rushes'
  };

  const featuredVideo = $derived(($videosStore[0] ?? fallbackVideo));
</script>

<section class="relative overflow-hidden bg-black">
  <!-- Subtle dot pattern overlay -->
  <div class="absolute inset-0 opacity-30" style="background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,.6) 1px, transparent 0); background-size: 20px 20px;"></div>

  <!-- Additional subtle gradient overlay -->
  <div class="absolute inset-0 bg-gradient-to-br from-gray-900/50 via-transparent to-gray-900/50"></div>
  
  <div class="relative px-6 py-16 lg:py-24">
    <div class="mx-auto max-w-4xl text-center">
      <h1 class="text-4xl font-bold tracking-tight text-white sm:text-6xl">
         <span class="text-blue-400">Rushes</span>
      </h1>
      <p class="mt-6 text-lg leading-8 text-gray-300">
      </p>
      
      <div class="mt-10 flex items-center justify-center gap-x-6">
        <a
          href="/videos"
          class="rounded-full bg-white px-6 py-3 text-sm font-semibold text-gray-900 shadow-sm hover:bg-gray-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white transition-all"
        >
          Explore Videos
        </a>
        <a
          href={`/videos/${featuredVideo.id}`}
          class="text-sm font-semibold leading-6 text-white hover:text-blue-400 transition-colors"
        >
          Watch Featured <span aria-hidden="true">‚Üí</span>
        </a>
      </div>
    </div>
    
    <!-- Featured Video Preview -->
    <div class="mx-auto mt-16 max-w-2xl">
      <div class="relative rounded-xl bg-gray-900/40 backdrop-blur-sm p-4 border border-gray-800/50">
        <div class="aspect-video overflow-hidden rounded-lg bg-gray-900">
          <img
            src={featuredVideo.thumbnailUrl ?? fallbackVideo.thumbnailUrl}
            alt={featuredVideo.title}
            class="h-full w-full object-cover"
          />
          <div class="absolute inset-0 flex items-center justify-center">
            <button class="rounded-full bg-black/60 p-4 backdrop-blur-sm hover:bg-black/80 transition-colors border border-gray-600" aria-label="Play featured video">
              <svg class="h-8 w-8 text-white" fill="currentColor" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="mt-4 text-center">
          <h3 class="text-lg font-semibold text-white">{featuredVideo.title}</h3>
          <p class="text-sm text-gray-400">by {featuredVideo.author}</p>
        </div>
      </div>
    </div>
  </div>
</section>
</file>

<file path="src/lib/components/home/StatsSection.svelte">
<script lang="ts">
  // Mock platform statistics
  const stats = [
    {
      name: 'Total Videos',
      value: '12,847',
      change: '+12%',
      changeType: 'increase',
      icon: 'M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z'
    },
    {
      name: 'Active Creators',
      value: '2,341',
      change: '+8%',
      changeType: 'increase',
      icon: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z'
    },
    {
      name: 'Hours Watched',
      value: '847K',
      change: '+23%',
      changeType: 'increase',
      icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z'
    },
    {
      name: 'Community Members',
      value: '89,432',
      change: '+15%',
      changeType: 'increase',
      icon: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z'
    }
  ];
</script>

<section class="border-t border-gray-200 dark:border-gray-800 bg-gray-50 dark:bg-gray-900 py-12">
  <div class="mx-auto max-w-4xl px-6">
    <div class="grid grid-cols-2 gap-8 lg:grid-cols-4">
      {#each stats as stat}
        <div class="text-center">
          <!-- Value -->
          <div class="text-2xl font-bold text-gray-900 dark:text-white">
            {stat.value}
          </div>
          <div class="mt-1 text-sm text-gray-600 dark:text-gray-400">
            {stat.name}
          </div>
        </div>
      {/each}
    </div>

    <!-- Footer -->
    <div class="mt-8 text-center">
      <p class="text-xs text-gray-500 dark:text-gray-400">
        ¬© 2024 Rushes. A community for video creators and enthusiasts.
      </p>
    </div>
  </div>
</section>
</file>

<file path="src/lib/components/Barcode.svelte">
<script>
    let videoElement;
    let barcodeCanvas;

    let isProcessing = false;
    let progress = 0;
    let barcodeDataUrl = null; // This will hold the final image data

    // These dimensions control the final barcode image
    const BARCODE_WIDTH = 1200; // The number of "slices" to take
    const BARCODE_HEIGHT = 200; // The height of the final image

    async function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        isProcessing = true;
        progress = 0;
        barcodeDataUrl = null;

        // Clean up any previous object URL
        if (videoElement.src) {
            URL.revokeObjectURL(videoElement.src);
        }

        // Load the video file into the hidden <video> element
        const fileURL = URL.createObjectURL(file);
        videoElement.src = fileURL;

        // The 'loadedmetadata' event will fire, triggering generateBarcode()
    }

    /**
     * Helper function to wait for the video to seek to a new time.
     * We wrap this in a Promise to use it with async/await.
     */
    function seekVideo(time) {
        return new Promise((resolve, reject) => {
            // Set up event listeners *before* changing currentTime
            videoElement.onseeked = () => resolve(true);
            videoElement.onerror = (e) => reject(e);

            videoElement.currentTime = time;
        });
    }

    /**
     * This function runs once the video's duration and dimensions are known.
     */
    async function generateBarcode() {
        console.log("Video metadata loaded. Starting barcode generation...");

        const duration = videoElement.duration;
        const videoWidth = videoElement.videoWidth;
        const videoHeight = videoElement.videoHeight;

        // 1. Set up the final canvas
        barcodeCanvas.width = BARCODE_WIDTH;
        barcodeCanvas.height = BARCODE_HEIGHT;
        const ctx = barcodeCanvas.getContext("2d");

        // 2. Create a hidden, in-memory canvas to draw full frames
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = videoWidth;
        tempCanvas.height = videoHeight;
        const tempCtx = tempCanvas.getContext("2d");

        const interval = duration / BARCODE_WIDTH;

        // 3. Loop through, seeking and sampling
        for (let i = 0; i < BARCODE_WIDTH; i++) {
            const time = i * interval;

            try {
                await seekVideo(time);

                // Draw the full video frame onto the temporary canvas
                tempCtx.drawImage(videoElement, 0, 0, videoWidth, videoHeight);

                // Draw a 1px slice from the *center* of the temp canvas
                // onto the final barcode canvas.
                // We stretch the slice's height to fit our barcode height.
                ctx.drawImage(
                    tempCanvas, // Source canvas
                    videoWidth / 2,
                    0, // Source (x, y) - from center
                    1,
                    videoHeight, // Source (width, height) - 1px wide slice
                    i,
                    0, // Destination (x, y) - at column 'i'
                    1,
                    BARCODE_HEIGHT, // Destination (width, height) - 1px wide, stretched
                );
            } catch (error) {
                console.error("Error seeking or drawing frame:", error);
                // Continue to the next frame
            }

            // Update progress
            progress = (i / BARCODE_WIDTH) * 100;
        }

        // 4. Done. Export the final canvas to an image.
        console.log("Barcode generation complete.");
        isProcessing = false;
        progress = 100;
        barcodeDataUrl = barcodeCanvas.toDataURL("image/png");

        // Clean up the object URL to free memory
        URL.revokeObjectURL(videoElement.src);
        videoElement.src = "";
    }
</script>

<div class="barcode-generator">
    <h2>Movie Barcode Generator (In-Browser)</h2>
    <p>Select a video file. Processing happens entirely on your computer.</p>

    <input
        type="file"
        accept="video/mp4,video/webm,video/ogg"
        on:change={handleFileSelect}
        disabled={isProcessing}
    />

    {#if isProcessing}
        <div class="progress-bar">
            <p>Processing... {Math.round(progress)}%</p>
            <progress value={progress} max="100"></progress>
        </div>
    {/if}

    {#if barcodeDataUrl}
        <div class="result">
            <h3>Your Barcode:</h3>
            <img src={barcodeDataUrl} alt="Movie Barcode" />
            <a
                href={barcodeDataUrl}
                download="movie-barcode.png"
                class="download-btn"
            >
                Download Barcode
            </a>
        </div>
    {/if}
</div>

<video
    bind:this={videoElement}
    on:loadedmetadata={generateBarcode}
    style="display: none;"
    muted
    preload="auto"
></video>

<canvas bind:this={barcodeCanvas} style="display: none;"></canvas>

<style>
    .barcode-generator {
        font-family: sans-serif;
        max-width: 800px;
        margin: 2em auto;
        padding: 1em;
        border: 1px solid #ccc;
        border-radius: 8px;
    }
    input[type="file"] {
        margin-bottom: 1em;
    }
    .progress-bar {
        margin: 1em 0;
    }
    progress {
        width: 100%;
    }
    .result img {
        width: 100%;
        height: auto;
        border: 1px solid #eee;
        margin-top: 1em;
    }
    .download-btn {
        display: inline-block;
        margin-top: 1em;
        padding: 0.8em 1.2em;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border-radius: 4px;
        font-weight: bold;
    }
    .download-btn:hover {
        background-color: #0056b3;
    }
</style>
</file>

<file path="src/lib/components/CollapsibleHeading.svelte">
<script lang="ts">
  import { slide } from 'svelte/transition';
  import { cubicOut } from 'svelte/easing';

  export let title: string;
  export let isOpen: boolean;
  export let actionButton: { text: string; icon?: string; href?: string } | null = null;
</script>

<!-- <div class="flex items-center justify-between border-t border-gray-200 dark:border-gray-100/10 py-4 "> -->
 <div class="flex items-center justify-between  ">
  <button 
    class="flex items-center w-full gap-2 pb-5"
    onclick={() => isOpen = !isOpen}
  >
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      width="10" 
      height="10" 
      fill="currentColor" 
      class="text-black/30 dark:text-white -rotate-90 transition-transform duration-200" 
      class:rotate-0={isOpen}
      viewBox="0 0 16 16"
    >
      <path d="M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z"/>
    </svg>
    <h3 class="text-sm  font-medium dark:text-neutral-200">{title}</h3>
  </button>
  {#if actionButton}
    {#if actionButton.href}
      <a 
        href={actionButton.href}
        class="text-xs dark:text-neutral-400 hover:text-white transition-colors flex flex-shrink-0 w-auto items-center gap-1"
      >
        {#if actionButton.icon}
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
            <path d={actionButton.icon} />
          </svg>
        {/if}
        {actionButton.text}
      </a>
    {:else}
      <button class="text-xs dark:text-neutral-400 hover:text-white transition-colors flex flex-shrink-0 w-auto items-center gap-1">
        {#if actionButton.icon}
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
            <path d={actionButton.icon} />
          </svg>
        {/if}
        {actionButton.text}
      </button>
    {/if}
  {/if}
</div>

{#if isOpen}
  <div 
    transition:slide={{ 
      duration: 200,
      easing: cubicOut
    }}
  >
    <slot />
  </div>
{/if}
</file>

<file path="src/lib/components/Header.svelte">
<script lang="ts">
  import { theme } from '$lib/stores/theme';

  interface Props {
    ontoggleSidebar?: () => void;
  }

  let { ontoggleSidebar }: Props = $props();

  function toggleTheme() {
    theme.toggle();
  }

  function openMobileSidebar() {
    ontoggleSidebar?.();
  }
</script>

<header class="z-40 text-black dark:text-white border-b-[0.5px] border-gray-200 dark:border-gray-800/20 py-4 pb-3 mx-6 flex justify-between items-center">
  <!-- Mobile menu button - only visible on mobile -->

  <!-- Mobile title with logo - visible on mobile -->
  <div class="lg:hidden flex items-center gap-2" onclick={openMobileSidebar}>
    <img src="/rushes.svg" alt="Rushes Logo" class="h-5 w-5 mr-0" />
    <!-- <span class="text-base font-normal" style="font-size: 14px; line-height: 0px">Rushes</span> -->
  </div>

  <!-- Theme toggle button -->
  <!-- <button
    class="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition-colors"
    on:click={toggleTheme}
    aria-label="Toggle theme"
  >
    {#if $theme === 'dark'}
      <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
      </svg>
    {:else}
      <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
      </svg>
    {/if}
  </button> -->
</header>
</file>

<file path="src/lib/components/LocationPicker.svelte">
<script lang="ts">
	import { browser } from '$app/environment';
	import { onMount, onDestroy } from 'svelte';
	import type mapboxgl from 'mapbox-gl';
	import 'mapbox-gl/dist/mapbox-gl.css';

	interface Props {
		latitude?: number;
		longitude?: number;
		onLocationChange?: (lat: number, lon: number) => void;
	}

	let { latitude, longitude, onLocationChange }: Props = $props();

	let container = $state<HTMLDivElement | null>(null);
	let map: mapboxgl.Map | null = null;
	let marker: mapboxgl.Marker | null = null;
	let mapError = $state<string | null>(null);
	const initialLat = typeof latitude === 'number' ? latitude : null;
	const initialLon = typeof longitude === 'number' ? longitude : null;
	const initialHasCoords =
		initialLat != null &&
		initialLon != null &&
		coordinatesInRange(initialLat, initialLon);
	let currentLat = $state<number | null>(initialHasCoords ? initialLat : null);
	let currentLon = $state<number | null>(initialHasCoords ? initialLon : null);

	const token =
		import.meta.env.PUBLIC_MAPBOX_ACCESS_TOKEN ??
		import.meta.env.VITE_MAPBOX_TOKEN ??
		import.meta.env.VITE_PUBLIC_MAPBOX_ACCESS_TOKEN ??
		'';

	const mapStyle =
		import.meta.env.VITE_MAPBOX_STYLE ??
		import.meta.env.PUBLIC_MAPBOX_STYLE ??
		'mapbox://styles/mapbox/dark-v11';

	let mapboxModule: typeof mapboxgl | null = null;

	function coordinatesInRange(lat: number, lon: number): boolean {
		return (
			Number.isFinite(lat) &&
			Number.isFinite(lon) &&
			Math.abs(lat) <= 90 &&
			Math.abs(lon) <= 180
		);
	}

	function updateMarker(
		lat: number,
		lon: number,
		options: { notify?: boolean; animate?: boolean } = {}
	) {
		if (!map || !mapboxModule) return;
		if (!coordinatesInRange(lat, lon)) return;

		currentLat = lat;
		currentLon = lon;

		if (marker) {
			marker.setLngLat([lon, lat]);
		} else {
			marker = new mapboxModule.Marker({ color: '#f59e0b', draggable: true })
				.setLngLat([lon, lat])
				.addTo(map);

			marker.on('dragend', () => {
				if (!marker) return;
				const lngLat = marker.getLngLat();
				updateMarker(lngLat.lat, lngLat.lng, { animate: false, notify: true });
			});
		}

		const animate = options.animate ?? true;
		const zoom = map.getZoom ? Math.max(map.getZoom(), 12) : 12;
		const move = () => {
			if (animate) {
				map.easeTo({ center: [lon, lat], zoom, duration: 800 });
			} else {
				map.jumpTo({ center: [lon, lat], zoom });
			}
		};

		if (map.isStyleLoaded()) {
			move();
		} else {
			map.once('load', move);
		}

		if (options.notify ?? true) {
			onLocationChange?.(lat, lon);
		}
	}

	onMount(async () => {
		if (!browser || !container) return;
		if (!token) {
			mapError = 'Missing Mapbox access token';
			return;
		}

		try {
			const module = await import('mapbox-gl');
			mapboxModule = module.default as typeof mapboxgl;
			const Mapbox = mapboxModule;

			if (!Mapbox) {
				mapError = 'Unable to load Mapbox library';
				return;
			}

			Mapbox.accessToken = token;
			const lat = typeof latitude === 'number' ? latitude : null;
			const lon = typeof longitude === 'number' ? longitude : null;
			const hasCoords = lat != null && lon != null && coordinatesInRange(lat, lon);
			const startLat = hasCoords && lat != null ? lat : 0;
			const startLon = hasCoords && lon != null ? lon : 0;
			map = new Mapbox.Map({
					container,
					style: mapStyle,
					center: [startLon, startLat],
					zoom: hasCoords ? 12 : 2,
					cooperativeGestures: false
				});

			map.once('load', () => {
					const loadLat = typeof latitude === 'number' ? latitude : null;
					const loadLon = typeof longitude === 'number' ? longitude : null;
					if (loadLat != null && loadLon != null && coordinatesInRange(loadLat, loadLon)) {
						updateMarker(loadLat, loadLon, { notify: false });
					}
				});

			// Add click handler to place/move marker
			map.on('click', (e) => {
				updateMarker(e.lngLat.lat, e.lngLat.lng);
			});

			// Add geolocation control
			const geolocate = new Mapbox.GeolocateControl({
				positionOptions: {
					enableHighAccuracy: true
				},
				trackUserLocation: false,
				showUserHeading: false
			});

			map.addControl(geolocate);

			// Listen for geolocation success
			geolocate.on('geolocate', (e: any) => {
				updateMarker(e.coords.latitude, e.coords.longitude);
			});

			// Add navigation controls
			map.addControl(new Mapbox.NavigationControl(), 'top-right');

		} catch (error) {
			console.error('Failed to initialize map:', error);
			mapError = 'Unable to render the interactive map';
		}
	});

	// Update marker when props change
	$effect(() => {
		const lat = typeof latitude === 'number' ? latitude : null;
		const lon = typeof longitude === 'number' ? longitude : null;

		if (lat != null && lon != null && coordinatesInRange(lat, lon)) {
			currentLat = lat;
			currentLon = lon;

			if (map && mapboxModule) {
				updateMarker(lat, lon, { notify: false });
			}
		} else if (latitude == null || longitude == null) {
			currentLat = null;
			currentLon = null;
			if (marker) {
				marker.remove();
				marker = null;
			}
		}
	});

	onDestroy(() => {
		marker?.remove();
		map?.remove();
		map = null;
		marker = null;
	});
</script>

<div class="location-picker">
	<div bind:this={container} class="map-container" role="presentation"></div>
	{#if mapError}
		<div class="map-error">
			<p>{mapError}</p>
		</div>
	{/if}
	<div class="coordinates">
		{#if currentLat != null && currentLon != null}
			<span class="coord-label">Location:</span>
			<span class="coord-value">{currentLat?.toFixed(6)}, {currentLon?.toFixed(6)}</span>
		{:else}
			<span class="coord-label">Click on the map to set a location</span>
		{/if}
	</div>
</div>

<style>
	.location-picker {
		position: relative;
		width: 100%;
		height: 400px;
		border-radius: 12px;
		overflow: hidden;
		border: 1px solid rgba(148, 163, 184, 0.2);
	}

	.map-container {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
	}

	.map-error {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		display: flex;
		align-items: center;
		justify-content: center;
		background: rgba(15, 23, 42, 0.95);
		color: #fca5a5;
		padding: 1.5rem;
		text-align: center;
		z-index: 10;
	}

	.coordinates {
		position: absolute;
		bottom: 1rem;
		left: 50%;
		transform: translateX(-50%);
		background: rgba(15, 23, 42, 0.95);
		border: 1px solid rgba(148, 163, 184, 0.3);
		border-radius: 9999px;
		padding: 0.5rem 1rem;
		font-size: 0.875rem;
		color: #e2e8f0;
		backdrop-filter: blur(8px);
		display: flex;
		gap: 0.5rem;
		align-items: center;
		z-index: 5;
		pointer-events: none;
	}

	.coord-label {
		color: rgba(226, 232, 240, 0.7);
	}

	.coord-value {
		color: #5eead4;
		font-weight: 500;
		font-variant-numeric: tabular-nums;
	}

	@media (max-width: 640px) {
		.location-picker {
			height: 300px;
		}

		.coordinates {
			font-size: 0.75rem;
			padding: 0.375rem 0.75rem;
		}
	}
</style>
</file>

<file path="src/lib/components/Map.svelte">
<script lang="ts">
	import { browser } from '$app/environment';
	import { onDestroy, onMount } from 'svelte';
	import type mapboxgl from 'mapbox-gl';
	import 'mapbox-gl/dist/mapbox-gl.css';

	interface Location {
		mapLat?: number;
		mapLon?: number;
		latitude?: number;
		longitude?: number;
		coordinates?: [number, number];
		setting?: string;
		name?: string;
		videoTitle?: string;
		videoAuthor?: string;
		videoId?: string;
	}

	interface Props {
		locations?: Location[];
		initialCenterLat?: number;
		initialCenterLon?: number;
		initialZoom?: number;
		activeVideoId?: string | null;
	}

  const props = $props<Props>();

  let locations = $state(props.locations ?? []);
  let initialCenterLat = $state(props.initialCenterLat ?? 0);
  let initialCenterLon = $state(props.initialCenterLon ?? 0);
  let initialZoom = $state(props.initialZoom ?? 2);
  let activeVideoId = $state(props.activeVideoId ?? null);

  $effect(() => {
    locations = props.locations ?? [];
    initialCenterLat = props.initialCenterLat ?? 0;
    initialCenterLon = props.initialCenterLon ?? 0;
    initialZoom = props.initialZoom ?? 2;
    activeVideoId = props.activeVideoId ?? null;
  });

	let container = $state<HTMLDivElement | null>(null);
	let map: mapboxgl.Map | null = null;
	let markers: mapboxgl.Marker[] = [];
	let mapError = $state<string | null>(null);
	let mapReady = $state(false);
	let lastFocusedVideoId = $state<string | null>(null);

	const token =
		import.meta.env.PUBLIC_MAPBOX_ACCESS_TOKEN ??
		import.meta.env.VITE_MAPBOX_TOKEN ??
		import.meta.env.VITE_PUBLIC_MAPBOX_ACCESS_TOKEN ??
		'';

	const mapStyle =
		import.meta.env.VITE_MAPBOX_STYLE ??
		import.meta.env.PUBLIC_MAPBOX_STYLE ??
		'mapbox://styles/mapbox/dark-v11'; // Fallback to public style

	function normaliseCoordinates(loc: Location): [number, number] | null {
		if (typeof loc.mapLon === 'number' && typeof loc.mapLat === 'number') {
			return [loc.mapLon, loc.mapLat];
		}
		if (typeof loc.longitude === 'number' && typeof loc.latitude === 'number') {
			return [loc.longitude, loc.latitude];
		}
		// Coordinates array is already in GeoJSON standard format: [lon, lat]
		if (Array.isArray(loc.coordinates) && loc.coordinates.length === 2) {
			return [loc.coordinates[0], loc.coordinates[1]];
		}
		return null;
	}

	function clearMarkers() {
		markers.forEach((marker) => marker.remove());
		markers = [];
	}

  // Simple HTML sanitization - escapes dangerous characters
  function escapeHtml(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, (char) => map[char]);
  }

  function syncMarkers(currentLocations: Location[] = []) {
    if (!map) return;
    clearMarkers();
    for (const loc of currentLocations) {
			const coords = normaliseCoordinates(loc);
			if (!coords) continue;
			const [lon, lat] = coords;
			const Mapbox = mapboxModule;
			if (!Mapbox) continue;
			const marker = new Mapbox.Marker({ color: '#f59e0b' })
				.setLngLat([lon, lat]);
			const popupContent: string[] = [];
			// Sanitize all user-provided content
			if (loc.setting || loc.name) {
				popupContent.push(`<strong>${escapeHtml(loc.setting ?? loc.name ?? '')}</strong>`);
			}
			if (loc.videoTitle) {
				popupContent.push(`<div>${escapeHtml(loc.videoTitle)}</div>`);
			}
			if (loc.videoAuthor) {
				popupContent.push(`<small>${escapeHtml(loc.videoAuthor)}</small>`);
			}
			if (popupContent.length > 0) {
				marker.setPopup(new Mapbox.Popup({ offset: 16 }).setHTML(popupContent.join('')));
			}
			marker.addTo(map);
			markers.push(marker);
		}
	}

	let mapboxModule: typeof mapboxgl | null = null;

	function findLocationByVideoId(videoId: string | null): Location | null {
		if (!videoId) return null;
		return (
			locations.find((loc) => (loc as any).videoId === videoId) ?? null
		);
	}

	function focusOnVideo(
	videoId: string | null,
	{ instant = false, force = false }: { instant?: boolean; force?: boolean } = {}
) {
	if (!map || !mapReady || !videoId) return;
	const location = findLocationByVideoId(videoId);
	if (!location) return;
	const coords = normaliseCoordinates(location);
	if (!coords) return;
	const [lon, lat] = coords;
	const targetZoom = Math.max(map.getZoom(), initialZoom, 10);
	if (instant) {
		map.jumpTo({ center: [lon, lat], zoom: targetZoom });
	} else if (force || videoId !== lastFocusedVideoId) {
		map.flyTo({
			center: [lon, lat],
			zoom: targetZoom,
			speed: 0.9,
			curve: 1.4,
			easing: (t) => 1 - Math.pow(1 - t, 3),
			essential: true
		});
	}
	lastFocusedVideoId = videoId;
}

	onMount(async () => {
		if (!browser || !container) return;
		if (!token) {
			mapError = 'Missing Mapbox access token. Set PUBLIC_MAPBOX_ACCESS_TOKEN to enable the map view.';
			return;
		}

		try {
			const module = await import('mapbox-gl');
			mapboxModule = module.default as typeof mapboxgl;
			const Mapbox = mapboxModule;
			if (!Mapbox) {
				mapError = 'Unable to load the Mapbox library.';
				return;
			}
			Mapbox.accessToken = token;
			map = new Mapbox.Map({
				container,
				style: mapStyle,
				center: [initialCenterLon, initialCenterLat],
				zoom: initialZoom,
				cooperativeGestures: true
			});
			map.once('load', () => {
				mapReady = true;
				syncMarkers(locations);
				if (activeVideoId) {
					requestAnimationFrame(() => focusOnVideo(activeVideoId, { force: true }));
				}
			});
		} catch (error) {
			console.error('Failed to initialise map', error);
			mapError = 'Unable to render the interactive map.';
		}
	});

	$effect(() => {
		if (map && mapboxModule) {
			syncMarkers(locations);
		}
	});

	$effect(() => {
		if (!mapReady) return;
		if (!activeVideoId) {
			lastFocusedVideoId = null;
			return;
		}
		focusOnVideo(activeVideoId);
	});

	onDestroy(() => {
		clearMarkers();
		map?.remove();
		map = null;
		mapReady = false;
		lastFocusedVideoId = null;
	});
</script>

<div class="map-wrapper">
	<div bind:this={container} class="map-container" role="presentation"></div>
	{#if mapError}
		<div class="map-fallback">
			<p>{mapError}</p>
			{#if locations.length > 0}
				<ul>
					{#each locations as loc (loc.setting ?? loc.name ?? `${loc.latitude}-${loc.longitude}`)}
						<li>
							<span>{loc.setting ?? loc.name ?? 'Location'}</span>
							{#if (loc.latitude ?? loc.mapLat) != null && (loc.longitude ?? loc.mapLon) != null}
								<small>
									({loc.latitude ?? loc.mapLat}, {loc.longitude ?? loc.mapLon})
								</small>
							{/if}
						</li>
					{/each}
				</ul>
			{/if}
		</div>
	{/if}
</div>

<style>
	.map-wrapper {
		position: relative;
		width: 100%;
		height: 100%;
	}

	.map-container {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		overflow: hidden;
	}

	.map-fallback {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		padding: 1.5rem;
		text-align: center;
		background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9));
		color: rgba(248, 250, 252, 0.8);
	}

	.map-fallback ul {
		margin-top: 1rem;
		padding: 0;
		list-style: none;
		width: 100%;
		max-width: 320px;
		text-align: left;
	}

	.map-fallback li {
		display: flex;
		justify-content: space-between;
		padding: 0.25rem 0;
		border-bottom: 1px dashed rgba(148, 163, 184, 0.3);
		font-size: 0.8125rem;
	}

	.map-fallback small {
		opacity: 0.7;
	}
</style>
</file>

<file path="src/lib/components/MuxVideoPlayer.svelte">
<script lang="ts">
    import { onMount, onDestroy, tick } from "svelte";
    import "media-chrome";
    import "hls-video-element";
    import { uiState, actions } from "../stores/appStore";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { getPlayerState } from "$lib/stores/playerStore.svelte";
    import { videosStore } from "$lib/stores/library";

    const {
        src = "",
        autoplayUserPreference = true,
        startTime = 0,
        playerKey = "",
    } = $props();
    const playerState = getPlayerState();

    let player: (HTMLVideoElement & { load?: () => void }) | undefined;
    let isMuted = true;
    let isExpanded = $state(false);
    let isHovering = $state(false);
    let isPaused = $state(true);
    const playlist = $derived($videosStore);
    const currentVideoId = $derived($selectedVideo.id);
    const currentIndex = $derived(
        playlist.findIndex((video) => video.id === currentVideoId),
    );

    $effect(() => {
        const unsubscribe = uiState.subscribe((state) => {
            isExpanded = state.isExpanded;
        });
        return () => unsubscribe();
    });

    function handleVideoEnded() {
        // Advance to the next video in the queue
        selectedVideo.playNext();
    }

    function togglePlay(event: MouseEvent) {
        event.stopPropagation();
        if (!player) return;
        if (player.paused) {
            player.play().catch(() => {});
        } else {
            player.pause();
        }
    }

    function stepQueue(offset: number, event: MouseEvent) {
        event.stopPropagation();
        if (!playlist.length) return;
        const length = playlist.length;
        const base =
            currentIndex === -1 ? (offset > 0 ? 0 : length - 1) : currentIndex;
        const next = (base + offset + length) % length;
        const target = playlist[next];
        if (target) {
            selectedVideo.selectVideo(target.id);
            tick().then(() => {
                player?.play().catch((err) => {
                    console.warn("Autoplay was prevented.", err);
                });
            });
        }
    }

    function goPrevious(event: MouseEvent) {
        stepQueue(-1, event);
    }

    function goNext(event: MouseEvent) {
        stepQueue(1, event);
    }

    function toggleFullscreen(event: MouseEvent) {
        event.stopPropagation();
        const next = !isExpanded;
        actions.setExpanded(next);
        selectedVideo.setFullScreen(next);
    }

    async function attemptAutoplay() {
        if (!player || !autoplayUserPreference) return;
        try {
            await player.play();
        } catch {
            // Autoplay can be blocked silently; no-op fallback
        }
    }

    onMount(() => {
        if (player) {
            player.muted = isMuted;
            if (startTime > 0) {
                player.currentTime = startTime;
            }
            if (autoplayUserPreference) {
                attemptAutoplay();
            }

            // Listen for play/pause events to update state
            player.addEventListener("play", () => {
                isPaused = false;
            });
            player.addEventListener("pause", () => {
                isPaused = true;
            });
            player.addEventListener("ended", handleVideoEnded);
            player.addEventListener("canplay", attemptAutoplay);

            isPaused = player.paused;
        }
    });

    onDestroy(() => {
        if (player) {
            // Clean up event listener
            player.removeEventListener("ended", handleVideoEnded);
            player.removeEventListener("canplay", attemptAutoplay);
            player.pause();
            player.removeAttribute("src");
        }
    });

    function toggleMute() {
        if (!player) return;
        isMuted = !isMuted;
        player.muted = isMuted;
        if (!isMuted && player.paused) {
            player.play().catch(() => {
                // Play after unmute failed - browser restriction
            });
        }
    }

    $effect(() => {
        if (!player) return;

        if (!src) {
            player.removeAttribute("src");
            return;
        }

        const currentSrc = player.getAttribute("src");
        if (currentSrc !== src) {
            player.src = src;
            player.load?.();
            attemptAutoplay();
        }
    });

    // Listen for seek requests from the player store
    $effect(() => {
        if (!player) return;

        const seekTime = playerState.seekRequested;
        if (seekTime !== null && isFinite(seekTime)) {
            // Only seek if the difference is significant (more than 0.5 seconds)
            if (Math.abs(player.currentTime - seekTime) > 0.5) {
                player.currentTime = seekTime;
            }
        }
    });

    $effect(() => {
        if (!player) return;
        if (!Number.isFinite(startTime)) return;
        const difference = Math.abs(player.currentTime - startTime);
        if (difference > 0.75) {
            player.currentTime = startTime;
        }
    });
</script>

<div
    class="video relative block"
    id="player-container"
    on:mouseenter={() => (isHovering = true)}
    on:mouseleave={() => (isHovering = false)}
>
    <div class="video-container absolute inset-0 bg-black overflow-hidden">
        <media-controller class="absolute inset-0">
            <hls-video
                slot="media"
                crossorigin="anonymous"
                playsinline
                autoplay
                muted
                bind:this={player}
            ></hls-video>
            <media-loading-indicator slot="centered-chrome" noautohide
            ></media-loading-indicator>
        </media-controller>
    </div>

    <!-- Hover controls overlay -->
    <div
        class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 transition-opacity duration-200 pointer-events-none {isHovering
            ? 'opacity-100'
            : ''}"
    >
        <div
            class="absolute bottom-4 left-0 right-0 flex items-center justify-center gap-3 pointer-events-auto"
        >
            <!-- Previous button -->
            <button
                on:click={goPrevious}
                aria-label="Previous video"
                class="control-button"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                >
                    <path d="M15 18 9 12l6-6v12zm-6 0H7V6h2v12z" />
                </svg>
            </button>

            <!-- Play/Pause button -->
            <button
                on:click={togglePlay}
                aria-label={isPaused ? "Play" : "Pause"}
                class="control-button-large"
            >
                {#if isPaused}
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="32"
                        height="32"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                    >
                        <path d="M8 5v14l11-7z" />
                    </svg>
                {:else}
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="32"
                        height="32"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                    >
                        <path d="M6 4h4v16H6zm8 0h4v16h-4z" />
                    </svg>
                {/if}
            </button>

            <!-- Next button -->
            <button
                on:click={goNext}
                aria-label="Next video"
                class="control-button"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="20"
                    height="20"
                    viewBox="0 0 24 24"
                    fill="currentColor"
                >
                    <path d="m9 18 6-6-6-6v12zm6 0h2V6h-2v12z" />
                </svg>
            </button>
        </div>

        <!-- Fullscreen button in top-right corner -->
        <div class="absolute top-4 right-4 pointer-events-auto">
            <button
                on:click={toggleFullscreen}
                aria-label={isExpanded ? "Shrink player" : "Expand player"}
                class="control-button"
                title={isExpanded ? "Shrink player" : "Expand player"}
            >
                {#if !isExpanded}
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="20"
                        height="20"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M1 1h5v1H2v4H1V1zm9 0h5v5h-1V2h-4V1zm5 9v5h-5v-1h4v-4h1zM6 14v1H1v-5h1v4h4z"
                        />
                    </svg>
                {:else}
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="20"
                        height="20"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M5.828 10.172a.5.5 0 0 0-.707 0l-4.096 4.096V11.5a.5.5 0 0 0-1 0v3.975a.5.5 0 0 0 .5.5H4.5a.5.5 0 0 0 0-1H1.732l4.096-4.096a.5.5 0 0 0 0-.707zm4.344 0a.5.5 0 0 1 .707 0l4.096 4.096V11.5a.5.5 0 1 1 1 0v3.975a.5.5 0 0 1-.5.5H11.5a.5.5 0 0 1 0-1h2.768l-4.096-4.096a.5.5 0 0 1 0-.707zm0-4.344a.5.5 0 0 0 .707 0l4.096-4.096V4.5a.5.5 0 1 0 1 0V.525a.5.5 0 0 0-.5-.5H11.5a.5.5 0 0 0 0 1h2.768l-4.096 4.096a.5.5 0 0 0 0 .707zm-4.344 0a.5.5 0 0 1-.707 0L1.025 1.732V4.5a.5.5 0 0 1-1 0V.525a.5.5 0 0 1 .5-.5H4.5a.5.5 0 0 1 0 1H1.732l4.096 4.096a.5.5 0 0 1 0 .707z"
                        />
                    </svg>
                {/if}
            </button>
        </div>
    </div>
</div>

<style>
    .video {
        display: block;
        width: 100%;
        height: 100%;
    }
    .video-container {
        cursor: default;
        object-fit: cover;
        width: 100%;
        height: 100%;
        position: absolute;
        inset: 0;
    }

    .control-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: none;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        color: white;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .control-button:hover {
        background: rgba(0, 0, 0, 0.8);
        transform: scale(1.1);
    }

    .control-button-large {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 64px;
        height: 64px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px);
        color: white;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .control-button-large:hover {
        background: rgba(233, 149, 12, 0.9);
        border-color: rgba(233, 149, 12, 1);
        transform: scale(1.1);
    }
    :global(media-controller) {
        --media-primary-color: lightpink;
        --media-secondary-color: rgb(27 54 93 / 0.85);
        --media-control-hover-background: rgb(128 0 0 / 0.85);
        --media-object-fit: cover;
        --media-object-position: center;
        object-fit: cover;
        width: 100%;
        height: 100%;
    }
    :global(media-controller) {
        position: absolute;
        inset: 0;
    }
    :global(media-controller [slot="media"]),
    :global(hls-video) {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
    }
    .mute-toggle-button:hover {
        transform: scale(1.05);
    }
    :global(media-controller) {
        --media-control-background: transparent;
        --media-control-hover-background: rgba(0, 0, 0, 0.5);
        --media-control-active-background: rgba(0, 0, 0, 0.7);
        --media-control-color: white;
        --media-control-hover-color: white;
        --media-control-active-color: white;
        --media-control-border-radius: 4px;
        --media-control-padding: 8px;
        --media-control-margin: 4px;
        --media-control-font-size: 14px;
        --media-control-font-weight: 500;
        --media-control-letter-spacing: 0.5px;
        --media-control-text-transform: none;
        --media-control-text-decoration: none;
        --media-control-text-shadow: none;
        --media-control-box-shadow: none;
        --media-control-transition: all 0.2s ease;
    }
    :global(media-control-bar) {
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
        padding: 8px;
    }
    :global(media-progress-bar) {
        --media-progress-bar-height: 4px;
        --media-progress-bar-background: rgba(255, 255, 255, 0.3);
        --media-progress-bar-fill-background: white;
    }
    :global(media-volume-range) {
        --media-range-track-height: 4px;
        --media-range-track-background: rgba(255, 255, 255, 0.3);
        --media-range-track-fill-background: white;
    }
</style>
</file>

<file path="src/lib/components/PersistentVideoPlayer.svelte">
<script lang="ts">
  import { activeVideo } from '$lib/stores/video';
  import { onMount } from 'svelte';
  import { gsap } from 'gsap';
  import VideoInfo from './VideoInfo.svelte';
  import VideoPlayer from './VideoPlayer.svelte';

  interface VideoData {
    video: {
      id: string;
      url: string;
      title: string;
      description: string;
      author: string;
      authorId: string;
      transcript: string;
      keywords: string[];
      locations: any[];
    }
  }

  let videoContainer: HTMLDivElement;
  let isPip = $state(false);
  let { data } = $props<{ data?: VideoData }>();

  function togglePip() {
    isPip = !isPip;
    
    // Animate to PiP mode
    if (isPip) {
      gsap.to(videoContainer, {
        y: window.innerHeight - 180, // offset to bottom
        x: -20,
        width: '280px',
        borderRadius: '8px',
        boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
        duration: 0.5,
        ease: 'power2.out'
      });
    } 
    // Animate to full screen
    else {
      gsap.to(videoContainer, {
        y: 0,
        x: 0,
        width: '100%',
        borderRadius: 0,
        boxShadow: 'none',
        duration: 0.5,
        ease: 'power2.inOut'
      });
    }
  }

  onMount(() => {
    // Set initial position based on isPip state
    if (isPip) {
      gsap.set(videoContainer, {
        y: window.innerHeight - 180, // offset to bottom
        x: window.innerWidth - 400,
        width: '280px',
        borderRadius: '8px',
        boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
      });
    } else {
      gsap.set(videoContainer, {
        y: 0,
        x: 0,
        width: '100%',
        borderRadius: 0,
        boxShadow: 'none'
      });
    }
  });
</script>

<div 
  bind:this={videoContainer}
  class="video-container"
>
  <div class:dashboard-panel={!isPip}>
    <div class="relative aspect-video bg-black">
      {#if $activeVideo?.url}
        <VideoPlayer videoUrl={$activeVideo.url} />
      {/if}
          
      <!-- Video Info -->
      <div class="absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/80 to-transparent text-white">
        <div class="flex items-center justify-between">
          <div class="display-none">
            <h3 class="text-sm font-medium truncate">{$activeVideo?.title}</h3>
            <p class="text-xs text-neutral-300">{$activeVideo?.author}</p>
          </div>
            <!-- PiP Toggle Button -->
      <button
        on:click={togglePip}
        class="absolute top-4 right-4 p-2 bg-black/50 hover:bg-black/70 rounded-full text-white transition-colors"
      >
        {#if isPip}
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"/>
          </svg>
        {:else}
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"/>
          </svg>
        {/if}
      </button>
        </div>
      </div>

    
    </div>

    {#if !isPip && data}
      <VideoInfo {data} />
    {/if}
  </div>
</div>

<style>
  .video-container {
    transform-origin: bottom right;
    position: fixed;
    top: 0;
    right: 0;
  }

  .dashboard-panel {
    border: 1px solid rgba(255, 255, 255, 0.1);
    background-color: rgba(255, 255, 255, 0.04);
    padding: 1.5rem;
  }
</style>
</file>

<file path="src/lib/components/Playing.svelte">
<script lang="ts">
    import { activeVideo } from '$lib/stores/video';
    import { selectedVideo } from '$lib/stores/selectedVideo';
  import { page } from '$app/stores';
  import { onMount } from 'svelte';
  import {gsap}  from "gsap/dist/gsap";
  import {ScrollTrigger} from "gsap/dist/ScrollTrigger";
  import VideoInfo from './VideoInfo.svelte';
  import VideoPlayer from './VideoPlayer.svelte';
  import { afterNavigate, goto } from '$app/navigation';

  
  import type { Video } from '$lib/types/content';
  import { getVideoById as lookupVideo, videosStore } from '$lib/stores/library';

  interface VideoData {
    video: Video;
  }

  let videoContainer = $state<HTMLDivElement>();
  let vidPlayer = $state<HTMLDivElement>();
  let isPip = $state(false);
  let videoData = $state<VideoData | null>(null);

  async function fetchVideoData(id: string) {
    try {
      let video = lookupVideo(id);
      if (!video && id === 'home') {
        video = $videosStore[0];
      }
      if (!video) throw new Error('Video not found');

      videoData = { video };

      // Update active video
      activeVideo.setActive({
        id: video.id,
        url: video.videoUrl ?? video.url ?? '',
        title: video.title,
        author: video.author,
        authorId: video.authorId,
        durationSeconds: video.durationSeconds ?? 0,
        thumbnailUrl: video.thumbnailUrl ?? undefined
      });
    } catch (error) {
      console.error('Error fetching video data:', error);
    }
  }

let manualOverride = false;

function togglePip() {
  const currentPath = $page.url.pathname;
  const isVideoDetailPage = currentPath.startsWith('/videos/') && currentPath !== '/videos';

  // If we're on a video detail page and minimizing (going to PiP), navigate back
  if (isVideoDetailPage && !isPip) {
    // Navigate to previous page or videos list
    goto('/videos');
    return;
  }

  isPip = !isPip;
  manualOverride = true;
  selectedVideo.toggleFullScreen();

  if (isPip && videoContainer) {
    gsap.to(videoContainer, {
      y: window.innerHeight - 180,
      x: -20,
      width: '280px',
      borderRadius: '8px',
      boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
      duration: 0.5,
      ease: 'power2.out'
    });
  } else if (videoContainer) {
    gsap.to(videoContainer, {
      y: 0,
      x: 0,
      width: '100%',
      borderRadius: 0,
      boxShadow: 'none',
      duration: 0.5,
      ease: 'power2.inOut'
    });
  }

  // Clear manual override after a short delay
  setTimeout(() => {
    manualOverride = false;
  }, 1000);
}

  onMount(async () => {
    try {
      if ($selectedVideo.id) {
        let video = lookupVideo($selectedVideo.id);
        if (!video && $selectedVideo.id === 'home') {
          video = $videosStore[0];
        }
        if (video) {
          videoData = { video };
        }
      }
    } catch (e) {
      console.error('Error loading video:', e);
    }
  });

// onMount(async () => {
//    gsap.registerPlugin(ScrollTrigger);
//    const scroller = document.querySelector('.scroll-container');

//   ScrollTrigger.create({
//     trigger: videoContainer,
//     start: "top top",
//     end: "+=250",
//     scrub: true,
//     scroller,
//     onUpdate: (self) => {
//       if (manualOverride) return;

//       const progress = self.progress;

//       const pipScale = gsap.utils.interpolate(1, 0.28, progress); // shrink to ~28%
//       const pipX = gsap.utils.interpolate(0, -20, progress);
//       const pipY = gsap.utils.interpolate(0, window.innerHeight - 180, progress);
//       const borderRadius = gsap.utils.interpolate(0, 8, progress);
//       const boxShadow = progress > 0.9
//         ? '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)'
//         : 'none';

//       gsap.to(vidPlayer, {
//         scale: pipScale,
//         x: pipX,
//         y: pipY,
//         zIndex: 999999,
//         borderRadius,
//         boxShadow,
//         transformOrigin: 'bottom right',
//         duration: 0.2,
//         overwrite: 'auto'
//       });

//     },
//     invalidateOnRefresh: true
//   });
// });

  onMount(() => {
  const handleRouteChange = () => {
    const currentPath = $page.url.pathname;

    const isFullscreenRoute =
      (currentPath.startsWith('/videos/') && currentPath !== '/videos') ||
      currentPath === '/live';

    if ($selectedVideo.id) {
      if (isFullscreenRoute && isPip) {
        togglePip(); 
        isPip = false;
      } else if (!isFullscreenRoute && !isPip) {
        togglePip();
        isPip = true;
      }
    }

  };

  afterNavigate(handleRouteChange);

  // Run it once immediately
  handleRouteChange();
});


  // Watch for selected video changes
  $effect(() => {
    if ($selectedVideo.id) {
      fetchVideoData($selectedVideo.id);
      isPip = !$selectedVideo.isFullScreen;
      
      // Animate based on isFullScreen state
      if (!$selectedVideo.isFullScreen && videoContainer) {
        gsap.to(videoContainer, {
          y: window.innerHeight - 180,
          x: -20,
          width: '280px',
          borderRadius: '8px',
          boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
          duration: 0.5,
          ease: 'power2.out'
        });
      } else if (videoContainer) {
        gsap.to(videoContainer, {
          y: 0,
          x: 0,
          width: '100%',
          borderRadius: 0,
          boxShadow: 'none',
          duration: 0.5,
          ease: 'power2.inOut'
        });
      }
    }
  });

  // Watch for page changes
  
</script>

{#if $selectedVideo.id}
  <div 
    bind:this={videoContainer}
    class="video-container scroll-container h-full overflow-y-auto"
    
  >
    <button
      class="relative aspect-video bg-black cursor-pointer w-full text-left"
      onclick={togglePip}
      aria-label="Toggle picture-in-picture mode"
    >
      {#if $activeVideo?.url}
        <div class="vidplayer"  bind:this={vidPlayer}>
            <VideoPlayer videoUrl={$activeVideo.url} />
        </div>
      {/if}
      
      <!-- Video Info -->
      <div class="absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/80 to-transparent text-white pointer-events-none">
        <div class="flex items-center justify-between">
          <div class="p-4 flex items-center gap-4">
            <h3 class="text-sm font-medium truncate">{$activeVideo?.title}</h3>
            <p class="text-xs text-neutral-300">{$activeVideo?.author}</p>
          </div>
          <!-- PiP Toggle Button -->
         
        </div>
      </div>
    </button>

    {#if !isPip && videoData}
        <VideoInfo data={videoData} />
   
    {/if}
  </div>
{/if}

<style>
  .video-container {
    transform-origin: bottom right;
    position: fixed;
    top: 0;
    right: 0;
    background: black;
  }

</style>
</file>

<file path="src/lib/components/PlayingDesktopColumn.svelte">
<script lang="ts">
    import { activeVideo } from "$lib/stores/video";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { page } from "$app/stores";
    import { onMount } from "svelte";
    import VideoInfo from "./VideoInfo.svelte";
    import VideoPlayer from "./VideoPlayer.svelte";
    import { afterNavigate, goto } from "$app/navigation";
    import {
        getVideoById as lookupVideo,
        videosStore,
    } from "$lib/stores/library";

    import type { Video } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let videoData = $state<VideoData | null>(null);
    let isFullscreenRoute = $derived(
        $page.url.pathname.startsWith("/videos/") &&
            $page.url.pathname !== "/videos",
    );

    async function fetchVideoData(id: string) {
        try {
            let video = lookupVideo(id);
            if (!video && id === "home") {
                video = $videosStore[0];
            }
            if (!video) throw new Error("Video not found");

            videoData = { video };

            activeVideo.setActive({
                id: video.id,
                url: video.videoUrl ?? video.url ?? "",
                title: video.title,
                author: video.author,
                authorId: video.authorId,
            });
        } catch (error) {
            console.error("Error fetching video data:", error);
        }
    }

    function expandToFullscreen() {
        if ($selectedVideo.id) {
            selectedVideo.toggleFullScreen();
            goto(`/videos/${$selectedVideo.id}`);
        }
    }

    onMount(() => {
        if ($selectedVideo.id) {
            let video = lookupVideo($selectedVideo.id);
            if (!video && $selectedVideo.id === "home") {
                video = $videosStore[0];
            }
            if (video) {
                videoData = { video };
            }
        }

        afterNavigate(() => {
            // no-op, reactive $derived handles isFullscreenRoute
        });
    });

    $effect(() => {
        if ($selectedVideo.id) {
            fetchVideoData($selectedVideo.id);
        }
    });
</script>

// place files you want to import through the `$lib` alias in this folder.
{#if $selectedVideo.id && !isFullscreenRoute}
    <!-- Desktop-only column next to Sidebar -->
    <div
        class="hidden lg:flex flex-col w-[500px] shrink-0 border-l border-neutral-200 dark:border-neutral-800 bg-white dark:bg-black h-full overflow-scroll top-0"
    >
        <!-- Video at top -->
        <button
            class="relative aspect-video bg-black w-full"
            onclick={expandToFullscreen}
            aria-label="Expand video to fullscreen"
        >
            {#if $activeVideo?.url}
                <div>
                    <VideoPlayer videoUrl={$activeVideo.url} />
                </div>
            {/if}
        </button>

        <!-- Video information underneath -->
        {#if videoData}
            <div class="flex-1 overflow-y-auto">
                <VideoInfo data={videoData} />
            </div>
        {/if}
    </div>
{/if}
</file>

<file path="src/lib/components/Sidebar.svelte">
<script lang="ts">
    import { slide } from "svelte/transition";
    import { onMount, tick } from "svelte";
    import { page } from "$app/stores";
    // FIXED: This is the correct import for the component API you are using
    import { Tooltip } from "bits-ui";

    interface Props {
        isOpen?: boolean;
        onclose?: () => void;
    }

    let { isOpen = false, onclose }: Props = $props();

    function closeMobileSidebar() {
        onclose?.();
    }

    // REFACTORED: Added "Live" link to the navLinks array
    const navLinks = [
        { href: "/", label: "Home", icon: "live" },
        { href: "/live", label: "Live", icon: "play" },
        { href: "/map", label: "Map", icon: "map" },
        { href: "/users", label: "Users", icon: "users" },
        { href: "/upload", label: "Upload", icon: "upload" },
    ] as const;

    // --- State for Highlight Logic ---
    let navContainer = $state<HTMLDivElement | null>(null);
    let highlightContainer = $state<HTMLDivElement | null>(null);
    // REMOVED: liveLinkRef is no longer needed
    // let liveLinkRef = $state<HTMLAnchorElement | null>(null);

    // This array will now be 5 elements long, and navRefs[0] will be the "Live" link
    let navRefs: Array<HTMLAnchorElement | null> = $state(
        new Array(navLinks.length).fill(null),
    );
    let highlightY = $state(0);
    let highlightX = $state(0);
    let highlightWidth = $state(0);
    let highlightHeight = $state(0);
    let highlightVisible = $state(false);
    let highlightPulse = $state(false);
    let highlightElement: HTMLDivElement | null = null;
    let resizeHandler: (() => void) | null = null;

    function routeMatches(href: string | null, currentPath: string): boolean {
        if (!href) return false;
        return currentPath === href || currentPath.startsWith(`${href}/`);
    }

    async function refreshHighlight(currentPath: string) {
        await tick();
        if (!highlightContainer) {
            highlightVisible = false;
            return;
        }

        let target: HTMLElement | null = null;

        const activeIndex = navLinks.findIndex((link) =>
            routeMatches(link.href, currentPath),
        );
        if (activeIndex !== -1) {
            const candidate = navRefs[activeIndex];
            if (candidate instanceof HTMLElement) {
                target = candidate;
            }
        }

        if (!target) {
            highlightVisible = false;
            return;
        }

        const containerRect = highlightContainer.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // UPDATED: Use the target's width and left directly.
        // Since the target <a> is h-12 w-12, this will result in a square.
        let width = targetRect.width;
        let left = targetRect.left - containerRect.left;

        // REMOVED: The block that calculated width based on the inner icon is gone.

        highlightY = targetRect.top - containerRect.top;
        highlightX = left;
        highlightWidth = width;
        highlightHeight = targetRect.height; // height will equal width (h-12)
        const isVisible = highlightHeight > 0 && highlightWidth > 0;

        if (!isVisible) {
            highlightVisible = false;
            highlightPulse = false;
            return;
        }

        highlightVisible = true;
        highlightPulse = false;
        await tick();
        highlightPulse = true;
    }

    onMount(() => {
        const handleResize = () => {
            refreshHighlight($page.url.pathname);
        };
        window.addEventListener("resize", handleResize);
        resizeHandler = handleResize;

        return () => {
            if (resizeHandler) {
                window.removeEventListener("resize", resizeHandler);
                resizeHandler = null;
            }
        };
    });

    // REFACTORED: Removed dependency on liveLinkRef
    $effect(() => {
        const path = $page.url.pathname;
        highlightContainer;
        navRefs.forEach((ref) => ref);
        refreshHighlight(path);
    });

    const icons = {
        home: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9.75L12 3l9 6.75V21a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-4.5a.75.75 0 00-.75-.75h-3a.75.75 0 00-.75.75V21a.75.75 0 01-.75.75H3.75A.75.75 0 013 21V9.75z"/></svg>`,
        map: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 3.75l6 2.5 6-2.5v14.5l-6 2.5-6-2.5-6 2.5V6.25l6-2.5zM9 3.75v14.5m6-12v14.5"/></svg>`,
        play: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347c-.75.412-1.667-.13-1.667-.986V5.653z" /></svg>`,
        users: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M6.5 21a5.5 5.5 0 0111 0M19.5 8.25a2.25 2.25 0 110 4.5M21 21a3 3 0 00-4-2.82"/></svg>`,
        upload: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16.5v1.25A2.25 2.25 0 006.25 20h11.5A2.25 2.25 0 0020 17.75V16.5M8.75 9.75L12 6.5l3.25 3.25M12 6.5v9.75"/></svg>`,
    } satisfies Record<string, string>;
</script>

<Tooltip.Provider delayDuration={100}>
    <aside
        class="hidden z-100 lg:flex lg:w-20 lg:flex-col transition-all duration-300 ease-in-out overflow-visible"
    >
        <div
            class="sidebar-shell relative flex flex-1 flex-col overflow-y-auto overflow-x-visible border-r border-white/10 bg-white/[0.02] backdrop-blur-md shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)]"
            bind:this={highlightContainer}
        >
            <div
                bind:this={highlightElement}
                class="nav-highlight"
                class:visible={highlightVisible}
                style={`--highlight-x: ${highlightX}px; --highlight-y: ${highlightY}px; height: ${highlightHeight}px; width: ${highlightWidth}px;`}
            >
                <div
                    class="nav-highlight-inner"
                    class:animate={highlightPulse}
                    on:animationend={() => {
                        highlightPulse = false;
                    }}
                ></div>
            </div>

            <nav class="mt-6 flex-1 flex justify-center px-4">
                <div class="space-y-1 nav-list" bind:this={navContainer}>
                    {#each navLinks as link, index}
                        <Tooltip.Root>
                            <Tooltip.Trigger asChild>
                                <a
                                    href={link.href}
                                    bind:this={navRefs[index]}
                                    class="nav-item flex h-10 w-10 items-center justify-center rounded-xl transition {link.icon ===
                                    'live'
                                        ? 'logo-link mb-10 '
                                        : 'text-white/70 hover:bg-white/10 hover:text-white'}"
                                    class:active={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )}
                                    aria-label={link.label}
                                    aria-current={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )
                                        ? "page"
                                        : undefined}
                                >
                                    {#if link.icon === "live"}
                                        <span
                                            class="logo-mark"
                                            aria-hidden="true"
                                        >
                                            <span
                                                class="logo-bar logo-bar--long"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--medium"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--short"
                                            ></span>
                                        </span>
                                    {:else}
                                        <span
                                            class="nav-icon text-white/80"
                                            aria-hidden="true"
                                            >{@html icons[link.icon]}</span
                                        >
                                    {/if}
                                </a>
                            </Tooltip.Trigger>

                            <Tooltip.Portal>
                                <Tooltip.Content
                                    side="right"
                                    align="center"
                                    sideOffset={3}
                                    class="tooltip-content"
                                >
                                    {link.label}
                                </Tooltip.Content>
                            </Tooltip.Portal>
                        </Tooltip.Root>
                    {/each}
                </div>
            </nav>
        </div>
    </aside>
</Tooltip.Provider>

<div class="lg:hidden">
    {#if isOpen}
        <aside
            class="fixed top-0 left-0 h-full w-64 bg-white dark:bg-black border-r border-gray-300 z-50"
            transition:slide={{ duration: 200, axis: "x" }}
        >
            <div class="flex flex-col flex-grow pt-5 pb-4 overflow-y-auto">
                <div
                    class="flex items-center justify-between flex-shrink-0 px-4"
                >
                    <h1
                        class="text-xl font-bold tracking-wider text-gray-900 dark:text-white"
                    >
                        RUSHES
                    </h1>
                    <button
                        on:click={closeMobileSidebar}
                        class="p-2 hover:bg-gray-100 dark:hover:bg-gray-900 rounded transition-colors"
                        aria-label="Close menu"
                    >
                        <svg
                            class="h-5 w-5 text-gray-900 dark:text-white"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <nav class="mt-8 flex-1 px-4 space-y-1">
                    {#each navLinks as link}
                        <a
                            href={link.href}
                            class="group flex items-center px-2 py-2 text-sm font-medium rounded-md text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
                            on:click={closeMobileSidebar}
                        >
                            {#if link.icon === "live"}
                                <span class="mr-3 h-5 w-5" aria-hidden="true">
                                    <span class="logo-mark !h-5 !w-5">
                                        <span
                                            class="logo-bar logo-bar--long bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--medium bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--short bg-gray-900 dark:bg-white"
                                        ></span>
                                    </span>
                                </span>
                            {:else}
                                <span
                                    class="mr-3 h-5 w-5 text-gray-900 dark:text-white"
                                    aria-hidden="true"
                                    >{@html icons[link.icon]}</span
                                >
                            {/if}
                            {link.label}
                        </a>
                    {/each}
                </nav>
            </div>
        </aside>
    {/if}
</div>

<style>
    .logo-mark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.2rem;
        width: 1.5rem;
        height: 1.5rem;
    }

    .logo-bar {
        width: 0.2rem;
        border-radius: 9999px;
        background: white;
    }

    .logo-bar--long {
        height: 1.15rem;
    }

    .logo-bar--medium {
        height: 0.85rem;
    }

    .logo-bar--short {
        height: 0.65rem;
    }

    .sidebar-shell {
        overflow-x: visible;
        overflow-y: auto;
    }

    .nav-list {
        position: relative;
        overflow: visible;
    }

    .nav-item {
        position: relative;
    }

    .nav-item.active {
        color: #f8fafc;
    }

    .nav-icon :global(svg) {
        display: block;
        height: 1.25rem;
        width: 1.25rem;
    }

    /* FIXED: Removed :global() and set z-index properly */
    :global(.tooltip-content) {
        background: rgba(255, 255, 255, 0.2);
        font-family: sans-serif;
        color: #f8fafc;
        padding: 0.35rem 0.6rem;
        border-radius: 0.55rem;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        white-space: nowrap;
        box-shadow: 0 18px 35px -24px rgba(15, 23, 42, 0.88);
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        z-index: 9999999;
    }

    /* Added style for tooltip arrow */
    .tooltip-arrow {
        fill: rgba(15, 23, 42, 0.92);
    }

    .nav-highlight {
        position: absolute;
        left: 0;
        top: 0;

        border-radius: 10px;
        pointer-events: none;
        z-index: -1;
        transform: translate3d(var(--highlight-x, 0), var(--highlight-y, 0), 0);
        transition:
            transform 0.32s cubic-bezier(0.28, 0.94, 0.38, 1),
            height 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            width 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            opacity 0.16s ease;
        opacity: 0;
    }

    .nav-highlight.visible {
        opacity: 1;
    }

    .nav-highlight-inner {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.18);
        transition: opacity 0.16s ease;
        opacity: 0.9;

        transform-origin: center;
    }

    .nav-highlight-inner.animate {
        animation: highlight-bounce 0.5s cubic-bezier(0.24, 1.58, 0.36, 1)
            forwards;
    }

    @keyframes highlight-bounce {
        0% {
            transform: scale(0.88);
        }
        45% {
            transform: scale(1.08);
        }
        70% {
            transform: scale(0.97);
        }
        100% {
            transform: scale(1);
        }
    }

    .nav-list a.active {
        color: orange;
    }

    .nav-list a.active span:first-child {
        color: orange;
    }

    a.active .logo-bar {
        background: orange !important;
    }
</style>
</file>

<file path="src/lib/components/VideoCard.svelte">
<script lang="ts">
  import { selectedVideo } from '$lib/stores/selectedVideo';

  export let video: {
    id: string;
    title: string;
    author: string;
    thumbnailUrl: string;
  };

  function handleVideoClick() {
    // If we're already on this video, toggle PiP
    if ($selectedVideo.id === video.id) {
      selectedVideo.toggleFullScreen();
    } else {
      // Otherwise select the new video
      selectedVideo.selectVideo(video.id);
    }
  }
</script>

<div 
  class="group relative aspect-video overflow-hidden rounded-lg bg-neutral-900 cursor-pointer"
  on:click={handleVideoClick}
>
  <img 
    src={video.thumbnailUrl} 
    alt={video.title}
    class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
  />
  <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100">
    <div class="absolute bottom-0 left-0 right-0 p-4">
      <h3 class="text-sm font-medium text-white truncate">{video.title}</h3>
      <p class="text-xs text-neutral-300">{video.author}</p>
    </div>
  </div>
</div>
</file>

<file path="src/lib/components/VideoInfo.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description md:bg-slate-100/5 border border-white/5 md:rounded-lg md:p-6 mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location md:bg-slate-100/5 border border-white/5 md:rounded-lg md:p-6 mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path="src/lib/components/VideoInfoContainer.svelte">
<script lang="ts">
    import VideoInfo from "$lib/components/VideoInfo.svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import {
        getVideoById as lookupVideo,
        videosStore,
    } from "$lib/stores/library";
    import type { Video } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    const videosList = $derived($videosStore);

    function resolveVideo(id: string | null): VideoData | null {
        if (!id) return null;
        if (id === "home") {
            const fallback = videosList[0];
            return fallback ? { video: fallback } : null;
        }
        const video = lookupVideo(id);
        return video ? { video } : null;
    }

    let data = $state<VideoData | null>(null);
    let nextVideo = $state<Video | null>(null);

    $effect(() => {
        data = resolveVideo($selectedVideo.id);

        // Resolve next video data
        const nextId = selectedVideo.nextVideoId;
        nextVideo = nextId ? (lookupVideo(nextId) ?? null) : null;
    });

    function handlePlayNext() {
        selectedVideo.playNext();
    }
</script>

{#if data}
    <VideoInfo {data} />

    {#if nextVideo}
        <div
            class="up-next-container border-t border-white/10 bg-white/[0.02] p-6 mt-6"
        >
            <div class="flex items-center justify-between mb-4">
                <h3
                    class="text-sm font-semibold uppercase tracking-[0.3em] text-slate-400"
                >
                    Up Next
                </h3>
                <button
                    onclick={handlePlayNext}
                    class="text-xs uppercase tracking-[0.25em] text-sky-400 hover:text-sky-300 transition-colors"
                >
                    Play Now ‚Üí
                </button>
            </div>

            <button
                onclick={handlePlayNext}
                class="group flex gap-4 w-full text-left rounded-2xl border border-white/10 bg-white/[0.04] p-4 hover:bg-white/[0.08] hover:border-white/20 transition-all duration-200"
            >
                <div
                    class="relative aspect-video w-32 flex-shrink-0 overflow-hidden rounded-xl bg-black"
                >
                    <img
                        src={nextVideo.thumbnailUrl ??
                            "https://placehold.co/640x360?text=Video"}
                        alt={nextVideo.title}
                        class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                    />
                    <div
                        class="absolute inset-0 flex items-center justify-center bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                        <svg
                            class="h-8 w-8 text-white"
                            viewBox="0 0 24 24"
                            fill="currentColor"
                        >
                            <path d="M8 5v14l11-7z" />
                        </svg>
                    </div>
                </div>

                <div class="flex-1 min-w-0">
                    <h4
                        class="text-sm font-medium text-white mb-1 truncate group-hover:text-sky-400 transition-colors"
                    >
                        {nextVideo.title}
                    </h4>
                    <p class="text-xs text-slate-400 mb-2">
                        {nextVideo.author}
                    </p>
                    <div class="flex items-center gap-3 text-xs text-slate-500">
                        {#if nextVideo.duration}
                            <span class="flex items-center gap-1">
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="12"
                                    height="12"
                                    fill="currentColor"
                                    viewBox="0 0 16 16"
                                >
                                    <path
                                        d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                                    />
                                    <path
                                        d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                                    />
                                </svg>
                                {Math.floor(nextVideo.duration / 60)}:{String(
                                    nextVideo.duration % 60,
                                ).padStart(2, "0")}
                            </span>
                        {/if}
                        {#if nextVideo.views}
                            <span>{nextVideo.views} views</span>
                        {/if}
                    </div>
                </div>
            </button>

            <p class="mt-3 text-xs text-slate-500 text-center">
                Auto-play will begin when the current video ends
            </p>
        </div>
    {/if}
{:else}{/if}

<style>
    .placeholder {
        border: 1px dashed rgba(148, 163, 184, 0.3);
        border-radius: 0.75rem;
        padding: 2rem;
        text-align: center;
        color: rgba(71, 85, 105, 0.8);
        background: rgba(15, 23, 42, 0.05);
    }

    .placeholder h2 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: inherit;
    }

    .placeholder p {
        font-size: 0.875rem;
        line-height: 1.4;
        margin: 0;
    }
</style>
</file>

<file path="src/lib/components/VideoPlayer.svelte">
<script lang="ts">
  import { onMount } from 'svelte';
  import 'hls-video-element';

  const props = $props<{
    videoUrl?: string;
    autoplay?: boolean;
    controls?: boolean;
    muted?: boolean;
    loop?: boolean;
    poster?: string;
  }>();

  let videoUrl = $state(props.videoUrl ?? '');
  let autoplay = $state(props.autoplay ?? false);
  let controls = $state(props.controls ?? true);
  let muted = $state(props.muted ?? false);
  let loop = $state(props.loop ?? false);
  let poster = $state<string | undefined>(props.poster);

  $effect(() => {
    videoUrl = props.videoUrl ?? '';
    autoplay = props.autoplay ?? false;
    controls = props.controls ?? true;
    muted = props.muted ?? false;
    loop = props.loop ?? false;
    poster = props.poster;
  });

const isHls = $derived(videoUrl?.toLowerCase().includes('.m3u8') ?? false);
let videoElement = $state<any>(null);

	onMount(() => {
		if (!videoElement) return;
		if (autoplay) {
			videoElement
				.play()
				.catch(() => {
					// Autoplay may be blocked; leave the video paused.
				});
		}
	});

	$effect(() => {
		if (!videoElement) return;
		if (!videoUrl) {
			videoElement.src = '';
			videoElement.removeAttribute('src');
			videoElement.pause();
			return;
		}

		const targetSrc = videoUrl ?? '';
		const currentSrc = videoElement.getAttribute('src') ?? '';
		if (currentSrc !== targetSrc) {
			if (isHls) {
				(videoElement as unknown as HTMLMediaElement).src = targetSrc;
				videoElement.setAttribute('src', targetSrc);
			} else {
				videoElement.src = targetSrc;
			}

			if (autoplay) {
				videoElement
					.play()
					.catch(() => {});
			} else {
				videoElement.pause();
			}
		}
	});
</script>

{#if videoUrl}
  {#if isHls}
    <hls-video
      bind:this={videoElement}
      class="video-player"
      crossorigin="anonymous"
      {controls}
      {loop}
      {muted}
      playsinline
      poster={poster}
    ></hls-video>
  {:else}
    <video
      bind:this={videoElement}
      class="video-player"
      {controls}
      {loop}
      {muted}
      playsinline
      poster={poster}
    >
      <source src={videoUrl} type="video/mp4" />
      Your browser does not support the video tag.
    </video>
  {/if}
{:else}
  <div class="video-player video-player--empty">
    <p>No video selected</p>
  </div>
{/if}

<style>
	.video-player {
		width: 100%;
		height: 100%;
		display: block;
		object-fit: cover;
		background: black;
	}

	.video-player--empty {
		display: flex;
		align-items: center;
		justify-content: center;
		color: rgba(255, 255, 255, 0.7);
		font-size: 0.875rem;
		background: rgba(17, 24, 39, 0.8);
		padding: 1.5rem;
	}
</style>
</file>

<file path="src/lib/components/VideoTimeline.svelte">
<script lang="ts">
    import { onMount, onDestroy, tick } from "svelte";
    import { browser } from "$app/environment";
    import { activeVideo } from "$lib/stores/video";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { videosStore } from "$lib/stores/library";
    import {
        seekTo,
        updateCurrentTime,
        updateDuration,
        updatePlayingState,
        getPlayerState,
    } from "$lib/stores/playerStore.svelte";
    import {
        generateMockWaveform,
        type WaveformData,
    } from "$lib/utils/waveform";

    let videoEl: HTMLVideoElement | null = null;
    let duration = $state(0);
    let currentTime = $state(0);
    let playing = $state(false);
    let rafId: number | null = null;
    let trackEl: HTMLDivElement | null = null;
    let isDragging = $state(false);
    let isScrubbing = $state(false);
    let isHovering = $state(false);
    let hoverTime = $state(0);
    let hoverX = $state(0);
    let waveformData = $state<WaveformData | null>(null);

    // Store event listeners in component scope to avoid memory leaks
    let currentListeners: {
        onTime: () => void;
        onPlay: () => void;
        onPause: () => void;
        onLoaded: () => void;
    } | null = null;

    const playlist = $derived($videosStore);
    const currentVideoId = $derived($selectedVideo.id);
    const currentIndex = $derived(
        playlist.findIndex((video) => video.id === currentVideoId),
    );
    const currentVideo = $derived(playlist[currentIndex]);

    // Use actual video element duration when available, fall back to database duration
    const effectiveDuration = $derived(
        videoEl && videoEl.duration > 0
            ? Math.floor(videoEl.duration)
            : (currentVideo?.duration ?? 0),
    );

    $effect(() => {
        if (currentVideo) {
            duration = currentVideo.duration ?? 0;
            // Generate waveform when video changes (fewer bars for simpler look)
            waveformData = generateMockWaveform(60, duration);
        } else if (duration > 0) {
            // Fallback: generate waveform even if currentVideo is not available
            waveformData = generateMockWaveform(60, duration);
        }
    });

    function stepQueue(offset: number) {
        if (!playlist.length) return;
        const length = playlist.length;
        const base =
            currentIndex === -1 ? (offset > 0 ? 0 : length - 1) : currentIndex;
        const next = (base + offset + length) % length;
        const target = playlist[next];
        if (target) {
            selectedVideo.selectVideo(target.id);
            activeVideo.setActive({
                id: target.id,
                url: target.videoUrl ?? target.url ?? "",
                title: target.title,
                author: target.author,
                authorId: target.authorId,
                duration: target.duration,
            });
            tick().then(() => {
                videoEl?.play().catch((err) => {
                    console.warn("Autoplay was prevented.", err);
                });
            });
        }
    }

    function goPrevious(event: MouseEvent) {
        event.stopPropagation();
        stepQueue(-1);
    }

    function goNext(event: MouseEvent) {
        event.stopPropagation();
        stepQueue(1);
    }

    // Type definition for HLS video element
    interface HLSVideoElement extends HTMLElement {
        video?: HTMLVideoElement;
        shadowRoot?: ShadowRoot;
    }

    // helper to find the underlying video element in the sidebar player
    function findVideo(): HTMLVideoElement | null {
        // looks for #player-container inside desktop sidebar (it exists in +layout.svelte)
        const container = document.querySelector("#player-container");
        if (!container) return null;

        // 1) direct query for video in light DOM (works if video is not in shadow DOM)
        const directVideo = container.querySelector("video");
        if (directVideo instanceof HTMLVideoElement) return directVideo;

        // 2) try to find a nested hls-video or hls-video-element and read its internal video (best effort)
        const hls =
            container.querySelector("hls-video") ||
            container.querySelector("hls-video-element");
        if (hls) {
            const hlsElement = hls as HLSVideoElement;

            // Try to access the video property if it exists
            if (hlsElement.video instanceof HTMLVideoElement) {
                return hlsElement.video;
            }

            // Attempt to access shadow root
            if (hlsElement.shadowRoot) {
                const shadowVideo =
                    hlsElement.shadowRoot.querySelector("video");
                if (shadowVideo instanceof HTMLVideoElement) {
                    return shadowVideo;
                }
            }
        }

        return null;
    }

    function attachVideo(v: HTMLVideoElement | null) {
        detachVideo();
        if (!v) return;
        videoEl = v;

        // Create listener functions
        const onTime = () => {
            // when not dragging or scrubbing, update currentTime so UI reflects playback
            if (!isDragging && !isScrubbing) {
                const time = videoEl?.currentTime || 0;
                currentTime = time;
                updateCurrentTime(time);
            }
            if (videoEl && videoEl.duration > 0) {
                const dur = Math.floor(videoEl.duration);
                duration = dur;
                updateDuration(dur);
            }
        };

        const onPlay = () => {
            playing = true;
            updatePlayingState(true);
            startRafLoop();
        };

        const onPause = () => {
            playing = false;
            updatePlayingState(false);
            stopRafLoop();
        };

        const onLoaded = () => {
            if (videoEl && videoEl.duration > 0) {
                const dur = Math.floor(videoEl.duration);
                duration = dur;
                updateDuration(dur);
            }
        };

        // Store listeners in component scope
        currentListeners = { onTime, onPlay, onPause, onLoaded };

        videoEl.addEventListener("timeupdate", onTime);
        videoEl.addEventListener("play", onPlay);
        videoEl.addEventListener("pause", onPause);
        videoEl.addEventListener("loadedmetadata", onLoaded);

        // initialize state
        const time = videoEl.currentTime || 0;
        currentTime = time;
        updateCurrentTime(time);
        if (videoEl && videoEl.duration > 0) {
            const dur = Math.floor(videoEl.duration);
            duration = dur;
            updateDuration(dur);
        }
        playing = !videoEl.paused;
        updatePlayingState(playing);

        if (playing) startRafLoop();
    }

    function detachVideo() {
        if (!videoEl || !currentListeners) return;

        videoEl.removeEventListener("timeupdate", currentListeners.onTime);
        videoEl.removeEventListener("play", currentListeners.onPlay);
        videoEl.removeEventListener("pause", currentListeners.onPause);
        videoEl.removeEventListener(
            "loadedmetadata",
            currentListeners.onLoaded,
        );

        stopRafLoop();
        currentListeners = null;
        videoEl = null;
    }

    function startRafLoop() {
        if (rafId != null) return;
        const loop = () => {
            if (videoEl && !isDragging && !isScrubbing) {
                const time = videoEl.currentTime;
                currentTime = time;
                updateCurrentTime(time);
                const dur = videoEl.duration
                    ? Math.floor(videoEl.duration)
                    : duration;
                duration = dur;
                updateDuration(dur);
            }
            rafId = requestAnimationFrame(loop);
        };
        rafId = requestAnimationFrame(loop);
    }

    function stopRafLoop() {
        if (rafId != null) {
            cancelAnimationFrame(rafId);
            rafId = null;
        }
    }

    function togglePlay() {
        if (!videoEl) return;
        if (videoEl.paused) videoEl.play().catch(() => {});
        else videoEl.pause();
    }

    function onSeekInput(e: Event) {
        if (!videoEl) return;
        const input = e.target as HTMLInputElement;
        const val = parseFloat(input.value) || 0;
        currentTime = val;
    }

    function onSeekChange(e: Event) {
        if (!videoEl) return;
        const input = e.target as HTMLInputElement;
        const val = parseFloat(input.value) || 0;
        videoEl.currentTime = val;
    }

    // Calculate time from mouse position
    function calculateTimeFromPosition(e: MouseEvent): number {
        if (!trackEl) return 0;
        const rect = trackEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, x / rect.width));
        return effectiveDuration * pct;
    }

    // Click to seek
    function onTrackClick(e: MouseEvent) {
        if (!trackEl) return;
        const newTime = calculateTimeFromPosition(e);
        seekTo(newTime);
        currentTime = newTime;
    }

    // Mouse down to start scrubbing
    function onTrackMouseDown(e: MouseEvent) {
        if (!browser || e.button !== 0) return; // Only left click in browser
        isScrubbing = true;
        const newTime = calculateTimeFromPosition(e);
        seekTo(newTime);
        currentTime = newTime;

        // Add global mouse event listeners
        window.addEventListener("mousemove", onTrackMouseMove);
        window.addEventListener("mouseup", onTrackMouseUp);
    }

    // Mouse move while scrubbing
    function onTrackMouseMove(e: MouseEvent) {
        if (!isScrubbing || !trackEl) return;
        const newTime = calculateTimeFromPosition(e);
        seekTo(newTime);
        currentTime = newTime;
    }

    // Mouse up to stop scrubbing
    function onTrackMouseUp() {
        if (!browser || !isScrubbing) return;
        isScrubbing = false;

        // Remove global mouse event listeners
        window.removeEventListener("mousemove", onTrackMouseMove);
        window.removeEventListener("mouseup", onTrackMouseUp);
    }

    // Handle mouse enter on timeline
    function onTrackMouseEnter() {
        isHovering = true;
    }

    // Handle mouse leave on timeline
    function onTrackMouseLeave() {
        isHovering = false;
    }

    // Handle mouse move for hover preview
    function onTrackHover(e: MouseEvent) {
        if (!trackEl) return;
        const rect = trackEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, x / rect.width));
        hoverTime = effectiveDuration * pct;
        hoverX = pct * 100;
    }

    function formatTime(t: number) {
        if (!isFinite(t) || t <= 0) return "0:00";
        const min = Math.floor(t / 60);
        const sec = Math.floor(t % 60);
        return `${min}:${sec.toString().padStart(2, "0")}`;
    }

    let observer: MutationObserver | null = null;

    onMount(() => {
        // initial find
        attachVideo(findVideo());

        // Watch for DOM changes only in the player container, not the entire document
        const container = document.querySelector("#player-container");
        if (container) {
            observer = new MutationObserver(() => {
                const found = findVideo();
                if (found !== videoEl) {
                    attachVideo(found);
                }
            });
            // Only observe the specific container, not subtree to reduce overhead
            observer.observe(container, { childList: true, subtree: false });
        }
    });

    onDestroy(() => {
        detachVideo();
        if (observer) {
            observer.disconnect();
            observer = null;
        }
        // Clean up scrubbing event listeners (only in browser)
        if (browser) {
            window.removeEventListener("mousemove", onTrackMouseMove);
            window.removeEventListener("mouseup", onTrackMouseUp);
        }
    });
</script>

<div class="px-8">
    <div class="flex items-center">
        <div class="flex-1 relative">
            <!-- visual track with playhead overlay -->
            <div
                bind:this={trackEl}
                class="relative cursor-pointer py-3 group"
                on:mousedown={onTrackMouseDown}
                on:mouseenter={onTrackMouseEnter}
                on:mouseleave={onTrackMouseLeave}
                on:mousemove={onTrackHover}
                role="slider"
                aria-label="Video timeline"
                aria-valuemin="0"
                aria-valuemax={effectiveDuration}
                aria-valuenow={currentTime}
                tabindex="0"
            >
                <!-- Waveform visualization -->
                {#if waveformData && waveformData.peaks.length > 0}
                    <div
                        class="absolute left-0 right-0 top-1/2 -translate-y-1/2 flex items-center gap-[2px] h-8"
                    >
                        {#each waveformData.peaks as peak, i}
                            {@const barWidth = 100 / waveformData.peaks.length}
                            {@const barHeight = Math.max(peak * 100, 20)}
                            {@const isPlayed =
                                i / waveformData.peaks.length <=
                                currentTime / effectiveDuration}
                            <div
                                class="flex-1 self-center rounded-sm transition-all duration-100"
                                style="height: {barHeight}%; background-color: {isPlayed
                                    ? 'rgb(233, 149, 12)'
                                    : 'rgba(156, 163, 175, 0.4)'}; min-width: 2px;"
                            ></div>
                        {/each}
                    </div>
                {:else}
                    <!-- Fallback to simple bar if no waveform -->
                    <div
                        class="absolute left-0 right-0 top-1/2 -translate-y-1/2 h-2 bg-gray-700/50 dark:bg-gray-600/50 rounded-full transition-all duration-200 {isHovering
                            ? 'h-3'
                            : 'h-2'}"
                    ></div>
                    <div
                        class="absolute left-0 top-1/2 -translate-y-1/2 h-2 rounded-full transition-all duration-200 {isHovering
                            ? 'h-3'
                            : 'h-2'}"
                        style="width: {effectiveDuration
                            ? (currentTime / effectiveDuration) * 100
                            : 0}%; background: rgb(233, 149, 12)"
                    ></div>
                {/if}

                <!-- Hover preview indicator -->
                {#if isHovering && !isScrubbing}
                    <div
                        class="absolute inset-y-0 -translate-x-1/2 transform pointer-events-none flex items-center"
                        style="left: {hoverX}%"
                    >
                        <div
                            class="w-px h-full bg-[rgb(233,149,12)] shadow-[0_0_8px_rgba(233,149,12,0.45)]"
                        ></div>
                        <div
                            class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 px-2 py-1 rounded-sm bg-gray-900/90 text-white text-[10px] tracking-tight shadow-lg backdrop-blur-sm"
                        >
                            {formatTime(hoverTime)}
                        </div>
                    </div>
                {/if}

                <!-- Playhead indicator -->
                <div
                    class="absolute top-1/2 -translate-x-1/2 -translate-y-1/2 w-3 h-3 bg-white border-2 border-orange-500 rounded-full shadow-lg pointer-events-none transition-transform duration-200 {isScrubbing ||
                    isHovering
                        ? 'scale-125'
                        : 'scale-100'} transform"
                    style="left: {effectiveDuration
                        ? (currentTime / effectiveDuration) * 100
                        : 0}%;"
                ></div>
            </div>

            <!-- accessible range input (keeps in sync) -->
            <input
                type="range"
                min="0"
                max={effectiveDuration || 0}
                step="0.1"
                value={currentTime}
                on:input={onSeekInput}
                on:change={onSeekChange}
                class="timeline-accessible-range"
                on:mousedown={() => (isDragging = true)}
                on:mouseup={() => (isDragging = false)}
            />
        </div>

        <div
            class="text-xs tabular-nums text-gray-700 dark:text-gray-200 w-10 bg text-right"
        >
            {formatTime(Math.max(0, effectiveDuration - (currentTime || 0)))}
        </div>
    </div>
</div>

<style>
    /* small tweaks for the inline playhead and track */
    :global(.dark) .bg-gray-200 {
        background-color: rgba(255, 255, 255, 0.06);
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 0;
        height: 0;
    }
    input[type="range"]::-moz-range-thumb {
        width: 0;
        height: 0;
        border: none;
    }
    .timeline-accessible-range {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        pointer-events: none;
        background: transparent;
    }
    .timeline-accessible-range:focus-visible {
        opacity: 1;
        pointer-events: auto;
        outline: 2px solid rgb(233, 149, 12);
        outline-offset: 4px;
    }
    .timeline-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        border-radius: 9999px;
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        transition:
            background 0.2s ease,
            transform 0.2s ease;
    }

    .timeline-button:hover {
        transform: scale(1.05);
        background: rgba(255, 255, 255, 0.2);
    }

    .timeline-button svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
    }
</style>
</file>

<file path="src/lib/data/comments.ts">
import type { Comment } from '$lib/types/content';

export const comments: Comment[] = [
	{
		id: 1,
		user: 'Sarah Chen',
		avatar: 'https://i.pravatar.cc/150?img=1',
		content:
			'The lighting in this scene is particularly striking. The way the shadows fall creates a dramatic contrast.',
		timestamp: '2 hours ago',
		likes: 12
	},
	{
		id: 2,
		user: 'Michael Rodriguez',
		avatar: 'https://i.pravatar.cc/150?img=2',
		content:
			'I notice the subtle camera movement here - it adds a lot of depth to the composition.',
		timestamp: '5 hours ago',
		likes: 8
	},
	{
		id: 3,
		user: 'Emma Thompson',
		avatar: 'https://i.pravatar.cc/150?img=3',
		content: 'The color grading in this shot really enhances the mood. Great work!',
		timestamp: '1 day ago',
		likes: 15
	}
];

export function getCommentsByVideoId(_videoId: string): Comment[] {
	return comments;
}
</file>

<file path="src/lib/server/db/index.ts">
// src/lib/db/index.ts

import { drizzle } from 'drizzle-orm/neon-http';
import { neon } from '@neondatabase/serverless';
import { DATABASE_URL } from '$env/static/private';
import * as schema from './schema';

// This creates an HTTP-based client
const sql = neon(DATABASE_URL);

// Use the neon-http drizzle adapter
export const db = drizzle(sql, { schema });
</file>

<file path="src/lib/server/db/schema.ts">
import { pgTable, text, integer, doublePrecision, primaryKey, uniqueIndex, index, serial, timestamp } from 'drizzle-orm/pg-core';

export const users = pgTable(
    'users',
    {
        id: serial('id').primaryKey(),
        slug: text('slug').notNull(),
        name: text('name').notNull(),
        avatar: text('avatar'),
        bio: text('bio'),
        createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
    },
    (table) => ({
        slugIdx: uniqueIndex('users_slug_unique').on(table.slug)
    })
);

export const videos = pgTable(
	'videos',
	{
		id: text('id').primaryKey(),
		title: text('title').notNull(),
		description: text('description').notNull(),
		userId: integer('user_id')
			.notNull()
			.references(() => users.id, { onDelete: 'cascade' }),
		videoUrl: text('video_url'),
		thumbnailUrl: text('thumbnail_url'),
		duration: integer('duration').notNull().default(0),
		uploadedAt: timestamp('uploaded_at', { withTimezone: true }),
		views: integer('views').notNull().default(0),
        likes: integer('likes').notNull().default(0),
        latitude: doublePrecision('latitude'),
        longitude: doublePrecision('longitude'),
        transcript: text('transcript'),
        createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
    },
    (table) => ({
        userIdx: index('videos_user_idx').on(table.userId)
    })
);

export const tags = pgTable(
    'tags',
    {
        id: serial('id').primaryKey(),
        name: text('name').notNull()
    },
    (table) => ({
        nameIdx: uniqueIndex('tags_name_unique').on(table.name)
    })
);

export const videoTags = pgTable(
    'video_tags',
    {
        videoId: text('video_id')
            .notNull()
            .references(() => videos.id, { onDelete: 'cascade' }),
        tagId: integer('tag_id')
            .notNull()
            .references(() => tags.id, { onDelete: 'cascade' })
    },
    (table) => ({
        pk: primaryKey({ columns: [table.videoId, table.tagId] })
    })
);

export const userFollows = pgTable(
    'user_follows',
    {
        followerId: integer('follower_id')
            .notNull()
            .references(() => users.id, { onDelete: 'cascade' }),
        followingId: integer('following_id')
            .notNull()
            .references(() => users.id, { onDelete: 'cascade' })
    },
    (table) => ({
        pk: primaryKey({ columns: [table.followerId, table.followingId] })
    })
);

export type UserInsert = typeof users.$inferInsert;
export type UserSelect = typeof users.$inferSelect;
export type VideoInsert = typeof videos.$inferInsert;
export type VideoSelect = typeof videos.$inferSelect;
export type TagInsert = typeof tags.$inferInsert;
export type TagSelect = typeof tags.$inferSelect;
</file>

<file path="src/lib/server/db/users.ts">
import { db } from './index';
import { users, videos, userFollows } from './schema';
import type { User, UserVideoSummary } from '$lib/types/content';
import { eq } from 'drizzle-orm';

const DEFAULT_AVATAR = 'https://i.pravatar.cc/150?img=15';
const DEFAULT_THUMBNAIL = 'https://placehold.co/400x225?text=Video';

function summariseVideos(rows: Array<{
	id: string;
	title: string;
	thumbnailUrl: string | null;
	duration: number | null;
	userId: number;
}>): Map<number, UserVideoSummary[]> {
	const map = new Map<number, UserVideoSummary[]>();
	for (const row of rows) {
		const entry = map.get(row.userId) ?? [];
		entry.push({
			id: row.id,
			title: row.title,
			thumbnail: row.thumbnailUrl ?? DEFAULT_THUMBNAIL,
			duration: row.duration ?? 0
		});
		map.set(row.userId, entry);
	}
	return map;
}

function computeFollowMaps(rows: Array<{ followerId: number; followingId: number }>) {
	const followers = new Map<number, Set<number>>();
	const following = new Map<number, Set<number>>();

	for (const row of rows) {
		const followersSet = followers.get(row.followingId) ?? new Set<number>();
		followersSet.add(row.followerId);
		followers.set(row.followingId, followersSet);

		const followingSet = following.get(row.followerId) ?? new Set<number>();
		followingSet.add(row.followingId);
		following.set(row.followerId, followingSet);
	}

	return { followers, following };
}

function formatUser(row: typeof users.$inferSelect, options: {
	videos: UserVideoSummary[];
	followers: number;
	following: number;
}): User {
	const { videos, followers, following } = options;
	return {
		id: row.slug,
		name: row.name,
		avatar: row.avatar ?? DEFAULT_AVATAR,
		bio: row.bio ?? '',
		stats: {
			videos: videos.length,
			followers,
			following
		},
		videos,
		recentVideos: videos.slice(0, 3),
		subscribers: followers,
		joinedAt: row.createdAt ?? undefined
	};
}

export async function getAllUsers(): Promise<User[]> {
	const userRows = await db.select().from(users).execute();
	const videoRows = await db
		.select({
			id: videos.id,
			title: videos.title,
			thumbnailUrl: videos.thumbnailUrl,
			duration: videos.duration,
			userId: videos.userId
		})
		.from(videos)
		.execute();
	const followRows = await db.select().from(userFollows).execute();

	const videosByUser = summariseVideos(videoRows);
	const { followers, following } = computeFollowMaps(followRows);

	return userRows.map((row) =>
		formatUser(row, {
			videos: videosByUser.get(row.id) ?? [],
			followers: followers.get(row.id)?.size ?? 0,
			following: following.get(row.id)?.size ?? 0
		})
	);
}

export async function getUserBySlug(slug: string): Promise<User | null> {
	const rows = await db.select().from(users).where(eq(users.slug, slug)).limit(1).execute();
	if (!rows.length) return null;

	const user = rows[0];
	const userVideosRows = await db
		.select({
			id: videos.id,
			title: videos.title,
			thumbnailUrl: videos.thumbnailUrl,
			duration: videos.duration,
			userId: videos.userId
		})
		.from(videos)
		.where(eq(videos.userId, user.id))
		.execute();

	const followerRows = await db
		.select({
			followerId: userFollows.followerId
		})
		.from(userFollows)
		.where(eq(userFollows.followingId, user.id))
		.execute();

	const followingRows = await db
		.select({
			followingId: userFollows.followingId
		})
		.from(userFollows)
		.where(eq(userFollows.followerId, user.id))
		.execute();

	const followersSet = new Set<number>();
	const followingSet = new Set<number>();

	for (const follower of followerRows) {
		if (typeof follower.followerId === 'number') {
			followersSet.add(follower.followerId);
		}
	}

	for (const followee of followingRows) {
		if (typeof followee.followingId === 'number') {
			followingSet.add(followee.followingId);
		}
	}

	return formatUser(user, {
		videos: summariseVideos(userVideosRows).get(user.id) ?? [],
		followers: followersSet.size,
		following: followingSet.size
	});
}
</file>

<file path="src/lib/server/db/videos.ts">
import { db } from "./index";
import { users, videos, videoTags, tags } from "./schema";
import { desc, eq, inArray } from "drizzle-orm";
import type { Video } from "$lib/types/content";

function mapRowToVideo(
  row: typeof videos.$inferSelect & {
    userName: string;
    userSlug: string;
    userAvatar: string | null;
  },
) {
  const coordinates =
    typeof row.latitude === "number" && typeof row.longitude === "number"
      ? [
          {
            name: row.title,
            coordinates: [row.longitude, row.latitude] as [number, number], // GeoJSON standard: [lon, lat]
            latitude: row.latitude,
            longitude: row.longitude,
            mapLat: row.latitude,
            mapLon: row.longitude,
            isExterior: 1,
            isDay: 1,
            isGuess: false,
            startTime: 0,
            endTime: 0,
          },
        ]
      : [];

  const uploadedAt =
    row.uploadedAt instanceof Date
      ? row.uploadedAt.toISOString()
      : (row.uploadedAt ?? undefined);
  const createdAt =
    row.createdAt instanceof Date
      ? row.createdAt.toISOString()
      : (row.createdAt ?? undefined);

  return {
    id: row.id,
    title: row.title,
    description: row.description,
    author: row.userName,
    authorId: row.userSlug,
    duration: row.duration ?? 0,
    uploadedAt,
    uploadDate: uploadedAt,
    url: row.videoUrl ?? undefined,
    videoUrl: row.videoUrl ?? undefined,
    thumbnailUrl: row.thumbnailUrl ?? undefined,
    locations: coordinates,
    transcript: row.transcript ?? "Transcript not available.",
    keywords: [],
    views: row.views ?? 0,
    likes: row.likes ?? 0,
    timestamp: uploadedAt ?? createdAt,
  } satisfies Video;
}

export async function getAllVideos(): Promise<Video[]> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      latitude: videos.latitude,
      longitude: videos.longitude,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .orderBy(desc(videos.createdAt))
    .execute();

  const videoIds = rows.map((row) => row.id);

  const tagRows = videoIds.length
    ? await db
        .select({
          videoId: videoTags.videoId,
          tag: tags.name,
        })
        .from(videoTags)
        .innerJoin(tags, eq(videoTags.tagId, tags.id))
        .where(inArray(videoTags.videoId, videoIds))
        .execute()
    : [];

  const tagsByVideo = new Map<string, string[]>();
  for (const tagRow of tagRows) {
    const list = tagsByVideo.get(tagRow.videoId) ?? [];
    if (typeof tagRow.tag === "string") {
      list.push(tagRow.tag);
      tagsByVideo.set(tagRow.videoId, list);
    }
  }

  return rows.map((row) => {
    const mapped = mapRowToVideo(row);
    mapped.keywords = tagsByVideo.get(row.id) ?? [];
    return mapped;
  });
}

export async function getVideoById(id: string): Promise<Video | null> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .where(eq(videos.id, id))
    .limit(1)
    .execute();

  if (!rows.length) return null;

  const videoTagsRows = await db
    .select({
      videoId: videoTags.videoId,
      tag: tags.name,
    })
    .from(videoTags)
    .innerJoin(tags, eq(videoTags.tagId, tags.id))
    .where(eq(videoTags.videoId, id))
    .execute();

  const video = mapRowToVideo(rows[0]);
  video.keywords = videoTagsRows.map((row) => row.tag ?? "").filter(Boolean);
  return video;
}

export async function getVideosByUserId(userId: number): Promise<Video[]> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .where(eq(videos.userId, userId))
    .orderBy(desc(videos.createdAt))
    .execute();

  const videoIds = rows.map((row) => row.id);

  const tagRows = videoIds.length
    ? await db
        .select({
          videoId: videoTags.videoId,
          tag: tags.name,
        })
        .from(videoTags)
        .innerJoin(tags, eq(videoTags.tagId, tags.id))
        .where(inArray(videoTags.videoId, videoIds))
        .execute()
    : [];

  const tagsByVideo = new Map<string, string[]>();
  for (const tagRow of tagRows) {
    const list = tagsByVideo.get(tagRow.videoId) ?? [];
    if (typeof tagRow.tag === "string") {
      list.push(tagRow.tag);
      tagsByVideo.set(tagRow.videoId, list);
    }
  }

  return rows.map((row) => {
    const mapped = mapRowToVideo(row);
    mapped.keywords = tagsByVideo.get(row.id) ?? [];
    return mapped;
  });
}
</file>

<file path="src/lib/stores/appStore.ts">
import { browser } from '$app/environment';
import { writable } from 'svelte/store';
import { gsap } from 'gsap/dist/gsap';
import Flip from 'gsap/dist/Flip';

interface UiState {
	isExpanded: boolean;
}

const store = writable<UiState>({ isExpanded: false });

type LayoutClass = 'fullscreen' | 'sidebar';

let flipRegistered = false;

function getScrollContainer() {
	return document.querySelector('#scroll-content') as HTMLElement | null;
}

function getSidebarDetails() {
	return document.querySelector('#sidebar-details') as HTMLElement | null;
}

function setScrollContainerMode(layout: LayoutClass) {
	const scroller = getScrollContainer();
	if (!scroller) return;
	scroller.classList.add('overflow-y-auto');
	scroller.dataset.layout = layout;
}

function ensureFlipRegistered() {
	if (!flipRegistered) {
		gsap.registerPlugin(Flip);
		flipRegistered = true;
	}
}

function getCurrentLayout(container: HTMLElement): LayoutClass | null {
	if (container.classList.contains('fullscreen')) return 'fullscreen';
	if (container.classList.contains('sidebar')) return 'sidebar';
	return null;
}

function updateLayoutClass(isExpanded: boolean) {
	if (!browser) return;
	const container = document.getElementById('player-container');
	if (!container) return;

	ensureFlipRegistered();

	const nextLayout: LayoutClass = isExpanded ? 'fullscreen' : 'sidebar';
	const previousLayout = getCurrentLayout(container);

	const scroller = getScrollContainer();
	const details = getSidebarDetails();
	const flipTargets = details ? [container, details] : container;

	if (previousLayout === nextLayout) {
		container.classList.remove('fullscreen', 'sidebar');
		container.classList.add(nextLayout);
		if (scroller) {
			setScrollContainerMode(nextLayout);
		}
		return;
	}

	const state = Flip.getState(flipTargets);

	let restoreScroll: (() => void) | null = null;
	if (scroller) {
		const { overflow, overflowX, overflowY } = scroller.style;
		scroller.classList.remove('overflow-y-auto');
		scroller.style.overflow = 'visible';
		let restored = false;
		restoreScroll = () => {
			if (restored) return;
			restored = true;
			scroller.style.overflow = overflow;
			scroller.style.overflowX = overflowX;
			scroller.style.overflowY = overflowY;
			setScrollContainerMode(nextLayout);
		};
	}

	container.classList.remove('fullscreen', 'sidebar');
	container.classList.add(nextLayout);

	const finalize = () => {
		if (restoreScroll) restoreScroll();
		else setScrollContainerMode(nextLayout);
	};

	Flip.from(state, {
		absolute: true,
		duration: 0.38,
		ease: 'power2.inOut',
		onComplete: finalize,
		onInterrupt: finalize
	});
}

export const actions = {
	toggleMode() {
		store.update((current) => {
			const next = { ...current, isExpanded: !current.isExpanded };
			updateLayoutClass(next.isExpanded);
			return next;
		});
	},
	setExpanded(value: boolean) {
		store.update((current) => {
			if (current.isExpanded === value) return current;
			const next = { ...current, isExpanded: value };
			updateLayoutClass(next.isExpanded);
			return next;
		});
	}
};

export const uiState = {
	subscribe: store.subscribe,
	set(value: UiState) {
		store.set(value);
		updateLayoutClass(value.isExpanded);
	},
	update(updater: (state: UiState) => UiState) {
		store.update((state) => {
			const next = updater(state);
			updateLayoutClass(next.isExpanded);
			return next;
		});
	}
};
</file>

<file path="src/lib/stores/auth.ts">
import { writable } from 'svelte/store';

export interface AuthUser {
	id: string;
	name: string;
	email: string;
	avatarUrl?: string;
}

interface AuthState {
	user: AuthUser | null;
}

function createAuthStore() {
	const { subscribe, set, update } = writable<AuthState>({ user: null });

	return {
		subscribe,
		login(user: AuthUser) {
			set({ user });
		},
		logout() {
			set({ user: null });
		},
		updateUser(updater: (user: AuthUser) => AuthUser) {
			update((state) => {
				if (!state.user) return state;
				return { user: updater(state.user) };
			});
		}
	};
}

export const authStore = createAuthStore();
</file>

<file path="src/lib/stores/library.ts">
import { derived, get, writable } from 'svelte/store';
import type { Video, User } from '$lib/types/content';

export const videosStore = writable<Video[]>([]);
export const usersStore = writable<User[]>([]);

export const videosByIdStore = derived(videosStore, ($videos) => {
	const map = new Map<string, Video>();
	for (const video of $videos) {
		map.set(video.id, video);
	}
	return map;
});

export const usersByIdStore = derived(usersStore, ($users) => {
	const map = new Map<string, User>();
	for (const user of $users) {
		map.set(user.id, user);
	}
	return map;
});

export function initialiseLibrary(videos: Video[], users: User[]) {
	videosStore.set(videos);
	usersStore.set(users);
}

export function getVideoById(id: string): Video | undefined {
	return get(videosByIdStore).get(id);
}

export function getUserById(id: string): User | undefined {
	return get(usersByIdStore).get(id);
}
</file>

<file path="src/lib/stores/playerStore.svelte.ts">
/**
 * Central player state store using Svelte 5 runes
 * Manages video playback state and seeking operations
 */

let currentTime = $state(0);
let duration = $state(0);
let isPlaying = $state(false);
let seekRequested = $state<number | null>(null);

/**
 * Request a seek to a specific time in the video
 * This will trigger the video player to update its position
 */
export function seekTo(time: number) {
	if (time < 0 || !isFinite(time)) return;
	seekRequested = time;
	currentTime = time;
}

/**
 * Update the current playback time
 * Should be called by the video player as it plays
 */
export function updateCurrentTime(time: number) {
	currentTime = time;
	// Clear seek request after it's been applied
	if (seekRequested !== null && Math.abs(seekRequested - time) < 0.5) {
		seekRequested = null;
	}
}

/**
 * Update the video duration
 * Should be called when video metadata is loaded
 */
export function updateDuration(dur: number) {
	duration = dur;
}

/**
 * Update the playing state
 */
export function updatePlayingState(playing: boolean) {
	isPlaying = playing;
}

/**
 * Clear seek request flag
 * Used internally after seek has been applied
 */
export function clearSeekRequest() {
	seekRequested = null;
}

/**
 * Get the current player state
 * These are reactive getters using Svelte 5 runes
 */
export function getPlayerState() {
	return {
		get currentTime() {
			return currentTime;
		},
		get duration() {
			return duration;
		},
		get isPlaying() {
			return isPlaying;
		},
		get seekRequested() {
			return seekRequested;
		}
	};
}
</file>

<file path="src/lib/stores/selectedVideo.ts">
import { writable } from 'svelte/store';

export interface SelectedVideoState {
	id: string | null;
	queue: string[];
	isFullScreen: boolean;
	history: string[];
}

const initialState: SelectedVideoState = {
	id: null,
	queue: [],
	isFullScreen: false,
	history: []
};

function resolveNext(state: SelectedVideoState): string | null {
	if (!state.id || state.queue.length === 0) return null;

	const index = state.queue.indexOf(state.id);
	if (index === -1) return state.queue[0] ?? null;
	if (index === state.queue.length - 1) return state.queue[0] ?? null;
	return state.queue[index + 1] ?? null;
}

function resolvePrevious(state: SelectedVideoState): string | null {
	if (!state.id || state.queue.length === 0) return null;

	const index = state.queue.indexOf(state.id);
	if (index === -1) return state.queue[state.queue.length - 1] ?? null;
	if (index === 0) return state.queue[state.queue.length - 1] ?? null;
	return state.queue[index - 1] ?? null;
}

function createSelectedVideoStore() {
	const store = writable<SelectedVideoState>({ ...initialState });
	let snapshot = initialState;

	store.subscribe((value) => {
		snapshot = value;
	});

	function setQueue(videoIds: string[]) {
		store.update((current) => ({
			...current,
			queue: [...videoIds]
		}));
	}

	function selectVideo(id: string | null) {
		store.update((current) => {
			if (current.id === id) return current;
			const history = current.id ? [...current.history, current.id] : [...current.history];
			return {
				...current,
				id,
				isFullScreen: false,
				history
			};
		});
	}

	function playNext() {
		const next = resolveNext(snapshot);
		if (next) {
			selectVideo(next);
		}
	}

	function playPrevious() {
		const previous = resolvePrevious(snapshot);
		if (previous) {
			selectVideo(previous);
		}
	}

	function toggleFullScreen(force?: boolean) {
		store.update((current) => {
			const nextValue = typeof force === 'boolean' ? force : !current.isFullScreen;
			if (current.isFullScreen === nextValue) return current;
			return { ...current, isFullScreen: nextValue };
		});
	}

	function setFullScreen(value: boolean) {
		store.update((current) => {
			if (current.isFullScreen === value) return current;
			return { ...current, isFullScreen: value };
		});
	}

	function reset() {
		store.set({ ...initialState });
	}

	return {
		subscribe: store.subscribe,
		selectVideo,
		setQueue,
		playNext,
		playPrevious,
		toggleFullScreen,
		setFullScreen,
		reset,
		get id() {
			return snapshot.id;
		},
		get queue() {
			return [...snapshot.queue];
		},
		get isFullScreen() {
			return snapshot.isFullScreen;
		},
		get history() {
			return [...snapshot.history];
		},
		get nextVideoId() {
			return resolveNext(snapshot);
		},
		get previousVideoId() {
			return resolvePrevious(snapshot);
		}
	};
}

export const selectedVideo = createSelectedVideoStore();
</file>

<file path="src/lib/stores/theme.ts">
import { browser } from '$app/environment';
import { writable } from 'svelte/store';

type Theme = 'light' | 'dark';

const STORAGE_KEY = 'rushes-theme';
const store = writable<Theme>('light');

function applyTheme(next: Theme) {
	if (!browser) return;
	const root = document.documentElement;
	root.classList.toggle('dark', next === 'dark');
	root.dataset.theme = next;
	try {
		localStorage.setItem(STORAGE_KEY, next);
	} catch (error) {
		console.warn('Unable to persist theme preference', error);
	}
}

function detectPreferredTheme(): Theme {
	if (!browser) return 'light';
	const stored = (() => {
		try {
			const value = localStorage.getItem(STORAGE_KEY);
			return value === 'dark' || value === 'light' ? value : null;
		} catch {
			return null;
		}
	})();
	if (stored) return stored;
	return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}

export const theme = {
	subscribe: store.subscribe,
	/**
	 * Synchronise the theme store with persisted preference and system defaults.
	 */
	init() {
		const initial = detectPreferredTheme();
		store.set(initial);
		applyTheme(initial);
	},
	set(value: Theme) {
		store.set(value);
		applyTheme(value);
	},
	toggle() {
		store.update((current) => {
			const next: Theme = current === 'dark' ? 'light' : 'dark';
			applyTheme(next);
			return next;
		});
	}
};

export type ThemeStore = typeof theme;
</file>

<file path="src/lib/stores/video.ts">
import { writable } from 'svelte/store';

export interface ActiveVideoState {
	id: string;
	url: string;
	title: string;
	author: string;
	authorId?: string;
	thumbnailUrl?: string;
	durationSeconds?: number;
}

function createActiveVideoStore() {
	const store = writable<ActiveVideoState | null>(null);

	return {
		subscribe: store.subscribe,
		setActive(video: ActiveVideoState | null) {
			store.set(video);
		},
		clear() {
			store.set(null);
		}
	};
}

export const activeVideo = createActiveVideoStore();
</file>

<file path="src/lib/types/content.ts">
export interface Location {
	setting?: string;
	environment?: string;
	startTime?: number;
	endTime?: number;
	isExterior?: number;
	isDay?: number;
	longitude?: number;
	latitude?: number;
	mapLat?: number;
	mapLon?: number;
	isGuess?: boolean;
	id?: number;
	name?: string;
	coordinates?: [number, number];
}

export interface Video {
	id: string;
	title: string;
	description: string;
	author: string;
	authorId: string;
	duration?: number;
	uploadedAt?: string;
	url?: string;
	videoUrl?: string;
	thumbnailUrl?: string;
	locations?: Location[];
	keywords?: string[];
	transcript?: string;
	views?: number;
	likes?: number;
	gcs_uri?: string;
	source_url?: string;
	timestamp?: string;
	raw_response_json?: unknown;
	uploadDate?: string;
}

export interface UserVideoSummary {
	id: string;
	title: string;
	thumbnail: string;
	duration?: number;
}

export interface UserStats {
	videos: number;
	followers: number;
	following: number;
}

export interface User {
	id: string;
	name: string;
	avatar: string;
	bio: string;
	stats: UserStats;
	videos: UserVideoSummary[];
	email?: string;
	subscribers?: number;
	joinedAt?: string;
	verified?: boolean;
	recentVideos?: UserVideoSummary[];
}

export interface Comment {
	id: number;
	user: string;
	avatar: string;
	content: string;
	timestamp: string;
	likes: number;
}
</file>

<file path="src/lib/types/dashboard.ts">
export type DashboardComponentKey =
	| 'videos'
	| 'profile'
	| 'activity'
	| 'sounds'
	| 'members'
	| 'keywords'
	| 'locations';

export type DashboardItem = {
	id: number;
	component: DashboardComponentKey;
	[key: string]: unknown;
};

export type SortDirection = 'asc' | 'desc';
export type TableKey = 'videos' | 'sounds' | 'members' | 'keywords';

export interface TableColumn {
	key: string;
	label: string;
	align?: 'left' | 'right';
}

export interface TableState {
	key: TableKey;
	label: string;
	sortKey: string;
	sortDirection: SortDirection;
	defaultSort: { key: string; direction: SortDirection };
	columns: TableColumn[];
}

export interface LatestLocationPin {
	id: string;
	videoId: string;
	videoTitle: string;
	videoAuthor?: string;
	uploadedLabel: string;
	timestampValue: number;
	lat: number;
	lon: number;
	setting?: string;
	thumbnailUrl?: string;
}

export interface LocationCenter {
	lat: number;
	lon: number;
	zoom: number;
}
</file>

<file path="src/lib/utils/waveform.ts">
/**
 * Waveform generation utility for HLS audio streams
 * Uses Web Audio API to analyze audio and generate waveform data
 */

export interface WaveformData {
  peaks: number[];
  duration: number;
}

/**
 * Generate waveform data from an HLS video URL
 * Extracts audio and analyzes it using Web Audio API
 */
export async function generateWaveform(
  videoUrl: string,
  samplesPerSecond: number = 10
): Promise<WaveformData | null> {
  try {
    // Create an audio element to load the HLS stream
    const audio = new Audio();
    audio.crossOrigin = 'anonymous';
    audio.src = videoUrl;

    // Wait for metadata to load
    await new Promise<void>((resolve, reject) => {
      audio.addEventListener('loadedmetadata', () => resolve(), { once: true });
      audio.addEventListener('error', reject, { once: true });
      audio.load();
    });

    const duration = audio.duration;
    if (!duration || !isFinite(duration)) {
      throw new Error('Invalid audio duration');
    }

    // Create audio context
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    const source = audioContext.createMediaElementSource(audio);
    const analyser = audioContext.createAnalyser();

    // Configure analyser
    analyser.fftSize = 2048;
    source.connect(analyser);
    // Don't connect to destination to avoid playing audio

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const totalSamples = Math.floor(duration * samplesPerSecond);
    const peaks: number[] = new Array(totalSamples).fill(0);
    const sampleDuration = duration / totalSamples;

    let currentSample = 0;

    // Play the audio (muted) and collect samples
    audio.muted = true;
    audio.play();

    return new Promise<WaveformData>((resolve, reject) => {
      const collectData = () => {
        const currentTime = audio.currentTime;
        const sampleIndex = Math.floor(currentTime / sampleDuration);

        if (sampleIndex < totalSamples) {
          // Get frequency data
          analyser.getByteFrequencyData(dataArray);

          // Calculate RMS (root mean square) for this sample
          let sum = 0;
          for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i] * dataArray[i];
          }
          const rms = Math.sqrt(sum / bufferLength);

          // Normalize to 0-1 range
          peaks[sampleIndex] = Math.max(peaks[sampleIndex], rms / 255);
        }

        if (currentTime < duration) {
          requestAnimationFrame(collectData);
        } else {
          // Cleanup
          audio.pause();
          audio.src = '';
          audioContext.close();

          resolve({
            peaks,
            duration
          });
        }
      };

      audio.addEventListener('error', () => {
        audioContext.close();
        reject(new Error('Failed to load audio'));
      });

      requestAnimationFrame(collectData);
    });
  } catch (error) {
    console.error('Waveform generation error:', error);
    return null;
  }
}

/**
 * Simplified waveform generation for faster loading
 * Uses fewer samples and simplified analysis
 */
export async function generateSimplifiedWaveform(
  videoElement: HTMLVideoElement,
  samples: number = 100
): Promise<WaveformData | null> {
  try {
    if (!videoElement.src) return null;

    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    const source = audioContext.createMediaElementSource(videoElement);
    const analyser = audioContext.createAnalyser();

    analyser.fftSize = 256;
    analyser.smoothingTimeConstant = 0.8;

    source.connect(analyser);
    analyser.connect(audioContext.destination);

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const peaks: number[] = [];

    // Generate mock waveform for now (replace with real-time analysis)
    for (let i = 0; i < samples; i++) {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let j = 0; j < bufferLength; j++) {
        sum += dataArray[j];
      }
      const average = sum / bufferLength / 255;
      peaks.push(average || Math.random() * 0.3 + 0.1);
    }

    return {
      peaks,
      duration: videoElement.duration
    };
  } catch (error) {
    console.error('Simplified waveform generation error:', error);
    return null;
  }
}

/**
 * Generate a mock waveform for testing/fallback
 * Creates a natural-looking random waveform
 */
export function generateMockWaveform(samples: number = 100, duration: number = 0): WaveformData {
  const peaks: number[] = [];

  for (let i = 0; i < samples; i++) {
    // Create more natural variation using sine waves and randomness
    const position = i / samples;
    const lowFreq = Math.sin(position * Math.PI * 2) * 0.3;
    const midFreq = Math.sin(position * Math.PI * 8) * 0.2;
    const noise = Math.random() * 0.2;

    const peak = Math.abs(lowFreq + midFreq + noise);
    peaks.push(Math.min(peak + 0.1, 1)); // Ensure minimum visibility
  }

  return {
    peaks,
    duration
  };
}
</file>

<file path="src/lib/workers/videoMetadata.worker.ts">
declare const self: DedicatedWorkerGlobalScope;

type IncomingMessage =
	| {
			type: 'extract-metadata';
			buffer: ArrayBuffer;
			lastModified?: number;
	  };

interface MetadataResult {
	date?: string;
	latitude?: number;
	longitude?: number;
	source?: string;
}

interface CoordinateMatch {
	lat: number;
	lon: number;
	source: string;
}

const decoder = new TextDecoder('utf-8', { fatal: false, ignoreBOM: true });
const MAX_SAMPLE_BYTES = 8 * 1024 * 1024; // Scan 8MB from start and end

self.onmessage = (event: MessageEvent<IncomingMessage>) => {
	const message = event.data;
	if (!message) return;

	if (message.type === 'extract-metadata') {
		try {
			const metadata = extractMetadata(message.buffer, message.lastModified);
			self.postMessage({ type: 'metadata-result', metadata });
		} catch (error) {
			const message =
				error instanceof Error ? error.message : 'Unknown metadata extraction error';
			self.postMessage({ type: 'error', error: message });
		}
	}
};

function extractMetadata(buffer: ArrayBuffer, lastModified?: number): MetadataResult {
	const bytes = new Uint8Array(buffer);
	const sampledText = buildSampledText(bytes);
	const metadata: MetadataResult = {};

	const date = findDate(sampledText) ?? (lastModified ? new Date(lastModified).toISOString() : undefined);
	if (date) {
		metadata.date = date;
	}

	const coords = findCoordinates(sampledText);
	if (coords) {
		metadata.latitude = coords.lat;
		metadata.longitude = coords.lon;
		metadata.source = coords.source;
	}

	return metadata;
}

function buildSampledText(bytes: Uint8Array): string {
	if (bytes.length === 0) return '';

	const segments: string[] = [];
	const headLength = Math.min(bytes.length, MAX_SAMPLE_BYTES);
	segments.push(
		decoder.decode(bytes.subarray(0, headLength)).replace(/\u0000/g, ' ')
	);

	if (bytes.length > MAX_SAMPLE_BYTES) {
		const tailStart = Math.max(0, bytes.length - MAX_SAMPLE_BYTES);
		segments.push(
			decoder.decode(bytes.subarray(tailStart)).replace(/\u0000/g, ' ')
		);
	}

	return segments.join('\n');
}

function findDate(text: string): string | undefined {
	const patterns: RegExp[] = [
		/com\.apple\.quicktime\.creationdate[^0-9]*([0-9]{4}[-:][0-9]{2}[-:][0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2}(?:\.\d+)?(?:Z|[+-][0-9]{2}:?[0-9]{2})?)?)/i,
		/creation_time[^0-9]*([0-9]{4}[-:][0-9]{2}[-:][0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2}(?:\.\d+)?(?:Z|[+-][0-9]{2}:?[0-9]{2})?)?)/i,
		/date_recorded[^0-9]*([0-9]{4}[-:][0-9]{2}[-:][0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?)/i
	];

	for (const pattern of patterns) {
		const match = text.match(pattern);
		if (match && match[1]) {
			const iso = toIso(match[1]);
			if (iso) return iso;
		}
	}
	return undefined;
}

function toIso(value: string): string | undefined {
	const trimmed = value.trim();
	if (!trimmed) return undefined;

	const normalised = trimmed.replace(/(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
	const withT = normalised.includes('T')
		? normalised
		: normalised.replace(' ', 'T');

	const date = new Date(withT);
	if (!Number.isNaN(date.getTime())) {
		return date.toISOString();
	}

	// Attempt to coerce missing timezone (assume UTC)
	if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/.test(withT)) {
		const utc = new Date(`${withT}Z`);
		if (!Number.isNaN(utc.getTime())) {
			return utc.toISOString();
		}
	}

	if (/^\d{4}-\d{2}-\d{2}$/.test(withT)) {
		return `${withT}T00:00:00.000Z`;
	}

	return undefined;
}

function findCoordinates(text: string): CoordinateMatch | null {
	const candidates = [
		{ term: 'com.apple.quicktime.location.iso6709', window: 160 },
		{ term: 'com.apple.quicktime.location', window: 160 },
		{ term: 'com.apple.quicktime.latitude', window: 200 },
		{ term: 'com.apple.quicktime.longitude', window: 200 },
		{ term: 'ISO6709', window: 160 },
		{ term: '¬©xyz', window: 120 },
		{ term: 'gps', window: 200 },
		{ term: 'location', window: 200 }
	];

	for (const candidate of candidates) {
		const coords = scanForTerm(text, candidate.term, candidate.window);
		if (coords) return coords;
	}

	const generalIso = scanIsoSequences(text);
	if (generalIso) return generalIso;

	const latLonPair = scanLatLonPairs(text);
	if (latLonPair) return latLonPair;

	return null;
}

function scanForTerm(text: string, term: string, window: number): CoordinateMatch | null {
	const lowerText = text.toLowerCase();
	const lowerTerm = term.toLowerCase();
	let index = lowerText.indexOf(lowerTerm);

	while (index !== -1) {
		const snippet = text.slice(index, Math.min(text.length, index + lowerTerm.length + window));
		const coords = parseCoordinates(snippet);
		if (coords) {
			return { ...coords, source: term };
		}
		index = lowerText.indexOf(lowerTerm, index + lowerTerm.length);
	}

	return null;
}

function scanIsoSequences(text: string): CoordinateMatch | null {
	const isoPattern =
		/([+-]\d{1,3}(?:\.\d+)?)([+-]\d{1,3}(?:\.\d+)?)(?:[+-]\d{1,3}(?:\.\d+)?\/?)?/g;

	let match: RegExpExecArray | null;
	// eslint-disable-next-line no-cond-assign
	while ((match = isoPattern.exec(text))) {
		const coords = parseIsoMatch(match);
		if (coords) {
			return { ...coords, source: 'iso-sequence' };
		}
	}
	return null;
}

function scanLatLonPairs(text: string): CoordinateMatch | null {
	const latPattern = /(latitude|gps_latitude)[^+\-0-9]*([+\-]?\d{1,3}(?:\.\d+)?)/i;
	const lonPattern = /(longitude|gps_longitude)[^+\-0-9]*([+\-]?\d{1,3}(?:\.\d+)?)/i;

	const latMatch = text.match(latPattern);
	const lonMatch = text.match(lonPattern);

	if (latMatch && lonMatch) {
		const lat = Number.parseFloat(latMatch[2]);
		const lon = Number.parseFloat(lonMatch[2]);
		if (isValidCoordinate(lat, lon)) {
			return { lat, lon, source: `${latMatch[1]}/${lonMatch[1]}` };
		}
	}

	return null;
}

function parseCoordinates(snippet: string): Omit<CoordinateMatch, 'source'> | null {
	const iso = parseIsoLike(snippet);
	if (iso) {
		return iso;
	}
	return null;
}

function parseIsoLike(value: string): Omit<CoordinateMatch, 'source'> | null {
	const isoMatch = value.match(/([+-]\d{1,3}(?:\.\d+)?)([+-]\d{1,3}(?:\.\d+)?)/);
	if (isoMatch) {
		const coords = parseIsoMatch(isoMatch);
		if (coords) return coords;
	}

	const delimited = value.match(/([+\-]?\d{1,3}(?:\.\d+)?)[,\s\/]+([+\-]?\d{1,3}(?:\.\d+)?)/);
	if (delimited) {
		const lat = Number.parseFloat(delimited[1]);
		const lon = Number.parseFloat(delimited[2]);
		if (isValidCoordinate(lat, lon)) {
			return { lat, lon };
		}
	}

	return null;
}

function parseIsoMatch(match: RegExpMatchArray): Omit<CoordinateMatch, 'source'> | null {
	if (match.length < 3) return null;
	const lat = Number.parseFloat(match[1]);
	const lon = Number.parseFloat(match[2]);
	if (!isValidCoordinate(lat, lon)) return null;
	return { lat, lon };
}

function isValidCoordinate(lat: number, lon: number): boolean {
	return (
		Number.isFinite(lat) &&
		Number.isFinite(lon) &&
		Math.abs(lat) <= 90 &&
		Math.abs(lon) <= 180
	);
}

export {};
</file>

<file path="src/lib/index.ts">
// place files you want to import through the `$lib` alias in this folder.
</file>

<file path="src/routes/live/+page.svelte">
<script lang="ts">
    import { onMount } from "svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";

    onMount(() => {
        // Ensure the player transitions into fullscreen layout
        selectedVideo.setFullScreen(true);
    });
</script>

<section class="live-wrapper">
    <div class="live-card">
        <span class="live-indicator">EN DIRECT</span>
        <h1>Flux en direct</h1>
        <p>
            La lecture principale occupe d√©sormais tout l'√©cran. S√©lectionnez un
            clip ou laissez la file s'encha√Æner automatiquement pour alimenter
            le direct.
        </p>
    </div>
</section>

<style>
    .live-wrapper {
        min-height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 4rem 1.5rem;
        background: black;
    }

    .live-card {
        max-width: 560px;
        display: grid;
        gap: 1.25rem;
        padding: 2.5rem;
        border-radius: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.65);
        box-shadow: 0 40px 120px -60px rgba(30, 64, 175, 0.6);
        text-align: center;
        color: #e2e8f0;
    }

    .live-indicator {
        justify-self: center;
        padding: 0.4rem 1rem;
        border-radius: 999px;
        background: linear-gradient(135deg, #ef4444, #f97316);
        color: #0f172a;
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.3em;
    }

    h1 {
        margin: 0;
        font-size: 2rem;
        font-weight: 600;
        letter-spacing: 0.1em;
        text-transform: uppercase;
    }

    p {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.6;
        color: rgba(226, 232, 240, 0.82);
    }

    @media (max-width: 640px) {
        .live-wrapper {
            padding: 2.5rem 1rem;
        }

        .live-card {
            padding: 2rem;
        }

        h1 {
            font-size: 1.6rem;
        }
    }
</style>
</file>

<file path="src/routes/map/+page.svelte">
<script lang="ts">
  import Map from '$lib/components/Map.svelte';
  import { page } from '$app/stores';
  import { videosStore } from '$lib/stores/library';
  import { selectedVideo } from '$lib/stores/selectedVideo';

  const videos = $derived($videosStore);

  const locations = $derived(
    videos.flatMap((video) =>
      video.locations?.map((loc) => ({
        ...loc,
        videoId: video.id,
        videoTitle: video.title,
        videoAuthor: video.author
      })) ?? []
    )
  );

  const lat = $derived(parseFloat($page.url.searchParams.get('lat') ?? '20'));
  const lon = $derived(parseFloat($page.url.searchParams.get('lon') ?? '0'));
  const zoom = $derived(parseInt($page.url.searchParams.get('zoom') ?? '2', 10));

  const filteredLocations = $derived(
    lat && lon
      ? locations.filter(
          (loc) =>
            Array.isArray(loc.coordinates) &&
            Math.abs(loc.coordinates[0] - lat) < 0.1 &&
            Math.abs(loc.coordinates[1] - lon) < 0.1
        )
      : locations
  );

  const activeVideoId = $derived($selectedVideo.id);

  // Toolbar UI state (visual only)
  let searchValue = $state('');
</script>


  <div class="relative w-full h-full w-full overflow-hidden">
 
      <Map
        locations={filteredLocations}
        initialCenterLon={lon}
        initialCenterLat={lat}
        initialZoom={zoom}
        activeVideoId={activeVideoId}
      />

      <aside class="map-toolbar" aria-label="Map tools">
        <div class="toolbar-row">
          <label class="sr-only" for="map-search">Search map</label>
          <div class="toolbar-item search">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="7" />
                <line x1="20" y1="20" x2="16.65" y2="16.65" />
              </svg>
            </span>
            <input
              id="map-search"
              class="toolbar-input"
              type="search"
              placeholder="Search map"
              bind:value={searchValue}
            />
          </div>

          <button type="button" class="toolbar-item" aria-label="Filters">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 6h16" />
                <path d="M7 12h10" />
                <path d="M10 18h4" />
              </svg>
            </span>
          </button>

          <button type="button" class="toolbar-item" aria-label="Timeline">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10" />
                <polyline points="12 6 12 12 16 14" />
              </svg>
            </span>
          </button>

          <button type="button" class="toolbar-item" aria-label="Keywords">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="m3 7 5 5-5 5" />
                <path d="m13 7 5 5-5 5" />
              </svg>
            </span>
          </button>
        </div>
      </aside>


    <!-- Mobile Menu Overlay Button -->
    <!-- <div class="pointer-events-none absolute top-4 left-4 md:hidden">
      <button
        class="pointer-events-auto rounded-lg bg-white/90 dark:bg-gray-800/90 p-2 shadow-lg border border-gray-200 dark:border-gray-700 backdrop-blur"
        aria-label="Open navigation menu"
        onclick={() => {
          const event = new CustomEvent('toggle-sidebar');
          window.dispatchEvent(event);
        }}
      >
        <svg class="h-5 w-5 text-gray-600 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
      </button>
    </div> -->

    <!-- Map Controls -->
    <!-- <div class="pointer-events-none absolute top-4 right-4 flex flex-col gap-2">
      <div class="pointer-events-auto rounded-lg bg-white/90 dark:bg-gray-900/90 p-3 shadow-lg border border-gray-200 dark:border-gray-700 backdrop-blur">
        <div class="text-sm font-medium text-gray-900 dark:text-white">
          {filteredLocations.length} locations
        </div>
        <div class="text-xs text-gray-500 dark:text-gray-400">
          {videos.length} videos archived
        </div>
      </div>

      <a
        href="/videos"
        class="pointer-events-auto rounded-lg bg-blue-600 px-3 py-2 text-sm font-medium text-white hover:bg-blue-500 transition-colors shadow-lg"
      >
        Browse Videos
      </a>
    </div> -->

</div>

<style>
  :global(body) {
    font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
  }

  .map-page {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .map-toolbar {
    position: absolute;
    top: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    width: min(960px, calc(100% - 3rem));
    padding: 0.85rem 1rem;
    border-radius: 18px;
    background: rgba(15, 18, 24, 0.78);
    backdrop-filter: blur(18px);
    border: 1px solid rgba(255, 255, 255, 0.14);
    box-shadow:
      0 24px 70px -35px rgba(15, 23, 42, 0.6),
      inset 0 0 0 0.5px rgba(255, 255, 255, 0.12);
    color: #e9eef6;
    z-index: 20;
    pointer-events: auto;
  }

  .toolbar-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .toolbar-item {
    display: inline-flex;
    align-items: center;
    gap: 0.55rem;
    padding: 0.5rem 0.7rem;
    border-radius: 12px;
    background: rgba(13, 17, 23, 0.45);
    border: 1px solid rgba(255, 255, 255, 0.08);
    min-height: 42px;
    color: inherit;
    transition: border-color 0.2s ease, background 0.2s ease;
  }

  .toolbar-item:hover,
  .toolbar-item:focus-visible {
    border-color: rgba(255, 255, 255, 0.22);
    background: rgba(15, 18, 24, 0.6);
    outline: none;
  }

  .toolbar-item.search {
    flex: 1 1 260px;
  }

  .toolbar-icon {
    display: inline-flex;
    width: 18px;
    height: 18px;
    opacity: 0.85;
  }

  .toolbar-icon svg {
    width: 100%;
    height: 100%;
    stroke: currentColor;
  }

  .toolbar-input {
    flex: 1;
    min-width: 0;
    border: none;
    background: transparent;
    color: inherit;
    font-size: 0.92rem;
  }

  .toolbar-input::placeholder {
    color: rgba(233, 238, 246, 0.55);
  }

  .toolbar-input:focus {
    outline: none;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  @media (max-width: 720px) {
    .map-toolbar {
      top: 1rem;
      width: calc(100% - 2rem);
      padding: 0.75rem;
    }

    .toolbar-item {
      flex: 1 1 100%;
    }
  }
</style>
</file>

<file path="src/routes/upload/+page.server.ts">
import { fail } from '@sveltejs/kit';
import type { Actions, PageServerLoad } from './$types';
import { db } from '$lib/server/db';
import { videos } from '$lib/server/db/schema';
import { getAllUsers } from '$lib/server/db/users';
import { nanoid } from 'nanoid';

export const load: PageServerLoad = async () => {
	// Get all users for the upload form (to select which user is uploading)
	const users = await getAllUsers();
	return {
		users
	};
};

export const actions: Actions = {
	upload: async ({ request }) => {
		const formData = await request.formData();

		const title = formData.get('title') as string;
		const description = formData.get('description') as string;
		const userId = formData.get('userId') as string;
		const uploadedAt = formData.get('uploadedAt') as string;
		const latitude = formData.get('latitude') as string;
		const longitude = formData.get('longitude') as string;
		const videoUrl = formData.get('videoUrl') as string;
		const thumbnailUrl = formData.get('thumbnailUrl') as string;
		const duration = formData.get('duration') as string;

		// Validation
		if (!title || title.trim().length === 0) {
			return fail(400, { error: 'Title is required', field: 'title' });
		}

		if (!description || description.trim().length === 0) {
			return fail(400, { error: 'Description is required', field: 'description' });
		}

		// Check word count (max 300 words)
		const wordCount = description.trim().split(/\s+/).length;
		if (wordCount > 300) {
			return fail(400, {
				error: `Description must be 300 words or less (currently ${wordCount} words)`,
				field: 'description'
			});
		}

		if (!userId) {
			return fail(400, { error: 'User selection is required', field: 'userId' });
		}

		if (!videoUrl || videoUrl.trim().length === 0) {
			return fail(400, { error: 'Video URL is required. Please upload a video file first.', field: 'video' });
		}

		try {
			// Generate unique video ID
			const videoId = nanoid(12);

			// Parse numeric values
			const userIdNum = parseInt(userId);
			const durationNum = duration ? parseInt(duration) : 0;
			const lat = latitude ? parseFloat(latitude) : null;
			const lon = longitude ? parseFloat(longitude) : null;

			// Validate userId is valid number
			if (isNaN(userIdNum)) {
				return fail(400, { error: 'Invalid user selection', field: 'userId' });
			}

			// Create video record
			await db.insert(videos).values({
				id: videoId,
				title: title.trim(),
				description: description.trim(),
				userId: userIdNum,
				videoUrl: videoUrl.trim(),
				thumbnailUrl: thumbnailUrl?.trim() || null,
				duration: durationNum,
				uploadedAt: uploadedAt ? new Date(uploadedAt) : new Date(),
				latitude: lat,
				longitude: lon,
				views: 0,
				likes: 0,
				transcript: null
			});

			return {
				success: true,
				videoId
			};
		} catch (error) {
			console.error('Upload error:', error);
			return fail(500, {
				error: 'Failed to save video. Please try again.',
				details: error instanceof Error ? error.message : 'Unknown error'
			});
		}
	}
};
</file>

<file path="src/routes/upload/+page.svelte">
<script lang="ts">
    import { browser } from "$app/environment";
    import { enhance } from "$app/forms";
    import type { PageData, ActionData } from "./$types";
    import LocationPicker from "$lib/components/LocationPicker.svelte";
    import { goto } from "$app/navigation";

    interface Props {
        data: PageData;
        form: ActionData;
    }

    const { data, form }: Props = $props();

    // Form state
    let videoFile = $state<File | null>(null);
    let title = $state("");
    let description = $state("");
    let selectedUserId = $state<number>(
        data.users[0]?.id ? parseInt(data.users[0].id) : 1,
    );
    let uploadDate = $state("");
    let latitude = $state<number | undefined>(undefined);
    let longitude = $state<number | undefined>(undefined);
    let selectedThumbnail = $state<string>("");
    let videoUrl = $state(""); // This would be set after uploading to storage
    let duration = $state(0);

    // UI state
    let isProcessing = $state(false);
    let processingStatus = $state("");
    let thumbnails = $state<string[]>([]);
    let videoPreviewUrl = $state<string>("");
    let wordCount = $state(0);
    let isSubmitting = $state(false);
    let locationStatus = $state<"detecting" | "found" | "not-found" | null>(
        null,
    );

    // Worker for video processing
    let worker: Worker | null = null;

    $effect(() => {
        if (browser) {
            // Initialize worker
            worker = new Worker(
                new URL(
                    "$lib/workers/videoMetadata.worker.ts",
                    import.meta.url,
                ),
                { type: "module" },
            );

            worker.onmessage = (e) => {
                const { type, metadata, error } = e.data;

                if (type === "metadata-result") {
                    // Update form with extracted metadata
                    if (metadata.date) {
                        try {
                            const date = new Date(metadata.date);
                            uploadDate = date.toISOString().split("T")[0];
                        } catch {
                            uploadDate = new Date().toISOString().split("T")[0];
                        }
                    } else {
                        uploadDate = new Date().toISOString().split("T")[0];
                    }

                    if (metadata.latitude && metadata.longitude) {
                        latitude = metadata.latitude;
                        longitude = metadata.longitude;
                        locationStatus = "found";
                    } else {
                        locationStatus = "not-found";
                    }
                } else if (type === "error") {
                    console.error("Worker error:", error);
                    isProcessing = false;
                    processingStatus = "Error processing video";
                    locationStatus = "not-found";
                }
            };

            return () => {
                worker?.terminate();
            };
        }
    });

    async function extractVideoDurationAndThumbnails(file: File) {
        try {
            const videoUrl = URL.createObjectURL(file);
            const video = document.createElement("video");
            video.preload = "metadata";
            video.muted = true;
            video.playsInline = true;
            video.src = videoUrl;

            await new Promise<void>((resolve, reject) => {
                video.onloadedmetadata = () => resolve();
                video.onerror = () => reject(new Error("Failed to load video"));
            });

            duration = Math.round(video.duration);

            // Generate thumbnails
            processingStatus = "Generating thumbnails...";
            const videoDuration = video.duration;
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            if (ctx) {
                const aspectRatio = video.videoHeight / video.videoWidth;
                canvas.width = 320;
                canvas.height = Math.round(320 * aspectRatio);

                const thumbCount = 5;
                const generatedThumbs: string[] = [];

                for (let i = 0; i < thumbCount; i++) {
                    const timestamp =
                        (videoDuration / (thumbCount + 1)) * (i + 1);
                    video.currentTime = timestamp;

                    await new Promise<void>((resolve) => {
                        video.onseeked = () => resolve();
                    });

                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
                    generatedThumbs.push(dataUrl);
                }

                thumbnails = generatedThumbs;
                if (thumbnails.length > 0) {
                    selectedThumbnail = thumbnails[0];
                }
            }

            URL.revokeObjectURL(videoUrl);
            isProcessing = false;
            processingStatus = "";
        } catch (error) {
            console.error("Error extracting video data:", error);
            isProcessing = false;
            processingStatus = "Error processing video";
        }
    }

    async function handleFileSelect(event: Event) {
        const input = event.target as HTMLInputElement;
        const file = input.files?.[0];

        if (file) {
            videoFile = file;
            videoPreviewUrl = URL.createObjectURL(file);

            // Extract metadata from video
            isProcessing = true;
            processingStatus = "Analyzing video...";
            locationStatus = "detecting";

            // Send buffer to worker for location extraction
            const buffer = await file.arrayBuffer();
            worker?.postMessage({
                type: "extract-metadata",
                buffer,
                lastModified: file.lastModified,
            });

            // Extract duration and thumbnails in main thread
            await extractVideoDurationAndThumbnails(file);

            // Set default title from filename
            if (!title) {
                title = file.name
                    .replace(/\.[^/.]+$/, "")
                    .replace(/[_-]/g, " ");
            }

            // Simulate video upload to get URL (in production, you'd upload to cloud storage)
            // For now, we'll use the blob URL as placeholder
            videoUrl = videoPreviewUrl;
        }
    }

    function handleLocationChange(lat: number, lon: number) {
        latitude = lat;
        longitude = lon;
    }

    function selectThumbnail(thumb: string) {
        selectedThumbnail = thumb;
    }

    function updateWordCount() {
        const words = description.trim().split(/\s+/).filter(Boolean);
        wordCount = words.length;
    }

    $effect(() => {
        updateWordCount();
    });

    function handleSubmit() {
        isSubmitting = true;
        return async ({ result, update }: any) => {
            isSubmitting = false;

            if (result.type === "success" && result.data?.success) {
                // Redirect to the video page or library
                goto(`/videos/${result.data.videoId}`).catch(() => {
                    goto("/videos");
                });
            } else {
                await update();
            }
        };
    }
</script>

<svelte:head>
    <title>Upload Video</title>
</svelte:head>

<div class="page">
    <form
        method="POST"
        action="?/upload"
        class="card"
        use:enhance={handleSubmit}
    >
        <header>
            <h1>Upload Video</h1>
            <p>Share your video with the world. Fill in the details below.</p>
        </header>

        {#if form?.error}
            <div class="error-banner">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                    <path
                        d="M10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 14.4183 5.58172 18 10 18Z"
                        stroke="currentColor"
                        stroke-width="2"
                    />
                    <path
                        d="M10 6V10"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                    />
                    <circle cx="10" cy="13" r="1" fill="currentColor" />
                </svg>
                <span>{form.error}</span>
            </div>
        {/if}

        <!-- Video File Picker -->
        <div class="form-group">
            <label for="video-file" class="label">Video File *</label>
            <div class="file-input-wrapper">
                <label class="file-picker" class:has-file={videoFile}>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path
                            d="M21 15V19C21 19.5304 20.7893 20.0391 20.4142 20.4142C20.0391 20.7893 19.5304 21 19 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V15"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        />
                        <path
                            d="M17 8L12 3L7 8"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        />
                        <path
                            d="M12 3V15"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        />
                    </svg>
                    <span
                        >{videoFile
                            ? videoFile.name
                            : "Choose a video file"}</span
                    >
                    <input
                        id="video-file"
                        type="file"
                        accept="video/*"
                        onchange={handleFileSelect}
                        required
                    />
                </label>
                {#if videoFile}
                    <div class="file-info">
                        <span class="file-size"
                            >{(videoFile.size / 1024 / 1024).toFixed(2)} MB</span
                        >
                        {#if duration > 0}
                            <span class="file-duration"
                                >{Math.floor(duration / 60)}:{(duration % 60)
                                    .toString()
                                    .padStart(2, "0")}</span
                            >
                        {/if}
                    </div>
                {/if}
            </div>
            {#if isProcessing}
                <div class="processing-status">
                    <div class="spinner"></div>
                    <span>{processingStatus}</span>
                </div>
            {/if}
        </div>

        <!-- Video Preview -->
        {#if videoPreviewUrl && !isProcessing}
            <div class="form-group">
                <label class="label">Preview</label>
                <video class="video-preview" src={videoPreviewUrl} controls
                ></video>
            </div>
        {/if}

        <!-- Title -->
        <div class="form-group">
            <label for="title" class="label">Title *</label>
            <input
                id="title"
                name="title"
                type="text"
                class="input"
                bind:value={title}
                placeholder="Enter video title"
                required
                maxlength="200"
            />
        </div>

        <!-- User Selection -->
        <div class="form-group">
            <label for="userId" class="label">Uploading as *</label>
            <select
                id="userId"
                name="userId"
                class="input"
                bind:value={selectedUserId}
                required
            >
                {#each data.users as user}
                    <option value={parseInt(user.id)}>{user.name}</option>
                {/each}
            </select>
        </div>

        <!-- Upload Date -->
        <div class="form-group">
            <label for="uploadDate" class="label">Upload Date</label>
            <input
                id="uploadDate"
                name="uploadedAt"
                type="date"
                class="input"
                bind:value={uploadDate}
            />
            <p class="hint">
                Automatically detected from video metadata when available
            </p>
        </div>

        <!-- Location Status -->
        {#if locationStatus}
            <div class="form-group">
                {#if locationStatus === "detecting"}
                    <div class="location-status detecting">
                        <div class="spinner-small"></div>
                        <span>Detecting location from video metadata...</span>
                    </div>
                {:else if locationStatus === "found"}
                    <div class="location-status found">
                        <svg
                            width="20"
                            height="20"
                            viewBox="0 0 20 20"
                            fill="none"
                        >
                            <path
                                d="M10 2C7.24 2 5 4.24 5 7c0 3.75 5 11 5 11s5-7.25 5-11c0-2.76-2.24-5-5-5zm0 7c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"
                                fill="currentColor"
                            />
                        </svg>
                        <span
                            >Location found: {latitude?.toFixed(6)}, {longitude?.toFixed(
                                6,
                            )}</span
                        >
                    </div>
                {:else if locationStatus === "not-found"}
                    <div class="location-status not-found">
                        <svg
                            width="20"
                            height="20"
                            viewBox="0 0 20 20"
                            fill="none"
                        >
                            <circle
                                cx="10"
                                cy="10"
                                r="8"
                                stroke="currentColor"
                                stroke-width="2"
                            />
                            <path
                                d="M10 6v4M10 14h.01"
                                stroke="currentColor"
                                stroke-width="2"
                                stroke-linecap="round"
                            />
                        </svg>
                        <span
                            >No location found in video metadata. You can set it
                            manually below.</span
                        >
                    </div>
                {/if}
            </div>
        {/if}

        <!-- Description -->
        <div class="form-group">
            <label for="description" class="label">
                Description *
                <span class="word-counter" class:over-limit={wordCount > 300}>
                    {wordCount} / 300 words
                </span>
            </label>
            <textarea
                id="description"
                name="description"
                class="textarea"
                bind:value={description}
                placeholder="Describe your video... (max 300 words)"
                required
                rows="6"
            ></textarea>
        </div>

        <!-- Thumbnail Picker -->
        {#if thumbnails.length > 0}
            <div class="form-group">
                <label class="label">Select Thumbnail</label>
                <div class="thumbnail-grid">
                    {#each thumbnails as thumb, i}
                        <button
                            type="button"
                            class="thumbnail-option"
                            class:selected={selectedThumbnail === thumb}
                            onclick={() => selectThumbnail(thumb)}
                        >
                            <img src={thumb} alt="Thumbnail {i + 1}" />
                            {#if selectedThumbnail === thumb}
                                <div class="selected-indicator">
                                    <svg
                                        width="24"
                                        height="24"
                                        viewBox="0 0 24 24"
                                        fill="none"
                                    >
                                        <circle
                                            cx="12"
                                            cy="12"
                                            r="10"
                                            fill="currentColor"
                                        />
                                        <path
                                            d="M8 12L11 15L16 9"
                                            stroke="white"
                                            stroke-width="2"
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                        />
                                    </svg>
                                </div>
                            {/if}
                        </button>
                    {/each}
                </div>
            </div>
        {/if}

        <!-- Location Picker -->
        <div class="form-group">
            <label class="label">
                Location
                {#if latitude && longitude}
                    <span class="location-detected">üìç Location set</span>
                {/if}
            </label>
            <p class="hint">
                Click on the map to set the video location. Use the geolocation
                button to use your current location.
            </p>
            <LocationPicker
                {latitude}
                {longitude}
                onLocationChange={handleLocationChange}
            />
        </div>

        <!-- Hidden fields for submission -->
        <input type="hidden" name="latitude" value={latitude ?? ""} />
        <input type="hidden" name="longitude" value={longitude ?? ""} />
        <input type="hidden" name="videoUrl" value={videoUrl} />
        <input type="hidden" name="thumbnailUrl" value={selectedThumbnail} />
        <input type="hidden" name="duration" value={duration} />

        <!-- Submit Button -->
        <div class="form-actions">
            <button
                type="submit"
                class="submit-btn"
                disabled={isProcessing || isSubmitting || !videoFile}
            >
                {#if isSubmitting}
                    <div class="spinner"></div>
                    <span>Uploading...</span>
                {:else if isProcessing}
                    <span>Processing video...</span>
                {:else}
                    <span>Upload Video</span>
                {/if}
            </button>
        </div>
    </form>
</div>

<style>
    .page {
        height: 100vh;
        padding: 4rem 1.5rem;
        background:
            radial-gradient(
                circle at top,
                rgba(8, 47, 73, 0.4),
                transparent 55%
            ),
            rgba(2, 6, 23, 0.94);
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }

    .card {
        width: min(800px, 100%);
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 20px;
        padding: 2.5rem;
        box-shadow: 0 40px 120px -60px rgba(15, 118, 226, 0.45);
        display: grid;
        gap: 2rem;
        color: #e2e8f0;
        margin-bottom: 4rem;
    }

    header h1 {
        font-size: 1.8rem;
        margin: 0;
        color: #f8fafc;
    }

    header p {
        margin: 0.6rem 0 0;
        color: rgba(226, 232, 240, 0.8);
        font-size: 0.95rem;
        line-height: 1.4;
    }

    .error-banner {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem 1.25rem;
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 12px;
        color: #fca5a5;
        font-size: 0.9rem;
    }

    .error-banner svg {
        flex-shrink: 0;
    }

    .form-group {
        display: grid;
        gap: 0.75rem;
    }

    .label {
        font-size: 0.9rem;
        font-weight: 500;
        color: #f8fafc;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .hint {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.6);
        margin: -0.25rem 0 0;
    }

    .file-input-wrapper {
        display: grid;
        gap: 0.75rem;
    }

    .file-picker {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 1.5rem 1.75rem;
        border-radius: 12px;
        border: 2px dashed rgba(94, 234, 212, 0.3);
        background: rgba(94, 234, 212, 0.05);
        color: #5eead4;
        font-size: 0.95rem;
        font-weight: 500;
        cursor: pointer;
        transition:
            border-color 0.2s ease,
            background 0.2s ease,
            transform 0.2s ease;
        width: 100%;
    }

    .file-picker:hover {
        border-color: rgba(94, 234, 212, 0.5);
        background: rgba(94, 234, 212, 0.1);
        transform: translateY(-1px);
    }

    .file-picker.has-file {
        border-color: rgba(94, 234, 212, 0.5);
        background: rgba(94, 234, 212, 0.12);
    }

    .file-picker input {
        display: none;
    }

    .file-info {
        display: flex;
        gap: 1rem;
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.7);
    }

    .file-size,
    .file-duration {
        padding: 0.25rem 0.75rem;
        background: rgba(30, 41, 59, 0.6);
        border-radius: 6px;
        font-variant-numeric: tabular-nums;
    }

    .processing-status {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 8px;
        color: #93c5fd;
        font-size: 0.875rem;
    }

    .spinner {
        width: 1rem;
        height: 1rem;
        border: 2px solid rgba(94, 234, 212, 0.3);
        border-top-color: #5eead4;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }

    .spinner-small {
        width: 0.875rem;
        height: 0.875rem;
        border: 2px solid rgba(94, 234, 212, 0.3);
        border-top-color: #5eead4;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        flex-shrink: 0;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .location-status {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border-radius: 8px;
        font-size: 0.875rem;
    }

    .location-status.detecting {
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid rgba(59, 130, 246, 0.3);
        color: #93c5fd;
    }

    .location-status.found {
        background: rgba(94, 234, 212, 0.1);
        border: 1px solid rgba(94, 234, 212, 0.3);
        color: #5eead4;
    }

    .location-status.not-found {
        background: rgba(251, 191, 36, 0.1);
        border: 1px solid rgba(251, 191, 36, 0.3);
        color: #fbbf24;
    }

    .location-status svg {
        flex-shrink: 0;
    }

    .video-preview {
        width: 100%;
        max-height: 400px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.5);
    }

    .input,
    .textarea {
        width: 100%;
        padding: 0.75rem 1rem;
        background: rgba(30, 41, 59, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 8px;
        color: #f8fafc;
        font-size: 0.95rem;
        font-family: inherit;
        transition:
            border-color 0.2s ease,
            background 0.2s ease;
    }

    .input:focus,
    .textarea:focus {
        outline: none;
        border-color: rgba(94, 234, 212, 0.5);
        background: rgba(30, 41, 59, 0.8);
    }

    .textarea {
        resize: vertical;
        min-height: 120px;
        line-height: 1.5;
    }

    select.input {
        cursor: pointer;
    }

    .word-counter {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.6);
        font-weight: 400;
    }

    .word-counter.over-limit {
        color: #fca5a5;
    }

    .thumbnail-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 1rem;
    }

    .thumbnail-option {
        position: relative;
        aspect-ratio: 16 / 9;
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid rgba(148, 163, 184, 0.2);
        background: rgba(30, 41, 59, 0.6);
        cursor: pointer;
        transition:
            border-color 0.2s ease,
            transform 0.2s ease;
        padding: 0;
    }

    .thumbnail-option:hover {
        border-color: rgba(94, 234, 212, 0.5);
        transform: scale(1.05);
    }

    .thumbnail-option.selected {
        border-color: #5eead4;
    }

    .thumbnail-option img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .selected-indicator {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        color: #5eead4;
        background: rgba(15, 23, 42, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .location-detected {
        font-size: 0.85rem;
        color: #5eead4;
        font-weight: 400;
    }

    .form-actions {
        display: flex;
        justify-content: flex-end;
        padding-top: 1rem;
        border-top: 1px solid rgba(148, 163, 184, 0.2);
    }

    .submit-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 0.875rem 2rem;
        background: linear-gradient(135deg, #5eead4, #3b82f6);
        border: none;
        border-radius: 9999px;
        color: #0f172a;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition:
            transform 0.2s ease,
            box-shadow 0.2s ease;
        min-width: 200px;
    }

    .submit-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px -10px rgba(94, 234, 212, 0.5);
    }

    .submit-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    @media (max-width: 640px) {
        .page {
            padding: 2rem 1rem;
        }

        .card {
            padding: 1.5rem;
            gap: 1.5rem;
        }

        header h1 {
            font-size: 1.5rem;
        }

        .thumbnail-grid {
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.75rem;
        }

        .form-actions {
            justify-content: stretch;
        }

        .submit-btn {
            width: 100%;
        }
    }
</style>
</file>

<file path="src/routes/users/[id]/+page.svelte">
<script lang="ts">
  import { getUserById as lookupUser } from '$lib/stores/library';
  import { page } from '$app/stores';

  let { data } = $props();

  // Get user data from the centralized database
  const userId = $page.params.id;
  const user = lookupUser(userId) || {
    id: userId,
    name: "Unknown User",
    avatar: "https://i.pravatar.cc/150?img=4",
    bio: "User not found",
    stats: {
      videos: 0,
      followers: 0,
      following: 0
    },
    videos: [],
    recentVideos: []
  };
</script>

<div class=" ">
  <!-- Profile Header -->
  <div class="flex items-start gap-6 mb-8">
    <img 
      src={user.avatar} 
      alt={user.name} 
      class="w-24 h-24 rounded-full"
    />
    <div class="flex-1">
      <h1 class="text-2xl font-medium dark:text-neutral-200 mb-2">{user.name}</h1>
      <p class="text-sm text-neutral-600 dark:text-neutral-400 mb-4">{user.bio}</p>
      <div class="flex gap-6">
        <div>
          <span class="font-medium dark:text-neutral-200">{user.stats.videos}</span>
          <span class="text-sm text-neutral-600 dark:text-neutral-400 ml-1">videos</span>
        </div>
        <div>
          <span class="font-medium dark:text-neutral-200">{user.stats.followers}</span>
          <span class="text-sm text-neutral-600 dark:text-neutral-400 ml-1">followers</span>
        </div>
        <div>
          <span class="font-medium dark:text-neutral-200">{user.stats.following}</span>
          <span class="text-sm text-neutral-600 dark:text-neutral-400 ml-1">following</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Recent Videos -->
  <h2 class="text-lg font-medium dark:text-neutral-200 mb-4">Recent Videos</h2>
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    {#each user.recentVideos || [] as video}
      <a href="/videos/{video.id}" class="group">
        <div class="relative aspect-video rounded-lg overflow-hidden bg-white/10">
          <img
            src={video.thumbnail}
            alt={video.title}
            class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-200"
          />
          <div class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent">
            <p class="text-sm text-white">{video.title}</p>
            <p class="text-xs text-neutral-400">{video.duration}</p>
          </div>
        </div>
      </a>
    {/each}
  </div>
</div>
</file>

<file path="src/routes/users/+page.svelte">
<script lang="ts">
    import { browser } from "$app/environment";
    import { goto } from "$app/navigation";
    import { usersStore } from "$lib/stores/library";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { onMount } from "svelte";

    const users = $derived($usersStore);
    let container = $state<HTMLElement | null>(null);
    let gsapModule: any = null;

    onMount(() => {
        selectedVideo.selectVideo("home");
    });

    async function ensureGsap() {
        if (!browser) return null;
        if (!gsapModule) {
            const { default: gsap } = await import("gsap");
            gsapModule = gsap;
        }
        return gsapModule;
    }

    $effect(() => {
        const host = container;
        if (!host) return;
        ensureGsap().then((gsap) => {
            if (!gsap) return;
            gsap.fromTo(
                host.querySelectorAll("[data-user-card]"),
                { opacity: 0, y: 18 },
                {
                    opacity: 1,
                    y: 0,
                    duration: 0.5,
                    stagger: 0.05,
                    ease: "power2.out",
                },
            );
        });
    });

    function openProfile(id: string) {
        goto(`/users/${id}`);
    }
</script>

<svelte:head>
    <title>Creators ‚Äî Rushes Directory</title>
    <meta
        name="description"
        content="Browse the Rushes collective, discover filmmakers and dive into their rushes."
    />
</svelte:head>

<div class="mx-auto w-full max-w-[1200px] pb-24">
    <header class="flex flex-col gap-2 pb-8">
        <p class="text-xs uppercase tracking-[0.45em] text-slate-500">
            Directory
        </p>
        <h1
            class="text-3xl font-semibold text-white"
            style="font-family: 'Space Grotesk', 'Inter', sans-serif;"
        >
            Rushes collective
        </h1>
        <p class="max-w-xl text-sm text-slate-400">
            Meet the filmmakers weaving the Rushes archive. Select a profile to
            view their rushes, locations and shared notes.
        </p>
    </header>

    <div class="grid gap-6 md:grid-cols-2" bind:this={container}>
        {#each users as user (user.id)}
            <button
                class="group flex flex-col gap-4 rounded-4xl border border-white/10 bg-white/[0.04] p-6 text-left shadow-[0_45px_140px_-80px_rgba(12,18,38,0.92)] backdrop-blur-3xl transition-transform duration-300 hover:-translate-y-1 hover:shadow-[0_55px_160px_-90px_rgba(99,102,241,0.65)]"
                onclick={() => openProfile(user.id)}
                data-user-card
            >
                <div class="flex items-center gap-4">
                    <img
                        src={user.avatar}
                        alt={user.name}
                        class="h-16 w-16 rounded-3xl border border-white/10 object-cover"
                    />
                    <div>
                        <h2
                            class="text-xl font-semibold text-white"
                            style="font-family: 'Space Grotesk', 'Inter', sans-serif;"
                        >
                            {user.name}
                        </h2>
                        <p
                            class="mt-1 text-xs uppercase tracking-[0.35em] text-slate-500"
                        >
                            {user.stats.videos} rushes
                        </p>
                    </div>
                </div>
                <p class="text-sm text-slate-300">{user.bio}</p>
                <div
                    class="grid grid-cols-3 gap-3 rounded-3xl border border-white/10 bg-white/[0.03] p-4 text-center text-xs uppercase tracking-[0.3em] text-slate-400"
                >
                    <div>
                        <p class="text-[11px] text-slate-500">Followers</p>
                        <p class="mt-1 text-base text-white">
                            {user.stats.followers}
                        </p>
                    </div>
                    <div>
                        <p class="text-[11px] text-slate-500">Following</p>
                        <p class="mt-1 text-base text-white">
                            {user.stats.following}
                        </p>
                    </div>
                    <div>
                        <p class="text-[11px] text-slate-500">Videos</p>
                        <p class="mt-1 text-base text-white">
                            {user.stats.videos}
                        </p>
                    </div>
                </div>
            </button>
        {/each}
    </div>
</div>

<style>
    .rounded-4xl {
        border-radius: 2rem;
    }
</style>
</file>

<file path="src/routes/videos/[id]/+page.svelte">
<script lang="ts">
  import { page } from '$app/stores';
  import { selectedVideo } from '$lib/stores/selectedVideo';
  import { onMount } from 'svelte';

  onMount(() => {
    // Set the video based on the URL
    const videoId = $page.params.id;
    if (videoId) {
      // First select the video
      selectedVideo.selectVideo(videoId);
      // Then ensure it's in full screen mode
      if (!$selectedVideo.isFullScreen) {
        selectedVideo.toggleFullScreen();
      }
    }
  });
</script>

<div class=" bg-neutral-950">
  <!-- Video info will be shown in the Playing component -->
</div>
</file>

<file path="src/routes/videos/+page.svelte">
<script lang="ts">
	import { goto } from "$app/navigation";
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { slide } from "svelte/transition";
	import {
		dndzone,
		type DndEvent,
		SHADOW_ITEM_MARKER_PROPERTY_NAME,
	} from "svelte-dnd-action";
	import DashboardPanel from "$lib/components/dashboard/DashboardPanel.svelte";
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		SortDirection,
		TableColumn,
		TableKey,
		TableState,
	} from "$lib/types/dashboard";
import { videosStore, usersStore } from "$lib/stores/library";

	const boardDndType = "dashboard-panels";
	const boardDropTargetClasses = ["dashboard-drop-target"];
	const boardFlipDurationMs = 200;

	const videos = $derived($videosStore);
	const users = $derived($usersStore);

	// State for draggable items in each column
	let itemsLeft = $state<DashboardItem[]>([{ id: 1, component: "videos" }, { id: 2, component: "sounds" }]);

	let itemsRight = $state<DashboardItem[]>([
		{ id: 5, component: "profile" },
		{ id: 6, component: "activity" },
		{ id: 7, component: "locations" },
		{ id: 3, component: "members" },
		{ id: 4, component: "keywords" },
	]);

	const sectionLabels: Record<DashboardComponentKey, string> = {
		videos: "Queue overview",
		profile: "Profile summary",
		activity: "Live activity",
		sounds: "Sounds",
		members: "Members",
		keywords: "Keywords",
		locations: "Latest locations",
	};

	function getSectionLabel(item: DashboardItem) {
		return sectionLabels[item.component] ?? "Dashboard section";
	}

	function updateLeftColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsLeft = event.detail.items as DashboardItem[];
	}

	function updateRightColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsRight = event.detail.items as DashboardItem[];
	}

	const liveActivity = $state([
		{
			id: "act-1",
			user: "In√®s Duarte",
			action: "liked",
			content: "Canal Footbridge Atmos",
			type: "like",
			time: "2m ago",
		},
		{
			id: "act-2",
			user: "Luca Van Eyck",
			action: "commented on",
			content: "Metro Brakes ‚Äì Line 6",
			type: "comment",
			time: "5m ago",
		},
		{
			id: "act-3",
			user: "Aya Kakei",
			action: "liked",
			content: "Night Rain On Skylight",
			type: "like",
			time: "1h ago",
		},
		{
			id: "act-4",
			user: "Tom Schurr",
			action: "commented on",
			content: "Textile Rustle Layers",
			type: "comment",
			time: "3h ago",
		},
	]);

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	let collapsed = $state({
		videos: false,
		sounds: false,
		members: false,
		keywords: false,
		activity: false,
		locations: false,
	});

	function toggleCollapse(component: DashboardComponentKey) {
		collapsed[component] = !collapsed[component];
	}

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "In√®s Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des P√©niches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes ‚Äì Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo ‚Äî ‚ÄúGolden Hour‚Äù",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let tableState = $state({
		videos: {
			key: "videos",
			label: "Queue",
			sortKey: "uploaded",
			sortDirection: "desc",
			defaultSort: { key: "uploaded", direction: "desc" },
			columns: [],
		},
		sounds: {
			key: "sounds",
			label: "Sounds",
			sortKey: "captured",
			sortDirection: "desc",
			defaultSort: { key: "captured", direction: "desc" },
			columns: [
				{ key: "title", label: "CLIP" },
				{ key: "recordist", label: "CAPTURED_BY" },
				{ key: "captured", label: "CAPTURED", align: "right" },
				{ key: "duration", label: "DURATION", align: "right" },
			],
		},
		members: {
			key: "members",
			label: "MEMBERS",
			sortKey: "name",
			sortDirection: "asc",
			defaultSort: { key: "name", direction: "asc" },
			columns: [
				{ key: "name", label: "NAME" },
				{ key: "videos", label: "VIDEOS", align: "right" },
				{ key: "followers", label: "FOLLOWERS", align: "right" },
				{ key: "following", label: "FOLLOWING", align: "right" },
				{ key: "joined", label: "JOINED", align: "right" },
			],
		},
		keywords: {
			key: "keywords",
			label: "KEYWORDS",
			sortKey: "keyword",
			sortDirection: "asc",
			defaultSort: { key: "keyword", direction: "asc" },
			columns: [
				{ key: "keyword", label: "TERM" },
				{ key: "usage", label: "USAGE", align: "right" },
				{ key: "related", label: "RELATED_PROJECTS" },
			],
		},
	});

	function formatDate(iso?: string) {
		if (!iso) return "‚Äî";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		return date.toISOString().split("T")[0];
	}

	function parseDuration(value?: string) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [h, m, s] = parts;
			return h * 3600 + m * 60 + s;
		}
		if (parts.length === 2) {
			const [m, s] = parts;
			return m * 60 + s;
		}
		return parts[0];
	}

	function formatViews(views?: number) {
		if (typeof views !== "number" || Number.isNaN(views)) return "‚Äî";
		if (views >= 1_000_000) return `${(views / 1_000_000).toFixed(1)}M`;
		if (views >= 1_000) return `${(views / 1_000).toFixed(1)}K`;
		return `${views}`;
	}

	function formatStat(num: number) {
		if (num >= 1000) return `${(num / 1000).toFixed(1)}k`;
		return num.toString();
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return 0;
	}

	function getLocationCoordinates(
		location: any,
	): { lat: number; lon: number } | null {
		if (
			typeof location?.mapLat === "number" &&
			typeof location?.mapLon === "number"
		) {
			return { lat: location.mapLat, lon: location.mapLon };
		}
		if (
			typeof location?.latitude === "number" &&
			typeof location?.longitude === "number"
		) {
			return { lat: location.latitude, lon: location.longitude };
		}
		if (
			Array.isArray(location?.coordinates) &&
			location.coordinates.length === 2
		) {
			const [lat, lon] = location.coordinates;
			if (typeof lat === "number" && typeof lon === "number") {
				return { lat, lon };
			}
		}
		return null;
	}

	function getKeywordsSummary() {
		const keywordMap = new Map<
			string,
			{ usage: number; related: Set<string> }
		>();
		for (const video of videos) {
			for (const key of video.keywords ?? []) {
				const entry = keywordMap.get(key) ?? {
					usage: 0,
					related: new Set<string>(),
				};
				entry.usage += 1;
				entry.related.add(video.title);
				keywordMap.set(key, entry);
			}
		}
		return Array.from(keywordMap.entries()).map(([keyword, info]) => ({
			keyword,
			usage: info.usage,
			related: Array.from(info.related).join(", "),
		}));
	}

	const tableData = $derived({
		videos: videos.map((video) => {
			const iso = video.timestamp ?? video.uploadDate ?? null;
			const uploadedLabel = iso
				? formatDate(iso)
				: (video.uploadedAt ?? "‚Äî");
			return {
				id: video.id,
				title: video.title,
				author: video.author,
				duration: video.duration ?? "0:00",
				durationValue: video.duration,
				uploaded: uploadedLabel,
				uploadedValue: iso ? Date.parse(iso) : Number.NEGATIVE_INFINITY,
				views: formatViews(video.views),
				viewsValue:
					typeof video.views === "number" ? video.views : null,
				original: video,
			};
		}),
		sounds: soundLibrary.map((clip) => ({
			id: clip.id,
			title: clip.title,
			location: clip.location,
			recordist: clip.recordist,
			project: clip.relatedProject,
			captured: formatDate(clip.capturedOn),
			capturedValue: Date.parse(clip.capturedOn),
			duration: clip.duration,
			durationValue: clip.duration,
		})),
		members: users.map((user) => ({
			id: user.id,
			name: user.name,
			videos: user.stats?.videos ?? 0,
			followers: user.stats?.followers ?? 0,
			following: user.stats?.following ?? 0,
			joined: user.joinedAt ? formatDate(user.joinedAt) : "‚Äî",
			joinedValue: user.joinedAt
				? Date.parse(user.joinedAt)
				: Number.NEGATIVE_INFINITY,
		})),
		keywords: getKeywordsSummary(),
	});

	const totalRuntimeSeconds = $derived(
		tableData.videos.reduce(
			(total, video) =>
				total +
				(typeof video.durationValue === "number"
					? video.durationValue
					: 0),
			0,
		),
	);
	const uniqueContributors = $derived(
		new Set(
			tableData.videos
				.map((video) => video.author)
				.filter((author) => Boolean(author)),
		).size,
	);
	const lastUploadedTimestamp = $derived(
		tableData.videos.reduce((latest, video) => {
			if (Number.isFinite(video.uploadedValue)) {
				return Math.max(latest, video.uploadedValue);
			}
			return latest;
		}, Number.NEGATIVE_INFINITY),
	);

	const lastUpdated = $derived(
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "‚Äî",
	);
	const averageDurationLabel = $derived(() => {
		if (tableData.videos.length === 0) return "0m";
		const averageSeconds = Math.round(
			totalRuntimeSeconds / tableData.videos.length,
		);
		return formatRuntime(averageSeconds);
	});

	const latestLocations = $derived<LatestLocationPin[]>(() => {
		const pins: LatestLocationPin[] = [];
		for (const video of videos) {
			const locations = video.locations ?? [];
			if (!Array.isArray(locations) || locations.length === 0) continue;
			const timestampValue = getVideoTimestampValue(video);
			const isoCandidate =
				typeof (video.timestamp ?? video.uploadDate) === "string"
					? (video.timestamp ?? video.uploadDate)
					: null;
			const uploadedLabel =
				isoCandidate && !Number.isNaN(Date.parse(isoCandidate))
					? formatDate(isoCandidate)
					: typeof video.uploadedAt === "string"
						? video.uploadedAt
						: "‚Äî";
			locations.forEach((location, index) => {
				const coords = getLocationCoordinates(location);
				if (!coords) return;
				pins.push({
					id: `${video.id}-${index}`,
					videoId: video.id,
					videoTitle: video.title,
					videoAuthor: video.author,
					uploadedLabel,
					timestampValue,
					lat: coords.lat,
					lon: coords.lon,
					setting: location.setting ?? location.name,
					thumbnailUrl: video.thumbnailUrl,
				});
			});
		}
		return pins
			.sort((a, b) => b.timestampValue - a.timestampValue)
			.slice(0, 6);
	});

	const locationCenter = $derived<LocationCenter>(() => {
		if (latestLocations.length === 0) {
			return { lat: 20, lon: 0, zoom: 1.6 };
		}
		const totals = latestLocations.reduce(
			(acc, loc) => {
				acc.lat += loc.lat;
				acc.lon += loc.lon;
				return acc;
			},
			{ lat: 0, lon: 0 },
		);
		const lat = totals.lat / latestLocations.length;
		const lon = totals.lon / latestLocations.length;
		const zoom =
			latestLocations.length === 1
				? 5.5
				: latestLocations.length <= 3
					? 3.2
					: 2.4;
		return { lat, lon, zoom };
	});

	const heroMetrics = $derived([
		{
			label: "VIDEOS",
			value: tableData.videos.length.toString().padStart(2, "0"),
		},
		{
			label: "CURATORS",
			value: uniqueContributors.toString().padStart(2, "0"),
		},
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	]);

	const totalLikes = $derived(
		tableData.videos.reduce(
			(sum, video) => sum + (video.original.likes ?? 0),
			0,
		),
	);

	const profileStats = $derived({
		videos: tableData.videos.length,
		sounds: tableData.sounds.length,
		duration: formatRuntime(totalRuntimeSeconds),
		likes: totalLikes,
	});

	function getSortValue(
		row: any,
		tableKey: TableKey,
		key: string,
	): string | number {
		if (tableKey === "videos") {
			switch (key) {
				case "title":
					return row.title;
				case "author":
					return row.author;
				case "duration":
					return row.durationValue;
				case "uploaded":
					return row.uploadedValue;
				case "views":
					return row.viewsValue ?? -1;
				default:
					return "";
			}
		}
		if (tableKey === "sounds") {
			switch (key) {
				case "title":
					return row.title;
				case "recordist":
					return row.recordist;
				case "project":
					return row.project;
				case "captured":
					return row.capturedValue;
				case "duration":
					return row.durationValue;
				default:
					return "";
			}
		}
		if (tableKey === "members") {
			switch (key) {
				case "name":
					return row.name;
				case "videos":
					return row.videos;
				case "followers":
					return row.followers;
				case "following":
					return row.following;
				case "joined":
					return row.joinedValue;
				default:
					return "";
			}
		}
		if (tableKey === "keywords") {
			switch (key) {
				case "keyword":
					return row.keyword;
				case "usage":
					return row.usage;
				case "related":
					return row.related;
				default:
					return "";
			}
		}
		return "";
	}

	function sortRows(tableKey: TableKey) {
		const state = tableState[tableKey];
		if (!state) return [];
		const rows = [...(tableData[tableKey] as any[])];
		const direction = state.sortDirection === "asc" ? 1 : -1;

		return rows.sort((a, b) => {
			const aValue = getSortValue(a, tableKey, state.sortKey);
			const bValue = getSortValue(b, tableKey, state.sortKey);
			if (typeof aValue === "number" && typeof bValue === "number") {
				return (aValue - bValue) * direction;
			}
			const aStr = `${aValue ?? ""}`.toLowerCase();
			const bStr = `${bValue ?? ""}`.toLowerCase();
			return (
				aStr.localeCompare(bStr, undefined, {
					numeric: true,
					sensitivity: "base",
				}) * direction
			);
		});
	}

	function toggleSort(tableKey: TableKey, columnKey: string) {
		const current = tableState[tableKey];
		if (!current) return;
		if (current.sortKey === columnKey) {
			current.sortDirection =
				current.sortDirection === "asc" ? "desc" : "asc";
		} else {
			current.sortKey = columnKey;
			current.sortDirection = "asc";
		}
	}

	function openVideo(video: any, event?: MouseEvent) {
		if (event) {
			if (
				event.metaKey ||
				event.ctrlKey ||
				event.shiftKey ||
				event.button !== 0
			)
				return;
			event.preventDefault();
		}
		selectedVideo.selectVideo(video.id);
		actions.setExpanded(false);
		goto("/");
	}

	function handleVideoRowKey(event: KeyboardEvent, video: any) {
		if (event.key === "Enter" || event.key === " ") {
			event.preventDefault();
			openVideo(video);
		}
	}

	const sortedVideoRows = $derived(sortRows("videos"));
	const sortedSoundRows = $derived(sortRows("sounds"));
	const sortedMemberRows = $derived(sortRows("members"));
	const sortedKeywordRows = $derived(sortRows("keywords"));
</script>

<svelte:head>
	<title>Media Dashboard ‚Äî Rushes</title>
	<meta
		name="description"
		content="Terminal overview of the Rushes archive."
	/>
</svelte:head>

<div
	class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200"
>
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<div
				class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"
			></div>
			<div
				class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"
			></div>
			<div
				class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-end md:justify-between"
			>
				<div class="min-w-0 space-y-3">
					<p
						class="text-[11px] uppercase tracking-[0.35em] text-slate-500"
					>
						Rushes.fm
					</p>
					<!-- <h1 class="text-2xl font-semibold text-white">
						Channel Overview
					</h1> -->
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						RUSHES.BE est une plateforme collective d√©di√©e aux cin√©astes bruxellois. Elle cartographie les rushes ‚Äî images non mont√©es, fragments de tournage ‚Äî pour nourrir une archive vivante, un espace de rencontre et un laboratoire d‚Äôexp√©rimentation visuelle.

					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div
							class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner"
						>
							<p
								class="text-[10px] uppercase tracking-[0.3em] text-slate-500"
							>
								{metric.label}
							</p>
							<p class="mt-2 text-lg font-semibold text-white">
								{metric.value}
							</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<div class="grid gap-8 lg:grid-cols-2">
			<div
				class="column-container space-y-8"
				aria-label="Primary dashboard column"
				use:dndzone={{
					items: itemsLeft,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateLeftColumn}
				on:finalize={updateLeftColumn}
			>
				{#each itemsLeft as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>

			<div
				class="column-container space-y-8"
				aria-label="Secondary dashboard column"
				use:dndzone={{
					items: itemsRight,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateRightColumn}
				on:finalize={updateRightColumn}
			>
				{#each itemsRight as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>
		</div>
	</div>
</div>

<style>
	.column-container {
		transition:
			background-color 0.2s ease,
			border-color 0.2s ease;
		border-radius: 0.5rem;
		border: 1px solid transparent;
		min-height: min-content;
	}
	:global(.dashboard-drop-target) {
		background-color: rgba(56, 189, 248, 0.05);
		border-color: rgba(56, 189, 248, 0.2);
	}
	.draggable-item[data-is-dnd-shadow-item-hint="true"] {
		opacity: 0.65;
	}
</style>
</file>

<file path="src/routes/videos/+page.svelte.backup">
<script lang="ts">
	import { goto } from "$app/navigation";
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { slide } from "svelte/transition";
	import {
		dndzone,
		type DndEvent,
		SHADOW_ITEM_MARKER_PROPERTY_NAME,
	} from "svelte-dnd-action";
	import DashboardPanel from "$lib/components/dashboard/DashboardPanel.svelte";
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		SortDirection,
		TableColumn,
		TableKey,
		TableState,
	} from "$lib/types/dashboard";
import { videosStore, usersStore } from "$lib/stores/library";

	const boardDndType = "dashboard-panels";
	const boardDropTargetClasses = ["dashboard-drop-target"];
	const boardFlipDurationMs = 200;

	const videos = $derived($videosStore);
	const users = $derived($usersStore);

	// State for draggable items in each column
	let itemsLeft = $state<DashboardItem[]>([{ id: 1, component: "videos" }, { id: 2, component: "sounds" }]);

	let itemsRight = $state<DashboardItem[]>([
		{ id: 5, component: "profile" },
		{ id: 6, component: "activity" },
		{ id: 7, component: "locations" },
		{ id: 3, component: "members" },
		{ id: 4, component: "keywords" },
	]);

	const sectionLabels: Record<DashboardComponentKey, string> = {
		videos: "Queue overview",
		profile: "Profile summary",
		activity: "Live activity",
		sounds: "Sounds",
		members: "Members",
		keywords: "Keywords",
		locations: "Latest locations",
	};

	function getSectionLabel(item: DashboardItem) {
		return sectionLabels[item.component] ?? "Dashboard section";
	}

	function updateLeftColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsLeft = event.detail.items as DashboardItem[];
	}

	function updateRightColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsRight = event.detail.items as DashboardItem[];
	}

	const liveActivity = $state([
		{
			id: "act-1",
			user: "In√®s Duarte",
			action: "liked",
			content: "Canal Footbridge Atmos",
			type: "like",
			time: "2m ago",
		},
		{
			id: "act-2",
			user: "Luca Van Eyck",
			action: "commented on",
			content: "Metro Brakes ‚Äì Line 6",
			type: "comment",
			time: "5m ago",
		},
		{
			id: "act-3",
			user: "Aya Kakei",
			action: "liked",
			content: "Night Rain On Skylight",
			type: "like",
			time: "1h ago",
		},
		{
			id: "act-4",
			user: "Tom Schurr",
			action: "commented on",
			content: "Textile Rustle Layers",
			type: "comment",
			time: "3h ago",
		},
	]);

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	let collapsed = $state({
		videos: false,
		sounds: false,
		members: false,
		keywords: false,
		activity: false,
		locations: false,
	});

	function toggleCollapse(component: DashboardComponentKey) {
		collapsed[component] = !collapsed[component];
	}

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "In√®s Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des P√©niches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes ‚Äì Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo ‚Äî ‚ÄúGolden Hour‚Äù",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let tableState = $state({
		videos: {
			key: "videos",
			label: "Queue",
			sortKey: "uploaded",
			sortDirection: "desc",
			defaultSort: { key: "uploaded", direction: "desc" },
			columns: [],
		},
		sounds: {
			key: "sounds",
			label: "Sounds",
			sortKey: "captured",
			sortDirection: "desc",
			defaultSort: { key: "captured", direction: "desc" },
			columns: [
				{ key: "title", label: "CLIP" },
				{ key: "recordist", label: "CAPTURED_BY" },
				{ key: "captured", label: "CAPTURED", align: "right" },
				{ key: "duration", label: "DURATION", align: "right" },
			],
		},
		members: {
			key: "members",
			label: "MEMBERS",
			sortKey: "name",
			sortDirection: "asc",
			defaultSort: { key: "name", direction: "asc" },
			columns: [
				{ key: "name", label: "NAME" },
				{ key: "videos", label: "VIDEOS", align: "right" },
				{ key: "followers", label: "FOLLOWERS", align: "right" },
				{ key: "following", label: "FOLLOWING", align: "right" },
				{ key: "joined", label: "JOINED", align: "right" },
			],
		},
		keywords: {
			key: "keywords",
			label: "KEYWORDS",
			sortKey: "keyword",
			sortDirection: "asc",
			defaultSort: { key: "keyword", direction: "asc" },
			columns: [
				{ key: "keyword", label: "TERM" },
				{ key: "usage", label: "USAGE", align: "right" },
				{ key: "related", label: "RELATED_PROJECTS" },
			],
		},
	});

	function formatDate(iso?: string) {
		if (!iso) return "‚Äî";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		return date.toISOString().split("T")[0];
	}

	function parseDuration(value?: string) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [h, m, s] = parts;
			return h * 3600 + m * 60 + s;
		}
		if (parts.length === 2) {
			const [m, s] = parts;
			return m * 60 + s;
		}
		return parts[0];
	}

	function formatViews(views?: number) {
		if (typeof views !== "number" || Number.isNaN(views)) return "‚Äî";
		if (views >= 1_000_000) return `${(views / 1_000_000).toFixed(1)}M`;
		if (views >= 1_000) return `${(views / 1_000).toFixed(1)}K`;
		return `${views}`;
	}

	function formatStat(num: number) {
		if (num >= 1000) return `${(num / 1000).toFixed(1)}k`;
		return num.toString();
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return 0;
	}

	function getLocationCoordinates(
		location: any,
	): { lat: number; lon: number } | null {
		if (
			typeof location?.mapLat === "number" &&
			typeof location?.mapLon === "number"
		) {
			return { lat: location.mapLat, lon: location.mapLon };
		}
		if (
			typeof location?.latitude === "number" &&
			typeof location?.longitude === "number"
		) {
			return { lat: location.latitude, lon: location.longitude };
		}
		if (
			Array.isArray(location?.coordinates) &&
			location.coordinates.length === 2
		) {
			const [lat, lon] = location.coordinates;
			if (typeof lat === "number" && typeof lon === "number") {
				return { lat, lon };
			}
		}
		return null;
	}

	function getKeywordsSummary() {
		const keywordMap = new Map<
			string,
			{ usage: number; related: Set<string> }
		>();
		for (const video of videos) {
			for (const key of video.keywords ?? []) {
				const entry = keywordMap.get(key) ?? {
					usage: 0,
					related: new Set<string>(),
				};
				entry.usage += 1;
				entry.related.add(video.title);
				keywordMap.set(key, entry);
			}
		}
		return Array.from(keywordMap.entries()).map(([keyword, info]) => ({
			keyword,
			usage: info.usage,
			related: Array.from(info.related).join(", "),
		}));
	}

	const tableData = $derived({
		videos: videos.map((video) => {
			const iso = video.timestamp ?? video.uploadDate ?? null;
			const uploadedLabel = iso
				? formatDate(iso)
				: (video.uploadedAt ?? "‚Äî");
			return {
				id: video.id,
				title: video.title,
				author: video.author,
				duration: video.duration ?? "0:00",
				durationValue: video.duration,
				uploaded: uploadedLabel,
				uploadedValue: iso ? Date.parse(iso) : Number.NEGATIVE_INFINITY,
				views: formatViews(video.views),
				viewsValue:
					typeof video.views === "number" ? video.views : null,
				original: video,
			};
		}),
		sounds: soundLibrary.map((clip) => ({
			id: clip.id,
			title: clip.title,
			location: clip.location,
			recordist: clip.recordist,
			project: clip.relatedProject,
			captured: formatDate(clip.capturedOn),
			capturedValue: Date.parse(clip.capturedOn),
			duration: clip.duration,
			durationValue: clip.duration,
		})),
		members: users.map((user) => ({
			id: user.id,
			name: user.name,
			videos: user.stats?.videos ?? 0,
			followers: user.stats?.followers ?? 0,
			following: user.stats?.following ?? 0,
			joined: user.joinedAt ? formatDate(user.joinedAt) : "‚Äî",
			joinedValue: user.joinedAt
				? Date.parse(user.joinedAt)
				: Number.NEGATIVE_INFINITY,
		})),
		keywords: getKeywordsSummary(),
	});

	const totalRuntimeSeconds = $derived(
		tableData.videos.reduce(
			(total, video) =>
				total +
				(typeof video.durationValue === "number"
					? video.durationValue
					: 0),
			0,
		),
	);
	const uniqueContributors = $derived(
		new Set(
			tableData.videos
				.map((video) => video.author)
				.filter((author) => Boolean(author)),
		).size,
	);
	const lastUploadedTimestamp = $derived(
		tableData.videos.reduce((latest, video) => {
			if (Number.isFinite(video.uploadedValue)) {
				return Math.max(latest, video.uploadedValue);
			}
			return latest;
		}, Number.NEGATIVE_INFINITY),
	);

	const lastUpdated = $derived(
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "‚Äî",
	);
	const averageDurationLabel = $derived(() => {
		if (tableData.videos.length === 0) return "0m";
		const averageSeconds = Math.round(
			totalRuntimeSeconds / tableData.videos.length,
		);
		return formatRuntime(averageSeconds);
	});

	const latestLocations = $derived<LatestLocationPin[]>(() => {
		const pins: LatestLocationPin[] = [];
		for (const video of videos) {
			const locations = video.locations ?? [];
			if (!Array.isArray(locations) || locations.length === 0) continue;
			const timestampValue = getVideoTimestampValue(video);
			const isoCandidate =
				typeof (video.timestamp ?? video.uploadDate) === "string"
					? (video.timestamp ?? video.uploadDate)
					: null;
			const uploadedLabel =
				isoCandidate && !Number.isNaN(Date.parse(isoCandidate))
					? formatDate(isoCandidate)
					: typeof video.uploadedAt === "string"
						? video.uploadedAt
						: "‚Äî";
			locations.forEach((location, index) => {
				const coords = getLocationCoordinates(location);
				if (!coords) return;
				pins.push({
					id: `${video.id}-${index}`,
					videoId: video.id,
					videoTitle: video.title,
					videoAuthor: video.author,
					uploadedLabel,
					timestampValue,
					lat: coords.lat,
					lon: coords.lon,
					setting: location.setting ?? location.name,
					thumbnailUrl: video.thumbnailUrl,
				});
			});
		}
		return pins
			.sort((a, b) => b.timestampValue - a.timestampValue)
			.slice(0, 6);
	});

	const locationCenter = $derived<LocationCenter>(() => {
		if (latestLocations.length === 0) {
			return { lat: 20, lon: 0, zoom: 1.6 };
		}
		const totals = latestLocations.reduce(
			(acc, loc) => {
				acc.lat += loc.lat;
				acc.lon += loc.lon;
				return acc;
			},
			{ lat: 0, lon: 0 },
		);
		const lat = totals.lat / latestLocations.length;
		const lon = totals.lon / latestLocations.length;
		const zoom =
			latestLocations.length === 1
				? 5.5
				: latestLocations.length <= 3
					? 3.2
					: 2.4;
		return { lat, lon, zoom };
	});

	const heroMetrics = $derived([
		{
			label: "VIDEOS",
			value: tableData.videos.length.toString().padStart(2, "0"),
		},
		{
			label: "CURATORS",
			value: uniqueContributors.toString().padStart(2, "0"),
		},
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	]);

	const totalLikes = $derived(
		tableData.videos.reduce(
			(sum, video) => sum + (video.original.likes ?? 0),
			0,
		),
	);

	const profileStats = $derived({
		videos: tableData.videos.length,
		sounds: tableData.sounds.length,
		duration: formatRuntime(totalRuntimeSeconds),
		likes: totalLikes,
	});

	function getSortValue(
		row: any,
		tableKey: TableKey,
		key: string,
	): string | number {
		if (tableKey === "videos") {
			switch (key) {
				case "title":
					return row.title;
				case "author":
					return row.author;
				case "duration":
					return row.durationValue;
				case "uploaded":
					return row.uploadedValue;
				case "views":
					return row.viewsValue ?? -1;
				default:
					return "";
			}
		}
		if (tableKey === "sounds") {
			switch (key) {
				case "title":
					return row.title;
				case "recordist":
					return row.recordist;
				case "project":
					return row.project;
				case "captured":
					return row.capturedValue;
				case "duration":
					return row.durationValue;
				default:
					return "";
			}
		}
		if (tableKey === "members") {
			switch (key) {
				case "name":
					return row.name;
				case "videos":
					return row.videos;
				case "followers":
					return row.followers;
				case "following":
					return row.following;
				case "joined":
					return row.joinedValue;
				default:
					return "";
			}
		}
		if (tableKey === "keywords") {
			switch (key) {
				case "keyword":
					return row.keyword;
				case "usage":
					return row.usage;
				case "related":
					return row.related;
				default:
					return "";
			}
		}
		return "";
	}

	function sortRows(tableKey: TableKey) {
		const state = tableState[tableKey];
		if (!state) return [];
		const rows = [...(tableData[tableKey] as any[])];
		const direction = state.sortDirection === "asc" ? 1 : -1;

		return rows.sort((a, b) => {
			const aValue = getSortValue(a, tableKey, state.sortKey);
			const bValue = getSortValue(b, tableKey, state.sortKey);
			if (typeof aValue === "number" && typeof bValue === "number") {
				return (aValue - bValue) * direction;
			}
			const aStr = `${aValue ?? ""}`.toLowerCase();
			const bStr = `${bValue ?? ""}`.toLowerCase();
			return (
				aStr.localeCompare(bStr, undefined, {
					numeric: true,
					sensitivity: "base",
				}) * direction
			);
		});
	}

	function toggleSort(tableKey: TableKey, columnKey: string) {
		const current = tableState[tableKey];
		if (!current) return;
		if (current.sortKey === columnKey) {
			current.sortDirection =
				current.sortDirection === "asc" ? "desc" : "asc";
		} else {
			current.sortKey = columnKey;
			current.sortDirection = "asc";
		}
	}

	function openVideo(video: any, event?: MouseEvent) {
		if (event) {
			if (
				event.metaKey ||
				event.ctrlKey ||
				event.shiftKey ||
				event.button !== 0
			)
				return;
			event.preventDefault();
		}
		selectedVideo.selectVideo(video.id);
		actions.setExpanded(true);
		goto("/");
	}

	function handleVideoRowKey(event: KeyboardEvent, video: any) {
		if (event.key === "Enter" || event.key === " ") {
			event.preventDefault();
			openVideo(video);
		}
	}

	const sortedVideoRows = $derived(sortRows("videos"));
	const sortedSoundRows = $derived(sortRows("sounds"));
	const sortedMemberRows = $derived(sortRows("members"));
	const sortedKeywordRows = $derived(sortRows("keywords"));
</script>

<svelte:head>
	<title>Media Dashboard ‚Äî Rushes</title>
	<meta
		name="description"
		content="Terminal overview of the Rushes archive."
	/>
</svelte:head>

<div
	class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200"
>
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<div
				class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"
			></div>
			<div
				class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"
			></div>
			<div
				class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-end md:justify-between"
			>
				<div class="min-w-0 space-y-3">
					<p
						class="text-[11px] uppercase tracking-[0.35em] text-slate-500"
					>
						Rushes.fm
					</p>
					<!-- <h1 class="text-2xl font-semibold text-white">
						Channel Overview
					</h1> -->
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						RUSHES.BE est une plateforme collective d√©di√©e aux cin√©astes bruxellois. Elle cartographie les rushes ‚Äî images non mont√©es, fragments de tournage ‚Äî pour nourrir une archive vivante, un espace de rencontre et un laboratoire d‚Äôexp√©rimentation visuelle.

					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div
							class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner"
						>
							<p
								class="text-[10px] uppercase tracking-[0.3em] text-slate-500"
							>
								{metric.label}
							</p>
							<p class="mt-2 text-lg font-semibold text-white">
								{metric.value}
							</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<div class="grid gap-8 lg:grid-cols-2">
			<div
				class="column-container space-y-8"
				aria-label="Primary dashboard column"
				use:dndzone={{
					items: itemsLeft,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateLeftColumn}
				on:finalize={updateLeftColumn}
			>
				{#each itemsLeft as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>

			<div
				class="column-container space-y-8"
				aria-label="Secondary dashboard column"
				use:dndzone={{
					items: itemsRight,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateRightColumn}
				on:finalize={updateRightColumn}
			>
				{#each itemsRight as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>
		</div>
	</div>
</div>

<style>
	.column-container {
		transition:
			background-color 0.2s ease,
			border-color 0.2s ease;
		border-radius: 0.5rem;
		border: 1px solid transparent;
		min-height: min-content;
	}
	:global(.dashboard-drop-target) {
		background-color: rgba(56, 189, 248, 0.05);
		border-color: rgba(56, 189, 248, 0.2);
	}
	.draggable-item[data-is-dnd-shadow-item-hint="true"] {
		opacity: 0.65;
	}
</style>
</file>

<file path="src/routes/+layout.server.ts">
import type { LayoutServerLoad } from "./$types";
import { getAllVideos } from "$lib/server/db/videos";
import { getAllUsers } from "$lib/server/db/users";

const DATABASE_TIMEOUT_MS = 10000; // 10 seconds

export const load: LayoutServerLoad = async () => {
  try {
    const [videos, users] = (await Promise.race([
      Promise.all([getAllVideos(), getAllUsers()]),
      new Promise((_, reject) =>
        setTimeout(
          () => reject(new Error("Database query timeout")),
          DATABASE_TIMEOUT_MS,
        ),
      ),
    ])) as [
      Awaited<ReturnType<typeof getAllVideos>>,
      Awaited<ReturnType<typeof getAllUsers>>,
    ];

    return {
      videos,
      users,
    };
  } catch (error) {
    console.error("Failed to load initial data:", error);

    // Return empty arrays rather than failing completely
    return {
      videos: [],
      users: [],
      error: error instanceof Error ? error.message : "Failed to load content",
    };
  }
};
</file>

<file path="src/routes/+layout.svelte">
<script lang="ts">
    import "../app.css";
    import { browser } from "$app/environment";
    import { theme } from "$lib/stores/theme";
    import { activeVideo } from "$lib/stores/video";
    import { onMount } from "svelte";
    import Header from "$lib/components/Header.svelte";
    import Sidebar from "$lib/components/Sidebar.svelte";
    import PersistentVideoPlayer from "$lib/components/PersistentVideoPlayer.svelte";
    import { page } from "$app/stores";
    import Playing from "$lib/components/Playing.svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import MuxVideoPlayer from "$lib/components/MuxVideoPlayer.svelte";
    import VideoTimeline from "$lib/components/VideoTimeline.svelte";
    import VideoInfoContainer from "$lib/components/VideoInfoContainer.svelte";
    import type { LayoutData } from "./$types";
    import type { Video } from "$lib/types/content";
    import {
        initialiseLibrary,
        videosStore,
        getVideoById as lookupVideo,
    } from "$lib/stores/library";
    import { uiState, actions } from "$lib/stores/appStore";

    let { children, data } = $props<{
        children: () => any;
        data: LayoutData;
    }>();
    let isMobileSidebarOpen = $state(false);
    const videoLibrary = $derived($videosStore);
    const selectedVideoId = $derived($selectedVideo.id);
    const defaultVideo = $derived(videoLibrary[0] ?? null);

    function resolveVideo(id: string | null) {
        if (!id) return null;
        if (id === "home") {
            return defaultVideo;
        }
        return lookupVideo(id) ?? defaultVideo;
    }

    const currentVideo = $derived(resolveVideo($selectedVideo.id));

    function getVideoDuration(video: Video): number {
        const value = video.duration;
        if (typeof value === "number" && Number.isFinite(value) && value > 0) {
            return value;
        }
        // Fallback to three minutes if duration metadata is missing
        return 180;
    }

    function computeLivePlayback(
        videos: Video[],
        referenceTimestamp: number,
    ): { video: Video; startTime: number } | null {
        if (!videos.length) return null;
        const durations = videos.map(getVideoDuration);
        const totalDuration = durations.reduce((sum, value) => sum + value, 0);
        if (totalDuration <= 0) return null;

        const position = referenceTimestamp % totalDuration;
        let cursor = 0;
        for (let index = 0; index < videos.length; index += 1) {
            const nextCursor = cursor + durations[index];
            if (position < nextCursor) {
                return {
                    video: videos[index],
                    startTime: position - cursor,
                };
            }
            cursor = nextCursor;
        }
        return {
            video: videos[0]!,
            startTime: 0,
        };
    }

    let liveStartTime = $state(0);
    let liveTargetVideoId = $state<string | null>(null);
    let liveSourceSignature = $state("");

    $effect(() => {
        if (!browser) return;
        const videos = videoLibrary;
        if (!videos || videos.length === 0) return;

        const signature = videos
            .map((video) => `${video.id}:${getVideoDuration(video)}`)
            .join("|");
        if (liveSourceSignature === signature && liveTargetVideoId) {
            return;
        }

        const now = Math.floor(Date.now() / 1000);
        const playback = computeLivePlayback(videos, now);
        if (!playback) return;

        liveStartTime = playback.startTime;
        liveTargetVideoId = playback.video.id;
        liveSourceSignature = signature;

        if (selectedVideoId !== playback.video.id) {
            selectedVideo.selectVideo(playback.video.id);
        }
    });

    $effect(() => {
        if (data) {
            initialiseLibrary(data.videos, data.users);
            // Initialize the playback queue with all video IDs
            const videoIds = data.videos.map((v) => v.id);
            selectedVideo.setQueue(videoIds);
        }
    });

    function shouldExpandPath(pathname: string) {
        return (
            pathname === "/live" ||
            (pathname.startsWith("/videos/") && pathname !== "/videos")
        );
    }

    $effect(() => {
        const unsubscribe = uiState.subscribe((state) => {
            selectedVideo.setFullScreen(state.isExpanded);
        });
        return () => unsubscribe();
    });

    onMount(() => {
        theme.init();
        const currentPath = $page.url.pathname;
        if (!currentPath.startsWith("/videos/")) {
            selectedVideo.selectVideo("home");
        }
        const initialExpanded = shouldExpandPath(currentPath);
        uiState.set({ isExpanded: initialExpanded });
        selectedVideo.setFullScreen(initialExpanded);
    });

    $effect(() => {
        const pathname = $page.url.pathname;
        if (pathname === "/live") {
            actions.setExpanded(true);
            return;
        }
        if (pathname.startsWith("/videos/") && pathname !== "/videos") {
            actions.setExpanded(true);
            return;
        }
        // All other routes should minimize the player to sidebar mode
        actions.setExpanded(false);
    });

    function toggleMobileSidebar() {
        isMobileSidebarOpen = !isMobileSidebarOpen;
    }

    function closeMobileSidebar() {
        isMobileSidebarOpen = false;
    }

    // Check if we're on the video page
    const isVideoPage = $derived(
        $page.url.pathname.startsWith("/videos/") ||
            $page.url.pathname === "/live",
    );
    const showPipPlayer = $derived(!isVideoPage && $activeVideo !== null);
</script>

<svelte:head>
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Rushes</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Droid+Serif:ital,wght@0,400;0,700;1,400;1,700&family=Fira+Mono:wght@400;500;700&display=swap"
        rel="stylesheet"
    />
</svelte:head>

<!-- Persistent Video Player
{#if $activeVideo}
	<PersistentVideoPlayer />
{/if} -->

<div class="min-h-screen w-full overflow-x-hidden transition-colors">
    <div class="flex min-h-screen w-full relative overflow-visible">
        <!-- Sidebar -->
        <Sidebar isOpen="true" onclose={closeMobileSidebar} />

        <!-- Desktop Now Playing section, live like function with video queue -->
        <div
            id="scroll-view"
            class="hidden lg:flex h-screen flex-col w-[500px] max-w-[500px] shrink-0 border-l border-r border-gray-200/10 dark:border-neutral-100/10 bg-white dark:bg-white/2"
        >
            <div id="scroll-content" class="flex-1 overflow-y-auto">
                <div class="flex flex-col min-h-full gap-6">
                    <div class="flex-none" id="video-wrapper">
                        <div
                            id="video-aspect-container"
                            class="relative aspect-video w-full border-b border-white/10 bg-black shadow-[0_24px_80px_-48px_rgba(8,47,73,0.85)]"
                        >
                            <MuxVideoPlayer
                                class="h-full w-full"
                                src={currentVideo?.videoUrl}
                                autoplayUserPreference={true}
                                startTime={liveStartTime}
                                playerKey={`sidebar-player-${currentVideo?.id ?? "none"}-${Math.floor(liveStartTime)}`}
                            />
                        </div>
                    </div>

                    <!-- Video Info Container (like Sidebar content in Astro) -->
                    <div id="sidebar-details" class="flex-1">
                        <VideoTimeline />
                        <VideoInfoContainer />
                    </div>
                </div>
            </div>
        </div>

        <!-- Main content wrapper -->
        <div
            class="flex-1 flex flex-col w-full transition-all duration-200 min-h-0 overflow-hidden"
            class:translate-x-64={isMobileSidebarOpen}
        >
            <!-- Header -->
            <!-- <Header ontoggleSidebar={toggleMobileSidebar} /> -->

            <!-- Main content area -->
            <main
                class="flex-1 w-full max-w-full bg-white h-full overflow-scroll dark:bg-black min-h-0"
                style="height: 100vh; overflow-y: scroll;"
                style:view-transition-name="main-content"
            >
                {@render children()}
            </main>
        </div>
    </div>
</div>

<!-- Mobile-only playing overlay -->
<div class="lg:hidden">
    <Playing />
</div>

<style>
    :global(body) {
        font-family: "Droid Serif", serif;
        view-transition-name: none;
    }

    :global(::view-transition-old(main-content)),
    :global(::view-transition-new(main-content)) {
        animation: none;
        mix-blend-mode: normal;
    }

    :global(::view-transition-old(video-player)),
    :global(::view-transition-new(video-player)) {
        animation: none;
        mix-blend-mode: normal;
    }

    /* Player container styles from Astro layout */
    :global(#player-container) {
        will-change: transform;
        transform-style: preserve-3d;
        position: relative;
        width: 100%;
        height: 100%;
        margin: 0 auto;
        overflow: hidden;
        object-fit: cover !important;
        object-position: center center !important;
    }

    :global(#player-container.fullscreen) {
        position: fixed;
        will-change: transform;
        transform-style: preserve-3d;
        z-index: 999999;
        top: 2rem;
        border-radius: 0;
        left: calc(570px + 3rem);
        width: calc(100vw - 660px);
        height: calc(100vh - 3rem);
    }

    /* Collapse the video wrapper when player is fullscreen to remove aspect-ratio gap */
    :global(#video-wrapper:has(#player-container.fullscreen)) {
        height: 0 !important;
        min-height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
    }

    /* Remove aspect ratio and hide the container when player is fullscreen */
    :global(#video-aspect-container:has(#player-container.fullscreen)) {
        aspect-ratio: unset !important;
        height: 0 !important;
        min-height: 0 !important;
        padding: 0 !important;
        border: none !important;
    }

    /* Ensure video element stays above everything */
    :global(#player-container video) {
        width: 100%;
        height: 100%;
        position: relative;
        top: 0;
        left: 0;
    }
</style>
</file>

<file path="src/routes/+page.svelte">
<script lang="ts">
	import { goto } from "$app/navigation";
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { slide } from "svelte/transition";
	import {
		dndzone,
		type DndEvent,
		SHADOW_ITEM_MARKER_PROPERTY_NAME,
	} from "svelte-dnd-action";
	import DashboardPanel from "$lib/components/dashboard/DashboardPanel.svelte";
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		SortDirection,
		TableColumn,
		TableKey,
		TableState,
	} from "$lib/types/dashboard";
import { videosStore, usersStore } from "$lib/stores/library";

	const boardDndType = "dashboard-panels";
	const boardDropTargetClasses = ["dashboard-drop-target"];
	const boardFlipDurationMs = 200;

	const videos = $derived($videosStore);
	const users = $derived($usersStore);

	// State for draggable items in each column
	let itemsLeft = $state<DashboardItem[]>([{ id: 1, component: "videos" }, { id: 2, component: "sounds" }]);

	let itemsRight = $state<DashboardItem[]>([
		{ id: 5, component: "profile" },
		{ id: 6, component: "activity" },
		{ id: 7, component: "locations" },
		{ id: 3, component: "members" },
		{ id: 4, component: "keywords" },
	]);

	const sectionLabels: Record<DashboardComponentKey, string> = {
		videos: "Queue overview",
		profile: "Profile summary",
		activity: "Live activity",
		sounds: "Sounds",
		members: "Members",
		keywords: "Keywords",
		locations: "Latest locations",
	};

	function getSectionLabel(item: DashboardItem) {
		return sectionLabels[item.component] ?? "Dashboard section";
	}

	function updateLeftColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsLeft = event.detail.items as DashboardItem[];
	}

	function updateRightColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsRight = event.detail.items as DashboardItem[];
	}

	const liveActivity = $state([
		{
			id: "act-1",
			user: "In√®s Duarte",
			action: "liked",
			content: "Canal Footbridge Atmos",
			type: "like",
			time: "2m ago",
		},
		{
			id: "act-2",
			user: "Luca Van Eyck",
			action: "commented on",
			content: "Metro Brakes ‚Äì Line 6",
			type: "comment",
			time: "5m ago",
		},
		{
			id: "act-3",
			user: "Aya Kakei",
			action: "liked",
			content: "Night Rain On Skylight",
			type: "like",
			time: "1h ago",
		},
		{
			id: "act-4",
			user: "Tom Schurr",
			action: "commented on",
			content: "Textile Rustle Layers",
			type: "comment",
			time: "3h ago",
		},
	]);

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	let collapsed = $state({
		videos: false,
		sounds: false,
		members: false,
		keywords: false,
		activity: false,
		locations: false,
	});

	function toggleCollapse(component: DashboardComponentKey) {
		collapsed[component] = !collapsed[component];
	}

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "In√®s Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des P√©niches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes ‚Äì Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo ‚Äî ‚ÄúGolden Hour‚Äù",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let tableState = $state({
		videos: {
			key: "videos",
			label: "Queue",
			sortKey: "uploaded",
			sortDirection: "desc",
			defaultSort: { key: "uploaded", direction: "desc" },
			columns: [],
		},
		sounds: {
			key: "sounds",
			label: "Sounds",
			sortKey: "captured",
			sortDirection: "desc",
			defaultSort: { key: "captured", direction: "desc" },
			columns: [
				{ key: "title", label: "CLIP" },
				{ key: "recordist", label: "CAPTURED_BY" },
				{ key: "captured", label: "CAPTURED", align: "right" },
				{ key: "duration", label: "DURATION", align: "right" },
			],
		},
		members: {
			key: "members",
			label: "MEMBERS",
			sortKey: "name",
			sortDirection: "asc",
			defaultSort: { key: "name", direction: "asc" },
			columns: [
				{ key: "name", label: "NAME" },
				{ key: "videos", label: "VIDEOS", align: "right" },
				{ key: "followers", label: "FOLLOWERS", align: "right" },
				{ key: "following", label: "FOLLOWING", align: "right" },
				{ key: "joined", label: "JOINED", align: "right" },
			],
		},
		keywords: {
			key: "keywords",
			label: "KEYWORDS",
			sortKey: "keyword",
			sortDirection: "asc",
			defaultSort: { key: "keyword", direction: "asc" },
			columns: [
				{ key: "keyword", label: "TERM" },
				{ key: "usage", label: "USAGE", align: "right" },
				{ key: "related", label: "RELATED_PROJECTS" },
			],
		},
	});

	function formatDate(iso?: string) {
		if (!iso) return "‚Äî";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		return date.toISOString().split("T")[0];
	}

	function parseDuration(value?: string) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [h, m, s] = parts;
			return h * 3600 + m * 60 + s;
		}
		if (parts.length === 2) {
			const [m, s] = parts;
			return m * 60 + s;
		}
		return parts[0];
	}

	function formatViews(views?: number) {
		if (typeof views !== "number" || Number.isNaN(views)) return "‚Äî";
		if (views >= 1_000_000) return `${(views / 1_000_000).toFixed(1)}M`;
		if (views >= 1_000) return `${(views / 1_000).toFixed(1)}K`;
		return `${views}`;
	}

	function formatStat(num: number) {
		if (num >= 1000) return `${(num / 1000).toFixed(1)}k`;
		return num.toString();
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return 0;
	}

	function getLocationCoordinates(
		location: any,
	): { lat: number; lon: number } | null {
		if (
			typeof location?.mapLat === "number" &&
			typeof location?.mapLon === "number"
		) {
			return { lat: location.mapLat, lon: location.mapLon };
		}
		if (
			typeof location?.latitude === "number" &&
			typeof location?.longitude === "number"
		) {
			return { lat: location.latitude, lon: location.longitude };
		}
		if (
			Array.isArray(location?.coordinates) &&
			location.coordinates.length === 2
		) {
			const [lat, lon] = location.coordinates;
			if (typeof lat === "number" && typeof lon === "number") {
				return { lat, lon };
			}
		}
		return null;
	}

	function getKeywordsSummary() {
		const keywordMap = new Map<
			string,
			{ usage: number; related: Set<string> }
		>();
		for (const video of videos) {
			for (const key of video.keywords ?? []) {
				const entry = keywordMap.get(key) ?? {
					usage: 0,
					related: new Set<string>(),
				};
				entry.usage += 1;
				entry.related.add(video.title);
				keywordMap.set(key, entry);
			}
		}
		return Array.from(keywordMap.entries()).map(([keyword, info]) => ({
			keyword,
			usage: info.usage,
			related: Array.from(info.related).join(", "),
		}));
	}

	const tableData = $derived({
		videos: videos.map((video) => {
			const iso = video.timestamp ?? video.uploadDate ?? null;
			const uploadedLabel = iso
				? formatDate(iso)
				: (video.uploadedAt ?? "‚Äî");
			return {
				id: video.id,
				title: video.title,
				author: video.author,
				duration: video.duration ?? "0:00",
				durationValue: video.duration,
				uploaded: uploadedLabel,
				uploadedValue: iso ? Date.parse(iso) : Number.NEGATIVE_INFINITY,
				views: formatViews(video.views),
				viewsValue:
					typeof video.views === "number" ? video.views : null,
				original: video,
			};
		}),
		sounds: soundLibrary.map((clip) => ({
			id: clip.id,
			title: clip.title,
			location: clip.location,
			recordist: clip.recordist,
			project: clip.relatedProject,
			captured: formatDate(clip.capturedOn),
			capturedValue: Date.parse(clip.capturedOn),
			duration: clip.duration,
			durationValue: clip.duration,
		})),
		members: users.map((user) => ({
			id: user.id,
			name: user.name,
			videos: user.stats?.videos ?? 0,
			followers: user.stats?.followers ?? 0,
			following: user.stats?.following ?? 0,
			joined: user.joinedAt ? formatDate(user.joinedAt) : "‚Äî",
			joinedValue: user.joinedAt
				? Date.parse(user.joinedAt)
				: Number.NEGATIVE_INFINITY,
		})),
		keywords: getKeywordsSummary(),
	});

	const totalRuntimeSeconds = $derived(
		tableData.videos.reduce(
			(total, video) =>
				total +
				(typeof video.durationValue === "number"
					? video.durationValue
					: 0),
			0,
		),
	);
	const uniqueContributors = $derived(
		new Set(
			tableData.videos
				.map((video) => video.author)
				.filter((author) => Boolean(author)),
		).size,
	);
	const lastUploadedTimestamp = $derived(
		tableData.videos.reduce((latest, video) => {
			if (Number.isFinite(video.uploadedValue)) {
				return Math.max(latest, video.uploadedValue);
			}
			return latest;
		}, Number.NEGATIVE_INFINITY),
	);

	const lastUpdated = $derived(
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "‚Äî",
	);
	const averageDurationLabel = $derived(() => {
		if (tableData.videos.length === 0) return "0m";
		const averageSeconds = Math.round(
			totalRuntimeSeconds / tableData.videos.length,
		);
		return formatRuntime(averageSeconds);
	});

	const latestLocations = $derived<LatestLocationPin[]>(() => {
		const pins: LatestLocationPin[] = [];
		for (const video of videos) {
			const locations = video.locations ?? [];
			if (!Array.isArray(locations) || locations.length === 0) continue;
			const timestampValue = getVideoTimestampValue(video);
			const isoCandidate =
				typeof (video.timestamp ?? video.uploadDate) === "string"
					? (video.timestamp ?? video.uploadDate)
					: null;
			const uploadedLabel =
				isoCandidate && !Number.isNaN(Date.parse(isoCandidate))
					? formatDate(isoCandidate)
					: typeof video.uploadedAt === "string"
						? video.uploadedAt
						: "‚Äî";
			locations.forEach((location, index) => {
				const coords = getLocationCoordinates(location);
				if (!coords) return;
				pins.push({
					id: `${video.id}-${index}`,
					videoId: video.id,
					videoTitle: video.title,
					videoAuthor: video.author,
					uploadedLabel,
					timestampValue,
					lat: coords.lat,
					lon: coords.lon,
					setting: location.setting ?? location.name,
					thumbnailUrl: video.thumbnailUrl,
				});
			});
		}
		return pins
			.sort((a, b) => b.timestampValue - a.timestampValue)
			.slice(0, 6);
	});

	const locationCenter = $derived<LocationCenter>(() => {
		if (latestLocations.length === 0) {
			return { lat: 20, lon: 0, zoom: 1.6 };
		}
		const totals = latestLocations.reduce(
			(acc, loc) => {
				acc.lat += loc.lat;
				acc.lon += loc.lon;
				return acc;
			},
			{ lat: 0, lon: 0 },
		);
		const lat = totals.lat / latestLocations.length;
		const lon = totals.lon / latestLocations.length;
		const zoom =
			latestLocations.length === 1
				? 5.5
				: latestLocations.length <= 3
					? 3.2
					: 2.4;
		return { lat, lon, zoom };
	});

	const heroMetrics = $derived([
		{
			label: "VIDEOS",
			value: tableData.videos.length.toString().padStart(2, "0"),
		},
		{
			label: "CURATORS",
			value: uniqueContributors.toString().padStart(2, "0"),
		},
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	]);

	const totalLikes = $derived(
		tableData.videos.reduce(
			(sum, video) => sum + (video.original.likes ?? 0),
			0,
		),
	);

	const profileStats = $derived({
		videos: tableData.videos.length,
		sounds: tableData.sounds.length,
		duration: formatRuntime(totalRuntimeSeconds),
		likes: totalLikes,
	});

	function getSortValue(
		row: any,
		tableKey: TableKey,
		key: string,
	): string | number {
		if (tableKey === "videos") {
			switch (key) {
				case "title":
					return row.title;
				case "author":
					return row.author;
				case "duration":
					return row.durationValue;
				case "uploaded":
					return row.uploadedValue;
				case "views":
					return row.viewsValue ?? -1;
				default:
					return "";
			}
		}
		if (tableKey === "sounds") {
			switch (key) {
				case "title":
					return row.title;
				case "recordist":
					return row.recordist;
				case "project":
					return row.project;
				case "captured":
					return row.capturedValue;
				case "duration":
					return row.durationValue;
				default:
					return "";
			}
		}
		if (tableKey === "members") {
			switch (key) {
				case "name":
					return row.name;
				case "videos":
					return row.videos;
				case "followers":
					return row.followers;
				case "following":
					return row.following;
				case "joined":
					return row.joinedValue;
				default:
					return "";
			}
		}
		if (tableKey === "keywords") {
			switch (key) {
				case "keyword":
					return row.keyword;
				case "usage":
					return row.usage;
				case "related":
					return row.related;
				default:
					return "";
			}
		}
		return "";
	}

	function sortRows(tableKey: TableKey) {
		const state = tableState[tableKey];
		if (!state) return [];
		const rows = [...(tableData[tableKey] as any[])];
		const direction = state.sortDirection === "asc" ? 1 : -1;

		return rows.sort((a, b) => {
			const aValue = getSortValue(a, tableKey, state.sortKey);
			const bValue = getSortValue(b, tableKey, state.sortKey);
			if (typeof aValue === "number" && typeof bValue === "number") {
				return (aValue - bValue) * direction;
			}
			const aStr = `${aValue ?? ""}`.toLowerCase();
			const bStr = `${bValue ?? ""}`.toLowerCase();
			return (
				aStr.localeCompare(bStr, undefined, {
					numeric: true,
					sensitivity: "base",
				}) * direction
			);
		});
	}

	function toggleSort(tableKey: TableKey, columnKey: string) {
		const current = tableState[tableKey];
		if (!current) return;
		if (current.sortKey === columnKey) {
			current.sortDirection =
				current.sortDirection === "asc" ? "desc" : "asc";
		} else {
			current.sortKey = columnKey;
			current.sortDirection = "asc";
		}
	}

	function openVideo(video: any, event?: MouseEvent) {
		if (event) {
			if (
				event.metaKey ||
				event.ctrlKey ||
				event.shiftKey ||
				event.button !== 0
			)
				return;
			event.preventDefault();
		}
		selectedVideo.selectVideo(video.id);
		// Keep in sidebar mode on home page
		actions.setExpanded(false);
	}

	function handleVideoRowKey(event: KeyboardEvent, video: any) {
		if (event.key === "Enter" || event.key === " ") {
			event.preventDefault();
			openVideo(video);
		}
	}

	const sortedVideoRows = $derived(sortRows("videos"));
	const sortedSoundRows = $derived(sortRows("sounds"));
	const sortedMemberRows = $derived(sortRows("members"));
	const sortedKeywordRows = $derived(sortRows("keywords"));
</script>

<svelte:head>
	<title>Media Dashboard ‚Äî Rushes</title>
	<meta
		name="description"
		content="Terminal overview of the Rushes archive."
	/>
</svelte:head>

<div
	class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200"
>
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<div
				class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"
			></div>
			<div
				class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"
			></div>
			<div
				class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-end md:justify-between"
			>
				<div class="min-w-0 space-y-3">
					<p
						class="text-[11px] uppercase tracking-[0.35em] text-slate-500"
					>
						Rushes.fm
					</p>
					<!-- <h1 class="text-2xl font-semibold text-white">
						Channel Overview
					</h1> -->
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						RUSHES.BE est une plateforme collective d√©di√©e aux cin√©astes bruxellois. Elle cartographie les rushes ‚Äî images non mont√©es, fragments de tournage ‚Äî pour nourrir une archive vivante, un espace de rencontre et un laboratoire d‚Äôexp√©rimentation visuelle.

					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div
							class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner"
						>
							<p
								class="text-[10px] uppercase tracking-[0.3em] text-slate-500"
							>
								{metric.label}
							</p>
							<p class="mt-2 text-lg font-semibold text-white">
								{metric.value}
							</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<div class="grid gap-8 lg:grid-cols-2">
			<div
				class="column-container space-y-8"
				aria-label="Primary dashboard column"
				use:dndzone={{
					items: itemsLeft,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateLeftColumn}
				on:finalize={updateLeftColumn}
			>
				{#each itemsLeft as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>

			<div
				class="column-container space-y-8"
				aria-label="Secondary dashboard column"
				use:dndzone={{
					items: itemsRight,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateRightColumn}
				on:finalize={updateRightColumn}
			>
				{#each itemsRight as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>
		</div>
	</div>
</div>

<style>
	.column-container {
		transition:
			background-color 0.2s ease,
			border-color 0.2s ease;
		border-radius: 0.5rem;
		border: 1px solid transparent;
		min-height: min-content;
	}
	:global(.dashboard-drop-target) {
		background-color: rgba(56, 189, 248, 0.05);
		border-color: rgba(56, 189, 248, 0.2);
	}
	.draggable-item[data-is-dnd-shadow-item-hint="true"] {
		opacity: 0.65;
	}
</style>
</file>

<file path="src/routes/+page.svelte.backup">
<script lang="ts">
</script>

<svelte:head>
  <title>rushes.fm - Global Video Archive</title>
  <meta name="description" content="A platform for finding and sharing unedited footage from users around the world. Discover connections through AI-powered content analysis." />
</svelte:head>

<div class="min-h-screen bg-white dark:bg-black">

</div>
</file>

<file path="src/routes/page copy.svelte">
<script lang="ts">
  import StatsSection from '$lib/components/home/StatsSection.svelte';
  import GeneratedChannels from '$lib/components/home/GeneratedChannels.svelte';
</script>

<svelte:head>
  <title>rushes.fm - Global Video Archive</title>
  <meta name="description" content="A platform for finding and sharing unedited footage from users around the world. Discover connections through AI-powered content analysis." />
</svelte:head>

<div class="min-h-screen bg-white dark:bg-black">
  <!-- Minimal Header -->
  <header class="border-b border-gray-100 dark:border-gray-900 bg-white/60 dark:bg-black/60 backdrop-blur-sm sticky top-0 z-10">
    <div class="mx-auto max-w-4xl px-6 py-3">
      <div class="flex items-center justify-between">
        <!-- Logo -->
        <a href="/" class="flex items-center gap-2 hover:opacity-80 transition-opacity">
          <div class="h-5 w-5 rounded bg-blue-600"></div>
          <span class="text-base font-medium text-gray-900 dark:text-white">rushes.fm</span>
        </a>

        <!-- Navigation -->
        <nav class="flex items-center gap-6 text-sm text-gray-600 dark:text-gray-400">
          <a href="/videos" class="hover:text-gray-900 dark:hover:text-white transition-colors">Browse</a>
          <a href="/keywords" class="hover:text-gray-900 dark:hover:text-white transition-colors">Keywords</a>
          <a href="/map" class="hover:text-gray-900 dark:hover:text-white transition-colors">Map</a>
          <a href="/about" class="hover:text-gray-900 dark:hover:text-white transition-colors">About</a>
        </nav>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="mx-auto max-w-5xl px-6 py-12">
    <!-- Hero Section -->
    <div class="text-center mb-16">
      <h1 class="text-4xl font-bold text-gray-900 dark:text-white mb-6">
        rushes.fm
      </h1>
      <div class="max-w-3xl mx-auto">
        <p class="text-lg text-gray-600 dark:text-gray-400 leading-relaxed mb-8">
          rushes.fm is a platform for finding and sharing unedited footage from users around the world.
          Vector embeddings allow the platform to find connections between clips based on the content of the footage,
          as well as metadata such as keywords, transcriptions and location information.
          Each week the platform generates a new channel based on the content uploaded from the prior seven days.
        </p>

        <!-- Action Buttons -->
        <div class="flex items-center justify-center gap-4 mb-12">
          <a
            href="/videos"
            class="rounded-full bg-blue-600 px-6 py-3 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
          >
            Browse Archive
          </a>
          <a
            href="/keywords"
            class="rounded-full border border-gray-300 dark:border-gray-600 px-6 py-3 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
          >
            Explore Keywords
          </a>
        </div>
      </div>
    </div>

    <!-- Generated Channels -->
    <GeneratedChannels />

    <!-- Account Creation CTA -->
    <div class="rounded-2xl bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-900 dark:to-gray-800 border border-gray-200 dark:border-gray-700 p-8 mb-16">
      <div class="text-center mb-8">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-3">
          Unlock the Full Archive Experience
        </h2>
        <p class="text-gray-600 dark:text-gray-400 max-w-2xl mx-auto">
          Create an account to access advanced features, contribute your footage, and build your personal video vault
        </p>
      </div>

      <!-- Benefits Grid -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Upload & Archive</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Upload your unedited footage to the global archive</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Auto-Transcription</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Automatic speech-to-text for searchable content</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-purple-100 dark:bg-purple-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Rich Metadata</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Location, keywords, and content analysis</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-orange-100 dark:bg-orange-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-orange-600 dark:text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Natural Language Search</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Search using everyday language and concepts</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-pink-100 dark:bg-pink-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-pink-600 dark:text-pink-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Create Channels</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Curate and subscribe to themed collections</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-indigo-100 dark:bg-indigo-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-indigo-600 dark:text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Personal Vault Export</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Download your data for local LLM RAG systems</p>
          </div>
        </div>
      </div>

      <!-- CTA Buttons -->
      <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
        <button class="w-full sm:w-auto rounded-full bg-blue-600 px-8 py-3 text-sm font-semibold text-white hover:bg-blue-500 transition-colors shadow-lg">
          Create Free Account
        </button>
        <button class="w-full sm:w-auto rounded-full border border-gray-300 dark:border-gray-600 px-8 py-3 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors">
          Learn More
        </button>
      </div>

      <!-- Trust Indicators -->
      <div class="mt-6 text-center">
        <p class="text-xs text-gray-500 dark:text-gray-400">
          Free account ‚Ä¢ No credit card required ‚Ä¢ Export your data anytime
        </p>
      </div>
    </div>
<!--  -->
  </main>

  <!-- Stats at Bottom -->
  <StatsSection />
</div>
</file>

<file path="src/app.css">
@import 'tailwindcss';
@plugin '@tailwindcss/forms';
@plugin '@tailwindcss/typography';

@theme {
  --color-white: 255 255 255;
  --color-black: 0 0 0;
  --color-gray-50: #f9fafb;
  --color-gray-100: #f3f4f6;
  --color-gray-200: #e5e7eb;
  --color-gray-300: #d1d5db;
  --color-gray-400: #9ca3af;
  --color-gray-500: #6b7280;
  --color-gray-600: #4b5563;
  --color-gray-700: #374151;
  --color-gray-800: #1f2937;
  --color-gray-900: #111827;
  --color-gray-950: #030712;
}
body {
    background: black;
    color: white;
}

@layer utilities {
  .border-white\/5 {
    border-color: rgb(255 255 255 / 0.05);
  }
  .border-white\/10 {
    border-color: rgb(255 255 255 / 0.1);
  }
  .border-white\/20 {
    border-color: rgb(255 255 255 / 0.2);
  }
  .bg-white\/5 {
    background-color: rgb(255 255 255 / 0.05);
  }
  .bg-white\/10 {
    background-color: rgb(255 255 255 / 0.1);
  }
  .bg-white\/20 {
    background-color: rgb(255 255 255 / 0.2);
  }
  .bg-black\/50 {
    background-color: rgb(0 0 0 / 0.5);
  }
  .bg-black\/60 {
    background-color: rgb(0 0 0 / 0.6);
  }
  .bg-black\/70 {
    background-color: rgb(0 0 0 / 0.7);
  }
  .bg-black\/20 {
    background-color: rgb(0 0 0 / 0.2);
  }
  .bg-black\/15 {
    background-color: rgb(0 0 0 / 0.15);
  }
}
</file>

<file path="src/app.d.ts">
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		// interface Platform {}
	}
}

export {};
</file>

<file path="src/app.html">
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
</file>

<file path="static/.assetsignore">
_worker.js
_routes.json
</file>

<file path="static/robots.txt">
# allow crawling everything by default
User-agent: *
Disallow:
</file>

<file path="static/rushes.svg">
<svg class="w-4 h-4 mr-2" style="display: inline-block; top: -10px !important; margin-top: 2px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45.5 53.6"><g fill-rule="nonzero" fill="none"><path d="M44.8 44.4c0-.2-.3-.4-.5-.5-.4-.4-1-1.3-1.2-1.2-.2-.3-.5-.3-.7-.5-.1-.2-.4-.4-.7-.4-.2-.3-.4-.5-.8-.7L36 37.3l-1-.7-1-1c-1-.4-1.7-1.2-2.5-1.8-.2-.3-.1-.5-.6-.7 0 0 0-.3-.2-.3-.2-.1-1-.5-1-.8 0-.3-.8-.7-1-.9-.1-.2-.5-.2-.7-.5l-.1-.4c-.2-.1-.4 0-.6-.2 2-.5 4-.6 5.8-1l3.7-.9c2-.4 4.2-1.2 6.3-1.3 1 0 1.5-1.2 1.6-2 0-.4-.1-.6-.3-.9 0 0-.2-1.2-.6-.6-.1-.2.2-.3 0-.6 0-.3-.3-.4-.6-.4l-.6-.4c-.4-.2-.8-.3-1.2-.2-.8 0-1.6 0-2.3.3-.7.4-1.6.5-2.4.7l-2.2.5c-.7 0-1.4.4-2.1.4-.8 0-1.6.4-2.3.5-.6.1-1.3 0-2 .3l.4-1c.2 0 .4-.8.5-1l.5-1.3c0 .6.3-.6.3-.3l.3-.6c0-.4.2-.5.3-.8.2-.3.5-.9.5-1.2 0-.3.4-.7.6-1l.4-.8.9-1.8c.4-.5.6-1.4 1-1.9.2-.1.5-.7.5-.9 0-.2.3-.4.5-.6a34.3 34.3 0 0 0 2-4c.2-.1.3-.7.5-1l.5-1.2v-.5c.1-.1.4-.1.3-.4l.3-1.2c.2-.6.1-.8-.4-1.2-.3-.2-.5-.2-.6-.6 0-.1 0-.4-.2-.5-.2-.3-1-.3-1.3-.3-.5-.5-1.1-.2-1.7-.3-.2 0-.4.2-.5.4-.2.1-.4 0-.7.2-.6.3-.6.7-.9 1.4l-.8 2.7c-.5.4-.8 1.8-1.1 2.4-.1.2-.3.7-.5.8l-.1.4-.5.7-.5 1.1c0 .3-.5.8-.5 1.2-.2 0-.3.6-.3.8-.2.1-.6.7-.5.8-.1.4-.5.7-.6 1l-.2.7c-.2 0-.5.4-.5.6 0 .9-1 1.5-1 2.3l-.6 1a5 5 0 0 1-.4 1l-.6 1.1c-.2.4-.3 1-.5 1.2l-.5.8-.2.9c-.3 0-.3.3-.4.5l-.7-1.1-1.1-1.2c-.2-.5-.8-.7-1-1 0-.3-.5-1-.8-1 .2-.1-1-1.4-1-1.4-.2-.7-.9-1.1-1.3-1.6l-2-2.5c-.3-.5-1.1-1-1.2-1.5 0-.4-.5-.3-.5-.6 0-.2-.3-.5-.5-.6-.2-.2-.7-.6-.8-1 0-.5-.9-.9-1.2-1.3C9.5 8.7 9.1 8 8.5 8s-.7-.5-1.4-.5c-1.4 0-3.4.6-3 2.4.1.8.7 1.3 1.2 1.8l1.5 1.7c.2.2.1.4.4.5l.9 1.1c.2.3.7 1.2 1.1 1.3l.7.9c.2.2.5.4.6.7 0 .3.2.1.3.3.2.3.5.9.8 1 0 .3.8 1.3 1 1.4.6.3.8 1 1.3 1.5.4.3.7.9 1 1.3.3.5.8 1 1.3 1.4 0 .3.2.5.4.6l.5.8-2.9.7c-.7.2-1.5.6-2.2.6-.6 0-1.4.3-2 .4l-2.4.6-1.5.3-2.5.5-2.3.5c-.9.2-1.3 1-1.3 1.8 0 .5.3 1.2.8 1.5.3.2 1.2.8 1.6.8l.8.6c.5.2 1.1 0 1.7 0l2.4-.5c2-.5 4-1 5.9-1.3 1.6-.3 3.2-1 4.9-1.3l-1 1.9L16 36l-.5 1.1c0 .3-.3.5-.3.8-.2.2-.5 1.3-.5 1.6-.2.1-.5.7-.5 1 0 .3-.3.4-.2.8-.3.2-.4.8-.6 1.1l-.7 1.8c-.3.5-.5 1.4-.9 1.8-.3.2-.4.7-.6 1-.2.4-.2 1-.7 1.3-.1 0 0 .3-.2.5l-.4.6c-.2.4-.6.7-.8 1.2-.1.2-.2 1 0 1.3.2.2.4.8.7.8.4.2 1 .2 1.4.5.5.4 1 .4 1.5.3.5-.1 1.1 0 1.7-.2.2 0 .5-.7.6-.8l.6-1 .4-1c0-.4.5-.7.6-1l.8-1.6.4-1 .4-.7 1-2.5c.3-.2.4-.8.5-1.2l.7-1.4c.3-.8.5-1.8 1-2.5l1.3-3.3 1.1-2.2c.5.4.7 1 1.1 1.2l.5.5c.3.2.4 0 .7.4.3.3.5.6.8.7.3.3.2.5.6.7.6.3 1 1 1.6 1.4l2.8 2.3c.4.3 1 .6 1.3 1 .2.5 1.2 1 1.7 1.2.4.4.9 1 1.3 1.2.3.2.7.8 1 .8 0 .3.3.3.4.3l.5.5c0 .2 1 .7 1.1.8l1.8 1c.4 0 2.3.4 2.4.2.6-.7 1.4 0 1.5-1 0-.5 1-.9.6-1.6 0-.3-.3-.2-.6-.3Z" fill="#000"></path><path d="m17.1 26.2-2.9.7c-.7.2-1.5.6-2.2.6-.6 0-1.4.3-2 .4l-2.4.6-1.5.3-2.5.5-2.3.5c-.9.2-1.3 1-1.3 1.8 0 .5.3 1.2.8 1.5.3.2 1.2.8 1.6.8l.8.6c.5.2 1.1 0 1.7 0l2.4-.5c2-.5 4-1 5.9-1.3 1.6-.3 3.2-1 4.9-1.3-.3.7-1.2-5.4-1-5.2Z" fill="#FF9011"></path><path d="M44.8 45.4c0-.2-.3-.4-.5-.5-.4-.4-1-1.3-1.2-1.2-.2-.3-.5-.3-.7-.5-.1-.2-.4-.4-.7-.4-.2-.3-.4-.5-.8-.7L36 38.3l-1-.7-1-1c-1-.4-1.7-1.2-2.5-1.8-.2-.3-.1-.5-.6-.7 0 0 0-.3-.2-.3-.2-.1-1-.5-1-.8 0-.3-.8-.7-1-.9-.1-.2-.5-.2-.7-.5l-.1-.4c-.2-.1-.4 0-.6-.2 2-.5-4 3.9-3.6 3.1.5.4.7 1 1.1 1.2l.5.5c.3.2.4 0 .7.4.3.3.5.6.8.7.3.3.2.5.6.7.6.3 1 1 1.6 1.4l2.8 2.3c.4.3 1 .6 1.3 1 .2.5 1.2 1 1.7 1.2.4.4.9 1 1.3 1.2.3.2.7.8 1 .8 0 .3.3.3.4.3l.5.5c0 .2 1 .7 1.1.8l1.8 1c.4 0 2.3.4 2.4.2.6-.7 1.4 0 1.5-1 0-.5 1-.9.6-1.6 0-.3-.3-.2-.6-.3Z" fill="#8A00C2"></path><path d="M19 31.4c-.2.7-.5 1.3-.9 1.9L17 36l-.5 1.1c0 .3-.3.5-.3.8-.2.2-.5 1.3-.5 1.6-.2.1-.5.7-.5 1 0 .3-.3.4-.2.8-.3.2-.4.8-.6 1.1l-.7 1.8c-.3.5-.5 1.4-.9 1.8-.3.2-.4.7-.6 1-.2.4-.2 1-.7 1.3-.1 0 0 .3-.2.5l-.4.6c-.2.4-.6.7-.8 1.2-.1.2-.2 1 0 1.3.2.2.4.8.7.8.4.2 1 .2 1.4.5.5.4 1 .4 1.5.3.5-.1 1.1 0 1.7-.2.2 0 .5-.7.6-.8l.6-1 .4-1c0-.4.5-.7.6-1l.8-1.6.4-1 .4-.7 1-2.5c.3-.2.4-.8.5-1.2l.7-1.4c.3-.8.5-1.8 1-2.5l1.3-3.3 1.1-2.2c.5.4-7.3-1.3-5.6-1.7Z" fill="#2CBF00"></path><path d="m27.3 29.2 5.8-1 3.7-.8c2-.4 4.2-1.2 6.3-1.3 1 0 1.5-1.2 1.6-2 0-.4-.1-.6-.3-1 0 0-.2-1.2-.6-.5-.1-.2.2-.3 0-.7 0-.3-.3-.4-.6-.4l-.6-.3-1.2-.3c-.8.1-1.6 0-2.3.4-.7.3-1.6.4-2.4.6l-2.2.6c-.7 0-1.4.4-2.1.4-.8 0-1.6.3-2.3.5-.6 0-1.3 0-2 .3 0-.2-.6 5.7-.8 5.5Z" fill="#1700FF"></path><path d="m28.5 23.5.5-1.1.5-1.3c0 .6.3-.6.3-.3l.3-.6c0-.4.2-.5.3-.8.2-.3.5-.9.5-1.2 0-.3.4-.7.6-1l.4-.8.9-1.8c.4-.5.6-1.4 1-1.9.2-.1.5-.7.5-.9 0-.2.3-.4.5-.6a34.3 34.3 0 0 0 2-4c.2-.1.3-.7.5-1l.5-1.2v-.5c.1-.1.4-.1.3-.4l.3-1.2c.2-.6.1-.8-.4-1.2-.3-.2-.5-.2-.6-.6 0-.1 0-.4-.2-.5-.2-.3-1-.3-1.3-.3-.5-.5-1.1-.2-1.7-.3-.2 0-.4.2-.5.4-.2.1-.4 0-.7.2-.6.3-.6.7-.9 1.4l-.8 2.7c-.5.4-.8 1.8-1.1 2.4-.1.2-.3.7-.5.8l-.1.4-.5.7-.5 1.1c0 .3-.5.8-.5 1.2-.2 0-.3.6-.3.8-.2.1-.6.7-.5.8-.1.4-.5.7-.6 1l-.2.7c-.2 0-.5.4-.5.6 0 .9-1 1.5-1 2.3l-.6 1a5 5 0 0 1-.4 1l-.6 1.1c-.2.4-.3 1-.5 1.2l-.5.8c-.1.3 6 1 6 .9Z" fill="red"></path><path d="M21 22.9c-.2-.3-.7-1-1-1.2-.2-.5-.8-.7-1-1 0-.3-.5-1-.8-1 .2-.1-1-1.4-1-1.4-.2-.7-.9-1.1-1.3-1.6l-2-2.5c-.3-.5-1.1-1-1.2-1.5 0-.4-.5-.3-.5-.6 0-.2-.3-.5-.5-.6-.2-.2-.7-.6-.8-1 0-.5-.9-.9-1.2-1.3C9.5 8.7 9.1 8 8.5 8s-.7-.5-1.4-.5c-1.4 0-3.4.6-3 2.4.1.8.7 1.3 1.2 1.8l1.5 1.7c.2.2.1.4.4.5l.9 1.1c.2.3.7 1.2 1.1 1.3l.7.9c.2.2.5.4.6.7 0 .3.2.1.3.3.2.3.5.9.8 1 0 .3.8 1.3 1 1.4.6.3.8 1 1.3 1.5.4.3.7.9 1 1.3.3.5.8 1 1.3 1.4 0 .3.2.5.4.6.2.3 4.7-2.2 4.5-2.5Z" fill="#FFF900"></path></g></svg>
</file>

<file path=".env.example">
# Replace with your DB credentials!
DATABASE_URL="postgres://user:password@host:port/db-name"
</file>

<file path=".gitignore">
node_modules

# Output
.output
.vercel
.netlify
.wrangler
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*

.dev.vars*
!.dev.vars.example
</file>

<file path=".npmrc">
engine-strict=true
</file>

<file path=".prettierignore">
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
bun.lock
bun.lockb

# Miscellaneous
/static/
/drizzle/
</file>

<file path=".prettierrc">
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	],
	"tailwindStylesheet": "./src/app.css"
}
</file>

<file path="drizzle.config.ts">
import { defineConfig } from 'drizzle-kit';
import 'dotenv/config';

if (!process.env.DATABASE_URL) throw new Error('DATABASE_URL is not set');

export default defineConfig({
	schema: './src/lib/server/db/schema.ts',
	dialect: 'postgresql',
	dbCredentials: {
		url: process.env.DATABASE_URL
	},
	verbose: true,
	strict: true
});
</file>

<file path="package.json">
{
	"name": "RUSHES",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "npm run build && wrangler dev",
		"prepare": "svelte-kit sync || echo ''",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"format": "prettier --write .",
		"lint": "prettier --check .",
		"test:unit": "vitest",
		"test": "npm run test:unit -- --run",
		"db:push": "drizzle-kit push",
		"db:generate": "drizzle-kit generate",
		"db:migrate": "drizzle-kit migrate",
		"db:studio": "drizzle-kit studio",
		"deploy": "npm run build && wrangler deploy",
		"cf-typegen": "wrangler types ./src/worker-configuration.d.ts"
	},
	"devDependencies": {
		"@sveltejs/adapter-cloudflare": "^7.2.4",
		"@sveltejs/kit": "^2.43.2",
		"@sveltejs/vite-plugin-svelte": "^6.2.0",
		"@tailwindcss/forms": "^0.5.10",
		"@tailwindcss/typography": "^0.5.18",
		"@tailwindcss/vite": "^4.1.13",
		"@types/node": "^22",
		"@vitest/browser": "^3.2.4",
		"drizzle-kit": "^0.31.4",
		"drizzle-orm": "^0.44.5",
		"playwright": "^1.55.1",
		"prettier": "^3.6.2",
		"prettier-plugin-svelte": "^3.4.0",
		"prettier-plugin-tailwindcss": "^0.6.14",
		"svelte": "^5.39.5",
		"svelte-check": "^4.3.2",
		"tailwindcss": "^4.1.13",
		"typescript": "^5.9.2",
		"vite": "^7.1.7",
		"vitest": "^3.2.4",
		"vitest-browser-svelte": "^1.1.0",
		"wrangler": "^4.44.0"
	},
	"dependencies": {
		"@neondatabase/serverless": "^1.0.2",
		"bits-ui": "^2.14.0",
		"depcheck": "^1.4.7",
		"dotenv": "^17.2.3",
		"global": "^4.4.0",
		"gsap": "^3.13.0",
		"hls-video-element": "^1.5.8",
		"mapbox-gl": "^3.12.0",
		"media-chrome": "^4.14.0",
		"postgres": "^3.4.7",
		"svelte-dnd-action": "^0.9.65"
	}
}
</file>

<file path="README.md">
# sv

Everything you need to build a Svelte project, powered by [`sv`](https://github.com/sveltejs/cli).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```sh
# create a new project in the current directory
npx sv create

# create a new project in my-app
npx sv create my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```sh
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```sh
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://svelte.dev/docs/kit/adapters) for your target environment.
</file>

<file path="svelte.config.js">
import adapter from '@sveltejs/adapter-cloudflare';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),
	kit: { adapter: adapter() }
};

export default config;
</file>

<file path="tsconfig.json">
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler",
		"types": [
			"./src/worker-configuration.d.ts"
		]
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// To make changes to top-level options such as include and exclude, we recommend extending
	// the generated config; see https://svelte.dev/docs/kit/configuration#typescript
}
</file>

<file path="vite.config.ts">
import tailwindcss from '@tailwindcss/vite';
import { defineConfig } from 'vitest/config';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
	plugins: [tailwindcss(), sveltekit()],
	test: {
		expect: { requireAssertions: true },
		projects: [
			{
				extends: './vite.config.ts',
				test: {
					name: 'client',
					environment: 'browser',
					browser: {
						enabled: true,
						provider: 'playwright',
						instances: [{ browser: 'chromium' }]
					},
					include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
					exclude: ['src/lib/server/**'],
					setupFiles: ['./vitest-setup-client.ts']
				}
			},
			{
				extends: './vite.config.ts',
				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: ['src/**/*.svelte.{test,spec}.{js,ts}']
				}
			}
		]
	}
});
</file>

<file path="vitest-setup-client.ts">
/// <reference types="@vitest/browser/matchers" />
/// <reference types="@vitest/browser/providers/playwright" />
</file>

<file path="wrangler.jsonc">
{
	"$schema": "node_modules/wrangler/config-schema.json",
	"name": "rushes",
	"pages_build_output_dir": ".svelte-kit/cloudflare",
	"compatibility_date": "2025-10-22",
	"compatibility_flags": ["nodejs_als", "nodejs_compat"],
	"observability": {
		"enabled": true
	}
}
</file>

<file path="wrangler.toml">
# This file configures your Cloudflare Pages project
name = "rushes"
compatibility_date = "2024-04-05" # Use a recent date

# This is the line that fixes the error
compatibility_flags = ["nodejs_compat"]
</file>

</files>
