This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.history/
  src/
    lib/
      components/
        Sidebar_20251028182444.svelte
        Sidebar_20251028192244.svelte
        Sidebar_20251028192303.svelte
        Sidebar_20251028192307.svelte
        VideoInfo_20251018164223.svelte
        VideoInfo_20251028192012.svelte
        VideoInfo_20251028192027.svelte
        VideoInfo_20251028192039.svelte
        VideoInfo_20251028192045.svelte
        VideoInfo_20251028192048.svelte
        VideoInfo_20251028192051.svelte
        VideoInfo_20251028192104.svelte
        VideoInfo_20251028192106.svelte
        VideoInfo_20251028192150.svelte
        VideoInfoContainer_20251018164107.svelte
        VideoInfoContainer_20251028192208.svelte
      server/
        db/
          users_20251017181528.ts
          users_20251023114327.ts
          videos_20251018153330.ts
          videos_20251023114416.ts
    routes/
      upload/
        +page.server_20251018123924.ts
        +page.server_20251023114733.ts
      +page_20251028185051.svelte
      +page_20251028185056.svelte
      +page_20251028185609.svelte
      +page_20251028185634.svelte
      +page_20251028185643.svelte
      +page_20251028185645.svelte
      +page_20251028185654.svelte
      +page_20251028185656.svelte
      +page_20251028185716.svelte
      +page_20251028185718.svelte
      +page_20251028185721.svelte
      +page_20251028185746.svelte
      +page_20251028185951.svelte
      +page_20251028190756.svelte
      +page_20251028190808.svelte
      +page_20251028190812.svelte
      +page_20251028190819.svelte
      +page_20251028190828.svelte
      +page_20251028190842.svelte
      +page_20251028190853.svelte
      +page_20251028190856.svelte
      +page_20251028190859.svelte
      +page_20251028190904.svelte
      +page_20251028190914.svelte
      +page_20251028190922.svelte
      +page_20251028190929.svelte
      +page_20251028190932.svelte
      +page_20251028190940.svelte
      +page_20251028190946.svelte
      +page_20251028190950.svelte
      +page_20251028190954.svelte
      +page_20251028191005.svelte
      +page_20251028191011.svelte
      +page_20251028191029.svelte
      +page_20251028191046.svelte
      +page_20251028191138.svelte
      +page_20251028191152.svelte
      +page_20251028191229.svelte
      +page_20251028191236.svelte
      +page_20251028191241.svelte
      +page_20251028191254.svelte
      +page_20251028191307.svelte
      +page_20251028191314.svelte
      +page_20251028191326.svelte
      +page_20251028191341.svelte
      +page_20251028191343.svelte
      +page_20251028191346.svelte
      +page_20251028191355.svelte
      +page_20251028191413.svelte
      +page_20251028191415.svelte
      +page_20251028191428.svelte
      +page_20251028191446.svelte
      +page_20251028191510.svelte
      +page_20251028191514.svelte
      +page_20251028191521.svelte
      +page_20251028191525.svelte
      +page_20251028191540.svelte
      +page_20251028191544.svelte
      +page_20251028191548.svelte
      +page_20251028191556.svelte
      +page_20251028191621.svelte
      +page_20251028191625.svelte
      +page_20251028191644.svelte
      +page_20251028191648.svelte
      +page_20251028191653.svelte
      +page_20251028191657.svelte
      +page_20251028191702.svelte
      +page_20251028191722.svelte
      +page_20251028191736.svelte
      +page_20251028191740.svelte
      +page_20251028191742.svelte
      +page_20251028191744.svelte
      +page_20251028191810.svelte
      +page_20251028191819.svelte
  package-lock_20251022225014.json
  package-lock_20251023113848.json
  package-lock_20251023113853.json
hyperdrive-tutorial/
  .vscode/
    settings.json
  src/
    index.ts
  test/
    env.d.ts
    index.spec.ts
    tsconfig.json
  .editorconfig
  .gitignore
  .prettierrc
  package.json
  tsconfig.json
  vitest.config.mts
  worker-configuration.d.ts
  wrangler.jsonc
src/
  lib/
    components/
      dashboard/
        DashboardPanel.svelte
      home/
        AuthSection.svelte
        FeaturedChannels.svelte
        GeneratedChannels.svelte
        HeroSection.svelte
        StatsSection.svelte
      Barcode.svelte
      CollapsibleHeading.svelte
      Header.svelte
      LocationPicker.svelte
      Map.svelte
      MuxVideoPlayer.svelte
      PersistentVideoPlayer.svelte
      Playing.svelte
      PlayingDesktopColumn.svelte
      QueueBanner.svelte
      Sidebar.svelte
      VideoCard.svelte
      VideoInfo.svelte
      VideoInfoContainer.svelte
      VideoPlayer.svelte
      VideoTimeline.svelte
    data/
      comments.ts
    server/
      db/
        index.ts
        schema.ts
        users.ts
        videos.ts
      invite-codes.ts
    stores/
      appStore.ts
      auth.ts
      library.ts
      playerStore.svelte.ts
      selectedVideo.ts
      theme.ts
      video.ts
    supabase/
      client.ts
      server.ts
    types/
      content.ts
      dashboard.ts
    utils/
      direct-load.ts
      waveform.ts
    workers/
      videoMetadata.worker.ts
    index.ts
  routes/
    account/
      upload/
        tus/
          +server.ts
        +page.server.ts
        +page.svelte
      +page.server.ts
      +page.svelte
    browse/
      [slug]/
        +page.svelte
      +page.svelte
    date/
      [slug]/
        +page.svelte
    faq/
      +page.svelte
    live/
      +page.svelte
    map/
      +page.svelte
    users/
      [id]/
        +page.svelte
      +page.svelte
    video/
      [id].svelte
      +page.svelte
    videos/
      [id]/
        +page.svelte
      +page.svelte
      +page.svelte.backup
    +layout.server.ts
    +layout.svelte
    +page.svelte
    +page.svelte.backup
    +page.svelte.dashboard-backup
    page copy.svelte
  app.css
  app.d.ts
  app.html
static/
  .assetsignore
  favicon.png
  logo.png
  logo2.png
  robots.txt
  rushes.svg
.env.example
.gitignore
.groupedtimelineinclude
.npmrc
.prettierignore
.prettierrc
agents.md
drizzle.config.ts
package.json
README.md
svelte.config.js
tsconfig.json
vite.config.ts
vitest-setup-client.ts
wrangler.jsonc
wrangler.toml
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/lib/components/QueueBanner.svelte">
<script lang="ts">
    import { slide } from "svelte/transition";
    import { selectedVideo } from "$lib/stores/selectedVideo";

    const queueContext = $derived($selectedVideo.queueContext);
    const currentVideoId = $derived($selectedVideo.id);
    const queue = $derived($selectedVideo.queue);

    const currentIndex = $derived.by(() => {
        const id = currentVideoId;
        const context = queueContext;
        const queueList = queue;
        
        if (!id || !context || !queueList.length) return 0;
        const index = queueList.indexOf(id);
        return index >= 0 ? index + 1 : 0;
    });

    const totalVideos = $derived.by(() => {
        return queueContext?.videoIds.length ?? 0;
    });

    const isLastVideo = $derived.by(() => {
        return currentIndex >= totalVideos;
    });

    const isFirstVideo = $derived.by(() => {
        return currentIndex <= 1;
    });

    function handleSkipForward() {
        if (isLastVideo) {
            // If on last video, skip forward = exit queue and resume live
            selectedVideo.clearQueueContext();
        } else {
            // Otherwise, go to next video in queue
            selectedVideo.playNext();
        }
    }

    function handleSkipBackward() {
        // Go to previous video (playPrevious handles wrapping)
        selectedVideo.playPrevious();
    }

    const contextText = $derived.by(() => {
        const context = queueContext;
        if (!context) return "";
        
        const index = currentIndex;
        const total = totalVideos;
        
        if (context.type === "keyword") {
            return `Playing videos ${index}/${total} from keyword "${context.label}"`;
        } else if (context.type === "date") {
            return `Playing videos ${index}/${total} from ${context.label}`;
        } else if (context.type === "user") {
            return `Playing videos ${index}/${total} from ${context.label}`;
        }
        return "";
    });

    function getContextIcon(): string {
        const context = queueContext;
        if (!context) return "";
        
        if (context.type === "keyword") {
            // Browse/search icon
            return `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M11 15a4 4 0 1 0 8 0a4 4 0 1 0-8 0m7.5 3.5L21 21M4 6h16M4 12h4m-4 6h4"/></svg>`;
        } else if (context.type === "date") {
            // Calendar icon
            return `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 2v4M16 2v4M3 10h18M5 4h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2z"/></svg>`;
        } else if (context.type === "user") {
            // Users icon
            return `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"><path d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"/><path d="M6.5 21a5.5 5.5 0 0111 0M19.5 8.25a2.25 2.25 0 110 4.5M21 21a3 3 0 00-4-2.82"/></svg>`;
        }
        return "";
    }

    function handleCancel() {
        selectedVideo.clearQueueContext();
    }
</script>

{#if queueContext}
    <div
        transition:slide={{ duration: 300, axis: 'y', easing: (t) => t * (2 - t) }}
        class="bg-black/40 border-b border-orange-500/10 px-4 py-2.5 flex items-center gap-3 backdrop-blur-sm"
    >
        <span class="text-orange-500/60 flex-shrink-0" aria-hidden="true">
            {@html getContextIcon()}
        </span>
        <p class="text-sm text-white/70 font-medium flex-1">
            {contextText}
        </p>
        <div class="flex items-center gap-1">
            <button
                onclick={handleSkipBackward}
                class="p-1 hover:bg-white/5 rounded transition-colors flex-shrink-0"
                aria-label="Previous video"
                title="Previous video"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    class="text-white/50 hover:text-white/80"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M15 19l-7-7 7-7"
                    />
                </svg>
            </button>
            <button
                onclick={handleSkipForward}
                class="p-1 hover:bg-white/5 rounded transition-colors flex-shrink-0"
                aria-label={isLastVideo ? "Exit queue and resume live" : "Next video"}
                title={isLastVideo ? "Exit queue and resume live" : "Next video"}
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    class="text-white/50 hover:text-white/80"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M9 5l7 7-7 7"
                    />
                </svg>
            </button>
            <button
                onclick={handleCancel}
                class="p-1 hover:bg-white/5 rounded transition-colors flex-shrink-0"
                aria-label="Cancel queue and resume normal queue"
                title="Cancel queue and resume normal queue"
            >
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="16"
                    height="16"
                    fill="none"
                    stroke="currentColor"
                    viewBox="0 0 24 24"
                    class="text-white/50 hover:text-white/80"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M6 18L18 6M6 6l12 12"
                    />
                </svg>
            </button>
        </div>
    </div>
{/if}
</file>

<file path="src/lib/server/invite-codes.ts">
import type { RequestEvent } from '@sveltejs/kit';

type EnvSource = Record<string, string | undefined> | undefined;

const ENV_KEYS = ['INVITE_CODES', 'ACCOUNT_INVITE_CODES'] as const;

function getEnv(event: Pick<RequestEvent, 'platform'>): EnvSource {
	const platformEnv = event.platform?.env as Record<string, string | undefined> | undefined;
	if (platformEnv) return platformEnv;
	if (typeof process !== 'undefined') {
		return process.env as Record<string, string | undefined>;
	}
	return undefined;
}

export function parseInviteCodes(raw: string | undefined): string[] {
	if (!raw) return [];
	return raw
		.split(/[,\s]+/)
		.map((code) => code.trim())
		.filter((code) => code.length > 0);
}

export function getInviteCodes(event: Pick<RequestEvent, 'platform'>): string[] {
	const env = getEnv(event);
	if (!env) return [];
	for (const key of ENV_KEYS) {
		const value = env[key];
		if (value) {
			return parseInviteCodes(value);
		}
	}
	return [];
}

export function inviteCodesEnabled(event: Pick<RequestEvent, 'platform'>): boolean {
	return getInviteCodes(event).length > 0;
}

export function validateInviteCode(
	event: Pick<RequestEvent, 'platform'>,
	code: string | undefined | null
): { valid: boolean; error?: string } {
	const trimmed = typeof code === 'string' ? code.trim() : '';
	const codes = getInviteCodes(event);

	if (codes.length === 0) {
		return {
			valid: false,
			error:
				'Invite codes are not configured. Please add INVITE_CODES to your environment to enable signups.'
		};
	}

	if (trimmed.length === 0) {
		return { valid: false, error: 'An invite code is required to create an account.' };
	}

	if (!codes.includes(trimmed)) {
		return { valid: false, error: 'Invalid invite code. Please check your code and try again.' };
	}

	return { valid: true };
}
</file>

<file path="src/lib/supabase/client.ts">
import { createBrowserClient } from '@supabase/ssr';
import { browser } from '$app/environment';

const SUPABASE_URL_KEY = 'PUBLIC_SUPABASE_URL';
const SUPABASE_ANON_KEY = 'PUBLIC_SUPABASE_ANON_KEY';

export function createSupabaseClient() {
	if (!browser) {
		throw new Error('createSupabaseClient can only be used in the browser');
	}

	const supabaseUrl = import.meta.env[SUPABASE_URL_KEY];
	const supabaseAnonKey = import.meta.env[SUPABASE_ANON_KEY];

	if (!supabaseUrl || !supabaseAnonKey) {
		throw new Error('Missing Supabase environment variables');
	}

	return createBrowserClient(supabaseUrl, supabaseAnonKey);
}
</file>

<file path="src/lib/supabase/server.ts">
import { createServerClient } from '@supabase/ssr';
import type { RequestEvent } from '@sveltejs/kit';

const SUPABASE_URL_KEY = 'PUBLIC_SUPABASE_URL';
const SUPABASE_ANON_KEY = 'PUBLIC_SUPABASE_ANON_KEY';

function resolveEnvValue(
	event: Pick<RequestEvent, 'platform'>,
	key: typeof SUPABASE_URL_KEY | typeof SUPABASE_ANON_KEY
): string | undefined {
	const platformEnv = event.platform?.env as Record<string, string | undefined> | undefined;
	if (platformEnv?.[key]) {
		return platformEnv[key];
	}

	if (typeof process !== 'undefined' && process.env?.[key]) {
		return process.env[key];
	}

	return undefined;
}

export function createSupabaseServerClient(event: RequestEvent) {
	const supabaseUrl = resolveEnvValue(event, SUPABASE_URL_KEY);
	const supabaseAnonKey = resolveEnvValue(event, SUPABASE_ANON_KEY);

	if (!supabaseUrl || !supabaseAnonKey) {
		throw new Error('Missing Supabase environment variables');
	}

	return createServerClient(supabaseUrl, supabaseAnonKey, {
		cookies: {
			get(key: string) {
				return event.cookies.get(key);
			},
			set(key: string, value: string, options) {
				event.cookies.set(key, value, { ...options, path: '/' });
			},
			remove(key: string, options) {
				event.cookies.delete(key, { ...options, path: '/' });
			}
		}
	});
}
</file>

<file path="src/lib/utils/direct-load.ts">
import { browser } from '$app/environment';
import { afterNavigate } from '$app/navigation';
import { onDestroy, onMount } from 'svelte';

export function trackDirectLoad(update: (wasDirect: boolean) => void) {
	if (!browser) {
		update(false);
		return;
	}

	let hasMounted = false;
	let pending: boolean | null = null;

	const dispatch = (value: boolean) => {
		if (hasMounted) {
			update(value);
		} else {
			pending = value;
		}
	};

	const unsubscribe = afterNavigate(({ from }) => {
		dispatch(!from);
	});

	onMount(() => {
		hasMounted = true;
		if (pending !== null) {
			update(pending);
			pending = null;
		}
	});

	onDestroy(() => {
		unsubscribe();
	});
}
</file>

<file path="src/routes/account/upload/tus/+server.ts">
import { json, error } from '@sveltejs/kit';
import type { RequestHandler } from './$types';

const TUS_ENDPOINT = 'https://video.bunnycdn.com/tusupload';

function resolveEnv(
	platformEnv: Record<string, string | undefined> | undefined,
	key: string
): string | undefined {
	return platformEnv?.[key] ?? process.env[key];
}

function buildStreamHost(hostname: string | undefined): string | null {
	if (!hostname) return null;
	const cleaned = hostname.replace(/^https?:\/\//, '').replace(/\/+$/, '');
	return cleaned.length ? cleaned : null;
}

async function sha256Hex(input: string): Promise<string> {
	const encoder = new TextEncoder();
	const data = encoder.encode(input);
	const cryptoApi = globalThis.crypto?.subtle;
	if (!cryptoApi) {
		throw new Error('Web Crypto API is not available in this environment.');
	}
	const digest = await cryptoApi.digest('SHA-256', data);
	const bytes = Array.from(new Uint8Array(digest));
	return bytes.map((b) => b.toString(16).padStart(2, '0')).join('');
}

export const POST: RequestHandler = async ({ request, platform, fetch }) => {
	const body = await request.json().catch(() => null);

	if (!body || typeof body !== 'object') {
		throw error(400, 'Invalid request payload');
	}

	const title = typeof body.title === 'string' && body.title.trim().length > 0 ? body.title.trim() : null;
	const collection =
		typeof body.collection === 'string' && body.collection.trim().length > 0 ? body.collection.trim() : undefined;
	const thumbnailTime =
		typeof body.thumbnailTime === 'number' && Number.isFinite(body.thumbnailTime)
			? Math.max(0, Math.floor(body.thumbnailTime))
			: undefined;

	if (!title) {
		throw error(400, 'Video title is required.');
	}

	const platformEnv = platform?.env as Record<string, string | undefined> | undefined;
	const libraryId = resolveEnv(platformEnv, 'BUNNY_VIDEO_LIBRARY_ID');
	const apiKey = resolveEnv(platformEnv, 'BUNNY_API_CODE');
	const cdnHost = buildStreamHost(resolveEnv(platformEnv, 'BUNNY_CDN_HOST_NAME'));

	if (!libraryId || !apiKey) {
		throw error(500, 'Bunny Stream environment variables are not configured.');
	}

	const createVideoResponse = await fetch(`https://video.bunnycdn.com/library/${libraryId}/videos`, {
		method: 'POST',
		headers: {
			'Content-Type': 'application/json',
			Accept: 'application/json',
			AccessKey: apiKey
		},
		body: JSON.stringify({
			title,
			collection,
			thumbnailTime
		})
	});

	if (!createVideoResponse.ok) {
		const message = await createVideoResponse
			.json()
			.catch(() => ({ message: createVideoResponse.statusText || 'Failed to create Bunny video.' }));
		console.error('Bunny create video failed:', message);
		throw error(502, 'Failed to create video on Bunny Stream.');
	}

	const createdVideo = (await createVideoResponse.json()) as {
		guid?: string;
		videoLibraryId?: number;
		id?: number;
	};

	const videoId = createdVideo?.guid;
	if (!videoId) {
		console.error('Unexpected Bunny create video response:', createdVideo);
		throw error(502, 'Bunny Stream did not return a video identifier.');
	}

	const expirationSeconds = Math.floor(Date.now() / 1000) + 60 * 60; // Allow uploads for 1 hour
	const signatureSource = `${libraryId}${apiKey}${expirationSeconds}${videoId}`;
	const signature = await sha256Hex(signatureSource);

	return json({
		videoId,
		expires: expirationSeconds,
		signature,
		libraryId,
		uploadUrl: TUS_ENDPOINT,
		cdnHost
	});
};
</file>

<file path="src/routes/account/upload/+page.server.ts">
// src/routes/account/upload/+page.server.ts

import { fail, redirect } from '@sveltejs/kit';
import type { Actions, PageServerLoad } from './$types';
import { getDb } from '$lib/server/db';
import { videos } from '$lib/server/db/schema';
import { nanoid } from 'nanoid';
import { createSupabaseServerClient } from '$lib/supabase/server';
import { ensureUserForAuth } from '$lib/server/db/users';

function resolveEnv(
	platformEnv: Record<string, string | undefined> | undefined,
	key: string
): string | undefined {
	return platformEnv?.[key] ?? process.env[key];
}

function buildStreamUrl(hostname: string | undefined, videoId: string | undefined): string | null {
	if (!hostname || !videoId) return null;
	const cleanedHost = hostname.replace(/^https?:\/\//, '').replace(/\/+$/, '');
	if (!cleanedHost) return null;
	return `https://${cleanedHost}/${videoId}/playlist.m3u8`;
}

export const load: PageServerLoad = async (event) => {
	const supabase = createSupabaseServerClient(event);
	const {
		data: { user },
		error
	} = await supabase.auth.getUser();

	if (error) {
		console.error('Failed to resolve authenticated user in upload load:', error);
	}

	if (!user) {
		const redirectTo = encodeURIComponent(event.url.pathname);
		throw redirect(303, `/account?redirectTo=${redirectTo}`);
	}

	const databaseUrl = event.platform?.env?.DATABASE_URL;
	if (!databaseUrl) {
		console.error('DATABASE_URL binding not found in load()');
		return {
			uploader: null,
			sessionUser: user
		};
	}

	const db = getDb(databaseUrl);
	const uploader = await ensureUserForAuth(db, user);

	return {
		uploader: {
			id: uploader.id,
			name: uploader.name,
			slug: uploader.slug,
			authId: uploader.authId ?? user.id
		},
		sessionUser: user
	};
};

export const actions: Actions = {
	upload: async (event) => {
		const supabase = createSupabaseServerClient(event);
		const {
			data: { user },
			error
		} = await supabase.auth.getUser();

		if (error) {
			console.error('Failed to resolve authenticated user in upload action:', error);
		}

		if (!user) {
			return fail(401, { error: 'You must be signed in to upload videos.' });
		}

		const databaseUrl = event.platform?.env?.DATABASE_URL;
		if (!databaseUrl) {
			console.error('DATABASE_URL binding not found in action()');
			return fail(500, { error: 'Database not configured.' });
		}

		const db = getDb(databaseUrl);
		const dbUser = await ensureUserForAuth(db, user);

		const formData = await event.request.formData();

		const title = formData.get('title') as string;
		const description = formData.get('description') as string;
		const uploadedAt = formData.get('uploadedAt') as string;
		const bunnyVideoId = (formData.get('bunnyVideoId') as string | null)?.trim() ?? '';
		const latitude = formData.get('latitude') as string;
		const longitude = formData.get('longitude') as string;
		const videoUrl = formData.get('videoUrl') as string;
		const thumbnailUrl = formData.get('thumbnailUrl') as string;
		const duration = formData.get('duration') as string;

		if (!title || title.trim().length === 0) {
			return fail(400, { error: 'Title is required', field: 'title' });
		}

		if (!description || description.trim().length === 0) {
			return fail(400, { error: 'Description is required', field: 'description' });
		}

		const wordCount = description.trim().split(/\s+/).length;
		if (wordCount > 300) {
			return fail(400, {
				error: `Description must be 300 words or less (currently ${wordCount} words)`,
				field: 'description'
			});
		}

		const platformEnv = event.platform?.env as Record<string, string | undefined> | undefined;
		const cdnHost = resolveEnv(platformEnv, 'BUNNY_CDN_HOST_NAME');

		let finalVideoUrl = videoUrl?.trim();
		if ((!finalVideoUrl || finalVideoUrl.length === 0) && bunnyVideoId) {
			const streamUrl = buildStreamUrl(cdnHost, bunnyVideoId);
			if (streamUrl) {
				finalVideoUrl = streamUrl;
			}
		}

		if (!finalVideoUrl || finalVideoUrl.length === 0) {
			return fail(400, {
				error: 'Video stream URL is required. Complete the upload before saving.',
				field: 'video'
			});
		}

		try {
			const videoId = nanoid(12);
			const durationNum = duration ? parseInt(duration) : 0;
			const lat = latitude ? parseFloat(latitude) : null;
			const lon = longitude ? parseFloat(longitude) : null;

			await db.insert(videos).values({
				id: videoId,
				title: title.trim(),
				description: description.trim(),
				userId: dbUser.id,
				videoUrl: finalVideoUrl,
				thumbnailUrl: thumbnailUrl?.trim() || null,
				duration: durationNum,
				uploadedAt: uploadedAt ? new Date(uploadedAt) : new Date(),
				latitude: lat,
				longitude: lon,
				views: 0,
				likes: 0,
				transcript: null
			});

			return {
				success: true,
				videoUrl: finalVideoUrl,
				bunnyVideoId,
				videoId
			};
		} catch (error) {
			console.error('Upload error:', error);
			return fail(500, {
				error: 'Failed to save video. Please try again.',
				details: error instanceof Error ? error.message : 'Unknown error'
			});
		}
	}
};
</file>

<file path="src/routes/account/upload/+page.svelte">
<script lang="ts">
    import { browser } from "$app/environment";
    import { enhance } from "$app/forms";
    import type { PageData, ActionData } from "./$types";
    import LocationPicker from "$lib/components/LocationPicker.svelte";
    import { goto } from "$app/navigation";
    import { onDestroy } from "svelte";
    import { Upload } from "tus-js-client";

    interface Props {
        data: PageData;
        form: ActionData;
    }

    const { data, form }: Props = $props();

    // Form state
    let videoFile = $state<File | null>(null);
    let title = $state("");
    let description = $state("");
    let uploadDate = $state("");
    let latitude = $state<number | undefined>(undefined);
    let longitude = $state<number | undefined>(undefined);
    let selectedThumbnail = $state<string>("");
    let videoUrl = $state(""); // This would be set after uploading to storage
    let duration = $state(0);

    // UI state
    let isProcessing = $state(false);
    let processingStatus = $state("");
    let thumbnails = $state<string[]>([]);
    let videoPreviewUrl = $state<string>("");
    let wordCount = $state(0);
    let isSubmitting = $state(false);
    let locationStatus = $state<"detecting" | "found" | "not-found" | null>(
        null,
    );

    // Worker for video processing
    let worker: Worker | null = null;

    // TUS upload state
    type UploadState = "idle" | "creating" | "uploading" | "paused" | "success" | "error";
    let tusUpload: Upload | null = null;
    let uploadStatus = $state<UploadState>("idle");
    let uploadError = $state<string | null>(null);
    let uploadProgress = $state(0);
    let bytesUploaded = $state(0);
    let totalBytes = $state(0);
    let bunnyVideoId = $state("");
    let cdnHostname = $state("");

    const uploaderDisplayName = $derived(
        data.uploader?.name ??
            data.sessionUser?.user_metadata?.name ??
            data.sessionUser?.email ??
            "Your account",
    );

    function buildStreamUrl(host: string, videoId: string) {
        const trimmedHost = host?.replace(/^https?:\/\//, "").replace(/\/+$/, "");
        if (!trimmedHost || !videoId) return "";
        return `https://${trimmedHost}/${videoId}/playlist.m3u8`;
    }

    async function resetTusUpload(options: { terminate?: boolean; clearVideoUrl?: boolean } = {}) {
        const { terminate = false, clearVideoUrl = true } = options;
        if (tusUpload) {
            try {
                await tusUpload.abort(terminate);
            } catch (error) {
                console.warn("Failed to abort resumable upload", error);
            }
            tusUpload = null;
        }

        uploadStatus = "idle";
        uploadError = null;
        uploadProgress = 0;
        bytesUploaded = 0;
        totalBytes = 0;
        bunnyVideoId = "";
        cdnHostname = "";

        if (clearVideoUrl) {
            videoUrl = "";
        }
    }

    function formatBytes(bytes: number) {
        if (!Number.isFinite(bytes) || bytes <= 0) return "0 MB";
        return `${(bytes / 1024 / 1024).toFixed(1)} MB`;
    }

    async function startTusUpload() {
        if (!browser || !videoFile) return;
        if (!data.uploader) {
            uploadError = "Your account isn't linked to a creator profile yet.";
            return;
        }
        if (uploadStatus === "uploading" || uploadStatus === "creating") return;
        if (uploadStatus === "paused" && tusUpload) {
            resumeTusUpload();
            return;
        }

        await resetTusUpload({ terminate: false, clearVideoUrl: true });
        uploadStatus = "creating";
        uploadError = null;
        totalBytes = videoFile.size;

        const inferredTitle =
            title?.trim().length && videoFile
                ? title.trim()
                : videoFile.name.replace(/\.[^/.]+$/, "").replace(/[_-]/g, " ");

        try {
            const response = await fetch("/account/upload/tus", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    title: inferredTitle,
                    fileType: videoFile.type,
                    thumbnailTime: Math.max(0, Math.round(duration * 1000)),
                }),
            });

            if (!response.ok) {
                const errorPayload = await response.json().catch(() => null);
                throw new Error(
                    errorPayload?.message ?? "Unable to initialise resumable upload.",
                );
            }

            const payload: {
                videoId: string;
                expires: number;
                signature: string;
                libraryId: string | number;
                uploadUrl: string;
                cdnHost?: string | null;
            } = await response.json();

            bunnyVideoId = payload.videoId;
            cdnHostname = payload.cdnHost ?? "";
            totalBytes = videoFile.size;

            tusUpload = new Upload(videoFile, {
                endpoint: payload.uploadUrl,
                retryDelays: [0, 3000, 5000, 10000, 20000, 60000],
                metadata: {
                    filetype: videoFile.type ?? "video/mp4",
                    title: inferredTitle,
                },
                headers: {
                    AuthorizationSignature: payload.signature,
                    AuthorizationExpire: String(payload.expires),
                    LibraryId: String(payload.libraryId),
                    VideoId: payload.videoId,
                },
                onError: (error) => {
                    uploadStatus = "error";
                    uploadError =
                        error?.message ?? "Upload failed. Please try again.";
                },
                onProgress: (uploadedBytes, total) => {
                    bytesUploaded = uploadedBytes;
                    totalBytes = total;
                    if (total > 0) {
                        uploadProgress = Math.max(
                            0,
                            Math.min(100, Math.round((uploadedBytes / total) * 100)),
                        );
                    }
                },
                onSuccess: () => {
                    uploadStatus = "success";
                    uploadError = null;
                    uploadProgress = 100;
                    if (cdnHostname && bunnyVideoId) {
                        videoUrl = buildStreamUrl(cdnHostname, bunnyVideoId);
                    }
                },
            });

            if (!tusUpload) {
                throw new Error("Failed to initialise resumable upload.");
            }

            const previousUploads = await tusUpload
                .findPreviousUploads()
                .catch(() => []);
            if (previousUploads && previousUploads.length > 0) {
                tusUpload.resumeFromPreviousUpload(previousUploads[0]);
            }

            uploadStatus = "uploading";
            tusUpload.start();
        } catch (error) {
            console.error("Failed to start resumable upload:", error);
            await resetTusUpload({ terminate: false, clearVideoUrl: true });
            uploadStatus = "error";
            uploadError =
                error instanceof Error
                    ? error.message
                    : "Failed to start upload. Please try again.";
        }
    }

    async function pauseTusUpload() {
        if (!tusUpload || uploadStatus !== "uploading") return;
        try {
            await tusUpload.abort();
            uploadStatus = "paused";
        } catch (error) {
            console.warn("Failed to pause upload", error);
        }
    }

    function resumeTusUpload() {
        if (!tusUpload || uploadStatus !== "paused") return;
        uploadStatus = "uploading";
        uploadError = null;
        tusUpload.start();
    }

    const uploadCompleted = $derived(
        uploadStatus === "success" && (Boolean(videoUrl) || Boolean(bunnyVideoId)),
    );
    const submitDisabled = $derived(
        isSubmitting || !uploadCompleted || isProcessing || !data.uploader,
    );


    $effect(() => {
        if (browser) {
            worker = new Worker(
                new URL(
                    "$lib/workers/videoMetadata.worker.ts",
                    import.meta.url,
                ),
                { type: "module" },
            );
            worker.onmessage = (e) => {
                const { type, metadata, error } = e.data;
                if (type === "metadata-result") {
                    if (metadata.date) {
                        try {
                            const date = new Date(metadata.date);
                            uploadDate = date.toISOString().split("T")[0];
                        } catch {
                            uploadDate = new Date().toISOString().split("T")[0];
                        }
                    } else {
                        uploadDate = new Date().toISOString().split("T")[0];
                    }
                    if (metadata.latitude && metadata.longitude) {
                        latitude = metadata.latitude;
                        longitude = metadata.longitude;
                        locationStatus = "found";
                    } else {
                        locationStatus = "not-found";
                    }
                } else if (type === "error") {
                    console.error("Worker error:", error);
                    isProcessing = false;
                    processingStatus = "Error processing video";
                    locationStatus = "not-found";
                }
            };
            // When on /account/upload, check for a preset file (from drag on /account)
            if ((window as any).__rushesUploadFile) {
                const presetFile = (window as any).__rushesUploadFile as File;
                delete (window as any).__rushesUploadFile;
                // Show preview and analyze file automatically
                (async () => {
                    await resetTusUpload({ terminate: true, clearVideoUrl: true });
                    videoFile = presetFile;
                    if (videoPreviewUrl?.startsWith("blob:")) {
                        URL.revokeObjectURL(videoPreviewUrl);
                    }
                    videoPreviewUrl = URL.createObjectURL(videoFile);
                    isProcessing = true;
                    processingStatus = "Analyzing video...";
                    locationStatus = "detecting";
                    const buffer = await videoFile.arrayBuffer();
                    worker?.postMessage({
                        type: "extract-metadata",
                        buffer,
                        lastModified: videoFile.lastModified,
                    });
                    await extractVideoDurationAndThumbnails(videoFile);
                    if (!title) {
                        title = videoFile.name.replace(/\.[^/.]+$/, "").replace(/[_-]/g, " ");
                    }
                    videoUrl = "";
                })();
            }
            return () => {
                worker?.terminate();
            };
        }
    });

    async function extractVideoDurationAndThumbnails(file: File) {
        try {
            const videoUrl = URL.createObjectURL(file);
            const video = document.createElement("video");
            video.preload = "metadata";
            video.muted = true;
            video.playsInline = true;
            video.src = videoUrl;

            await new Promise<void>((resolve, reject) => {
                video.onloadedmetadata = () => resolve();
                video.onerror = () => reject(new Error("Failed to load video"));
            });

            duration = Math.round(video.duration);

            // Generate thumbnails
            processingStatus = "Generating thumbnails...";
            const videoDuration = video.duration;
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");

            if (ctx) {
                const aspectRatio = video.videoHeight / video.videoWidth;
                canvas.width = 320;
                canvas.height = Math.round(320 * aspectRatio);

                const thumbCount = 5;
                const generatedThumbs: string[] = [];

                for (let i = 0; i < thumbCount; i++) {
                    const timestamp =
                        (videoDuration / (thumbCount + 1)) * (i + 1);
                    video.currentTime = timestamp;

                    await new Promise<void>((resolve) => {
                        video.onseeked = () => resolve();
                    });

                    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                    const dataUrl = canvas.toDataURL("image/jpeg", 0.8);
                    generatedThumbs.push(dataUrl);
                }

                thumbnails = generatedThumbs;
                if (thumbnails.length > 0) {
                    selectedThumbnail = thumbnails[0];
                }
            }

            URL.revokeObjectURL(videoUrl);
            isProcessing = false;
            processingStatus = "";
        } catch (error) {
            console.error("Error extracting video data:", error);
            isProcessing = false;
            processingStatus = "Error processing video";
        }
    }

    async function handleFileSelect(event: Event) {
        const input = event.target as HTMLInputElement;
        const file = input.files?.[0];

        if (file) {
            await resetTusUpload({ terminate: true, clearVideoUrl: true });

            if (videoPreviewUrl?.startsWith("blob:")) {
                URL.revokeObjectURL(videoPreviewUrl);
            }

            videoFile = file;
            videoPreviewUrl = URL.createObjectURL(file);

            // Extract metadata from video
            isProcessing = true;
            processingStatus = "Analyzing video...";
            locationStatus = "detecting";

            // Send buffer to worker for location extraction
            const buffer = await file.arrayBuffer();
            worker?.postMessage({
                type: "extract-metadata",
                buffer,
                lastModified: file.lastModified,
            });

            // Extract duration and thumbnails in main thread
            await extractVideoDurationAndThumbnails(file);

            // Set default title from filename
            if (!title) {
                title = file.name
                    .replace(/\.[^/.]+$/, "")
                    .replace(/[_-]/g, " ");
            }

            // Reset stream URL until upload completes
            totalBytes = file.size;
            bytesUploaded = 0;
            videoUrl = "";
            uploadStatus = "idle";
            uploadError = null;
            uploadProgress = 0;
        }
    }

    function handleLocationChange(lat: number, lon: number) {
        latitude = lat;
        longitude = lon;
    }

    function selectThumbnail(thumb: string) {
        selectedThumbnail = thumb;
    }

    function updateWordCount() {
        const words = description.trim().split(/\s+/).filter(Boolean);
        wordCount = words.length;
    }

    $effect(() => {
        updateWordCount();
    });

    function handleSubmit() {
        if (!uploadCompleted) {
            uploadError =
                uploadStatus === "error"
                    ? uploadError
                    : "Please finish uploading the video before saving.";
        }
        if (!data.uploader) {
            uploadError = "Your account isn't linked to a creator profile yet.";
            return async () => {};
        }
        isSubmitting = true;
        return async ({ result, update }: any) => {
            isSubmitting = false;

            if (result.type === "success" && result.data?.success) {
                // Redirect to the video page or library
                goto(`/account?uploaded=${result.data.videoId}`).catch(() => {
                    goto("/account");
                });
            } else {
                await update();
            }
        };
    }

    onDestroy(() => {
        if (browser && videoPreviewUrl?.startsWith("blob:")) {
            URL.revokeObjectURL(videoPreviewUrl);
        }
        resetTusUpload({ terminate: true, clearVideoUrl: false }).catch(() => {});
    });
</script>

<svelte:head>
    <title>Upload Video</title>
</svelte:head>

<div class="page">
    <form
        method="POST"
        action="?/upload"
        class="card"
        use:enhance={handleSubmit}
        enctype="multipart/form-data"
    >
        <header>
            <h1>Upload Video</h1>
            <p>Share your video with the world. Fill in the details below.</p>
        </header>

        {#if form?.error}
            <div class="error-banner">
                <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                    <path
                        d="M10 18C14.4183 18 18 14.4183 18 10C18 5.58172 14.4183 2 10 2C5.58172 2 2 5.58172 2 10C2 14.4183 5.58172 18 10 18Z"
                        stroke="currentColor"
                        stroke-width="2"
                    />
                    <path
                        d="M10 6V10"
                        stroke="currentColor"
                        stroke-width="2"
                        stroke-linecap="round"
                    />
                    <circle cx="10" cy="13" r="1" fill="currentColor" />
                </svg>
                <span>{form.error}</span>
            </div>
        {/if}

        <!-- Video File Picker -->
        <div class="form-group">
            <label for="video-file" class="label">Video File *</label>
            <div class="file-input-wrapper">
                <label class="file-picker" class:has-file={videoFile}>
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none">
                        <path
                            d="M21 15V19C21 19.5304 20.7893 20.0391 20.4142 20.4142C20.0391 20.7893 19.5304 21 19 21H5C4.46957 21 3.96086 20.7893 3.58579 20.4142C3.21071 20.0391 3 19.5304 3 19V15"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        />
                        <path
                            d="M17 8L12 3L7 8"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        />
                        <path
                            d="M12 3V15"
                            stroke="currentColor"
                            stroke-width="2"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                        />
                    </svg>
                    <span
                        >{videoFile
                            ? videoFile.name
                            : "Choose a video file"}</span
                    >
                    <input
                        id="video-file"
                        type="file"
                        accept="video/*"
                        onchange={handleFileSelect}
                        name="localVideoFile"
                    />
                </label>
                {#if videoFile}
                    <div class="file-info">
                        <span class="file-size"
                            >{(videoFile.size / 1024 / 1024).toFixed(2)} MB</span
                        >
                        {#if duration > 0}
                            <span class="file-duration"
                                >{Math.floor(duration / 60)}:{(duration % 60)
                                    .toString()
                                    .padStart(2, "0")}</span
                            >
                        {/if}
                    </div>
                    <div class="upload-panel">
                        <div class="upload-actions">
                            {#if uploadStatus === "idle"}
                                <button
                                    type="button"
                                    class="upload-btn"
                                    onclick={startTusUpload}
                                    disabled={!data.uploader}
                                >
                                    Start Upload
                                </button>
                                <span class="upload-hint"
                                    >Uploads are resumable — you can pause and continue later.</span
                                >
                            {:else if uploadStatus === "creating"}
                                <div class="upload-status in-progress">
                                    <div class="spinner-small"></div>
                                    <span>Preparing secure upload...</span>
                                </div>
                            {:else if uploadStatus === "uploading"}
                                <button type="button" class="upload-btn" onclick={pauseTusUpload}>
                                    Pause
                                </button>
                                <span class="upload-hint">Uploading… {uploadProgress}%</span>
                            {:else if uploadStatus === "paused"}
                                <button type="button" class="upload-btn" onclick={resumeTusUpload}>
                                    Resume Upload
                                </button>
                                <span class="upload-hint">Upload paused at {uploadProgress}%.</span>
                            {:else if uploadStatus === "success"}
                                <span class="upload-hint success"
                                    >Upload complete. You can now save this video.</span
                                >
                            {:else if uploadStatus === "error"}
                                <span class="upload-hint error">Upload failed.</span>
                                <button type="button" class="upload-btn" onclick={startTusUpload}>
                                    Retry Upload
                                </button>
                            {/if}
                        </div>
                        {#if uploadStatus !== "idle" || uploadProgress > 0}
                            <div
                                class="upload-progress-bar"
                                role="progressbar"
                                aria-valuemin="0"
                                aria-valuemax="100"
                                aria-valuenow={Math.min(100, uploadProgress)}
                            >
                                <div
                                    class="upload-progress-fill"
                                    style={`width: ${Math.min(100, uploadProgress)}%`}
                                ></div>
                            </div>
                            <div class="upload-progress-meta">
                                <span>{uploadProgress}%</span>
                                <span>{formatBytes(bytesUploaded)} / {formatBytes(totalBytes)}</span>
                            </div>
                        {/if}
                        {#if uploadStatus === "error" && uploadError}
                            <p class="upload-error">{uploadError}</p>
                        {/if}
                    </div>
                {/if}
            </div>
            {#if isProcessing}
                <div class="processing-status">
                    <div class="spinner"></div>
                    <span>{processingStatus}</span>
                </div>
            {/if}
        </div>

        <!-- Video Preview -->
        {#if videoPreviewUrl && !isProcessing}
            <div class="form-group">
                <label class="label" for="video-preview">Preview</label>
                <video id="video-preview" class="video-preview" src={videoPreviewUrl} controls>
                    <track kind="captions" label="No captions" />
                </video>
            </div>
        {/if}

        <!-- Title -->
        <div class="form-group">
            <label for="title" class="label">Title *</label>
            <input
                id="title"
                name="title"
                type="text"
                class="input"
                bind:value={title}
                placeholder="Enter video title"
                required
                maxlength="200"
            />
        </div>

        <!-- Uploader -->
        <div class="form-group">
            <label class="label" for="uploader-pill">Uploading as</label>
            <div id="uploader-pill" class="uploader-pill">
                <span class="uploader-avatar">{uploaderDisplayName.slice(0, 1).toUpperCase()}</span>
                <div class="uploader-details">
                    <span class="uploader-name">{uploaderDisplayName}</span>
                    {#if data.sessionUser?.email}
                        <span class="uploader-email">{data.sessionUser.email}</span>
                    {/if}
                </div>
            </div>
            {#if !data.uploader}
                <p class="warning">
                    We couldn&apos;t link your account to a creator profile. Please contact support before uploading.
                </p>
            {/if}
        </div>

        <!-- Upload Date -->
        <div class="form-group">
            <label for="uploadDate" class="label">Upload Date</label>
            <input
                id="uploadDate"
                name="uploadedAt"
                type="date"
                class="input"
                bind:value={uploadDate}
            />
            <p class="hint">
                Automatically detected from video metadata when available
            </p>
        </div>

        <!-- Location Status -->
        {#if locationStatus}
            <div class="form-group">
                {#if locationStatus === "detecting"}
                    <div class="location-status detecting">
                        <div class="spinner-small"></div>
                        <span>Detecting location from video metadata...</span>
                    </div>
                {:else if locationStatus === "found"}
                    <div class="location-status found">
                        <svg
                            width="20"
                            height="20"
                            viewBox="0 0 20 20"
                            fill="none"
                        >
                            <path
                                d="M10 2C7.24 2 5 4.24 5 7c0 3.75 5 11 5 11s5-7.25 5-11c0-2.76-2.24-5-5-5zm0 7c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z"
                                fill="currentColor"
                            />
                        </svg>
                        <span
                            >Location found: {latitude?.toFixed(6)}, {longitude?.toFixed(
                                6,
                            )}</span
                        >
                    </div>
                {:else if locationStatus === "not-found"}
                    <div class="location-status not-found">
                        <svg
                            width="20"
                            height="20"
                            viewBox="0 0 20 20"
                            fill="none"
                        >
                            <circle
                                cx="10"
                                cy="10"
                                r="8"
                                stroke="currentColor"
                                stroke-width="2"
                            />
                            <path
                                d="M10 6v4M10 14h.01"
                                stroke="currentColor"
                                stroke-width="2"
                                stroke-linecap="round"
                            />
                        </svg>
                        <span
                            >No location found in video metadata. You can set it
                            manually below.</span
                        >
                    </div>
                {/if}
            </div>
        {/if}

        <!-- Description -->
        <div class="form-group">
            <label for="description" class="label">
                Description *
                <span class="word-counter" class:over-limit={wordCount > 300}>
                    {wordCount} / 300 words
                </span>
            </label>
            <textarea
                id="description"
                name="description"
                class="textarea"
                bind:value={description}
                placeholder="Describe your video... (max 300 words)"
                required
                rows="6"
            ></textarea>
        </div>

        <!-- Thumbnail Picker -->
        {#if thumbnails.length > 0}
            <div class="form-group">
                <fieldset>
                    <legend class="label">Select Thumbnail</legend>
                    <div class="thumbnail-grid">
                        {#each thumbnails as thumb, i}
                            <button
                                type="button"
                                class="thumbnail-option"
                                class:selected={selectedThumbnail === thumb}
                                onclick={() => selectThumbnail(thumb)}
                                aria-label={`Select Thumbnail ${i+1}`}
                            >
                                <img src={thumb} alt="Thumbnail {i + 1}" />
                                {#if selectedThumbnail === thumb}
                                    <div class="selected-indicator">
                                        <svg
                                            width="24"
                                            height="24"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                        >
                                            <circle
                                                cx="12"
                                                cy="12"
                                                r="10"
                                                fill="currentColor"
                                            />
                                            <path
                                                d="M8 12L11 15L16 9"
                                                stroke="white"
                                                stroke-width="2"
                                                stroke-linecap="round"
                                                stroke-linejoin="round"
                                            />
                                        </svg>
                                    </div>
                                {/if}
                            </button>
                        {/each}
                    </div>
                </fieldset>
            </div>
        {/if}

        <!-- Location Picker -->
        <div class="form-group">
            <label class="label" for="location-map">
                Location
                {#if latitude && longitude}
                    <span class="location-detected">📍 Location set</span>
                {/if}
            </label>
            <p class="hint">
                Click on the map to set the video location. Use the geolocation
                button to use your current location.
            </p>
            <LocationPicker
                {latitude}
                {longitude}
                onLocationChange={handleLocationChange}
            />
        </div>

        <!-- Hidden fields for submission -->
        <input type="hidden" name="latitude" value={latitude ?? ""} />
        <input type="hidden" name="longitude" value={longitude ?? ""} />
        <input type="hidden" name="videoUrl" value={videoUrl} />
        <input type="hidden" name="thumbnailUrl" value={selectedThumbnail} />
        <input type="hidden" name="duration" value={duration} />
        <input type="hidden" name="bunnyVideoId" value={bunnyVideoId} />

        <!-- Submit Button -->
        <div class="form-actions">
            <button type="submit" class="submit-btn" disabled={submitDisabled}>
                {#if isSubmitting}
                    <div class="spinner"></div>
                    <span>Uploading...</span>
                {:else if isProcessing}
                    <span>Processing video...</span>
                {:else if !uploadCompleted}
                    <span>Finish Video Upload</span>
                {:else}
                    <span>Save Video</span>
                {/if}
            </button>
        </div>
    </form>
</div>

<style>
    .page {
        height: 100vh;
        padding: 4rem 1.5rem;
        background:
            radial-gradient(
                circle at top,
                rgba(8, 47, 73, 0.4),
                transparent 55%
            ),
            rgba(2, 6, 23, 0.94);
        display: flex;
        align-items: flex-start;
        justify-content: center;
    }

    .card {
        width: min(800px, 100%);
        background: rgba(15, 23, 42, 0.9);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 20px;
        padding: 2.5rem;
        box-shadow: 0 40px 120px -60px rgba(15, 118, 226, 0.45);
        display: grid;
        gap: 2rem;
        color: #e2e8f0;
        margin-bottom: 4rem;
    }

    header h1 {
        font-size: 1.8rem;
        margin: 0;
        color: #f8fafc;
    }

    header p {
        margin: 0.6rem 0 0;
        color: rgba(226, 232, 240, 0.8);
        font-size: 0.95rem;
        line-height: 1.4;
    }

    .error-banner {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 1rem 1.25rem;
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.3);
        border-radius: 12px;
        color: #fca5a5;
        font-size: 0.9rem;
    }

    .error-banner svg {
        flex-shrink: 0;
    }

    .form-group {
        display: grid;
        gap: 0.75rem;
    }

    .label {
        font-size: 0.9rem;
        font-weight: 500;
        color: #f8fafc;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .hint {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.6);
        margin: -0.25rem 0 0;
    }

    .file-input-wrapper {
        display: grid;
        gap: 0.75rem;
    }

    .file-picker {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 1.5rem 1.75rem;
        border-radius: 12px;
        border: 2px dashed rgba(94, 234, 212, 0.3);
        background: rgba(94, 234, 212, 0.05);
        color: #5eead4;
        font-size: 0.95rem;
        font-weight: 500;
        cursor: pointer;
        transition:
            border-color 0.2s ease,
            background 0.2s ease,
            transform 0.2s ease;
        width: 100%;
    }

    .file-picker:hover {
        border-color: rgba(94, 234, 212, 0.5);
        background: rgba(94, 234, 212, 0.1);
        transform: translateY(-1px);
    }

    .file-picker.has-file {
        border-color: rgba(94, 234, 212, 0.5);
        background: rgba(94, 234, 212, 0.12);
    }

    .file-picker input {
        display: none;
    }

    .file-info {
        display: flex;
        gap: 1rem;
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.7);
    }

    .file-size,
    .file-duration {
        padding: 0.25rem 0.75rem;
        background: rgba(30, 41, 59, 0.6);
        border-radius: 6px;
        font-variant-numeric: tabular-nums;
    }

    .upload-panel {
        display: grid;
        gap: 0.75rem;
        margin-top: 1rem;
        padding: 1rem 1.25rem;
        border-radius: 12px;
        background: rgba(37, 99, 235, 0.12);
        border: 1px solid rgba(59, 130, 246, 0.2);
    }

    .upload-actions {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: 0.75rem;
    }

    .upload-btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        padding: 0.55rem 1.2rem;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.25);
        border: 1px solid rgba(59, 130, 246, 0.4);
        color: #bfdbfe;
        font-size: 0.85rem;
        font-weight: 500;
        transition:
            background 0.2s ease,
            border-color 0.2s ease,
            transform 0.2s ease;
        cursor: pointer;
    }

    .upload-btn:hover {
        background: rgba(59, 130, 246, 0.35);
        border-color: rgba(59, 130, 246, 0.55);
        transform: translateY(-1px);
    }

    .upload-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
    }

    .upload-hint {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.7);
    }

    .upload-hint.success {
        color: #5eead4;
    }

    .upload-hint.error {
        color: #fca5a5;
    }

    .upload-progress-bar {
        position: relative;
        height: 0.5rem;
        border-radius: 999px;
        background: rgba(148, 163, 184, 0.2);
        overflow: hidden;
    }

    .upload-progress-fill {
        position: absolute;
        inset: 0;
        width: 0%;
        background: linear-gradient(90deg, #60a5fa, #38bdf8);
        transition: width 0.2s ease;
    }

    .upload-progress-meta {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        gap: 0.75rem;
        font-size: 0.8rem;
        color: rgba(226, 232, 240, 0.7);
    }

    .upload-error {
        margin: 0;
        font-size: 0.85rem;
        color: #fca5a5;
    }

    .upload-status {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        font-size: 0.85rem;
    }

    .upload-status.in-progress {
        color: #93c5fd;
    }

    .uploader-pill {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border-radius: 12px;
        border: 1px solid rgba(94, 234, 212, 0.25);
        background: rgba(94, 234, 212, 0.08);
    }

    .uploader-avatar {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 2.5rem;
        height: 2.5rem;
        border-radius: 999px;
        background: rgba(94, 234, 212, 0.2);
        color: #5eead4;
        font-weight: 600;
        font-size: 1rem;
    }

    .uploader-details {
        display: flex;
        flex-direction: column;
        gap: 0.15rem;
    }

    .uploader-name {
        font-size: 0.95rem;
        font-weight: 600;
        color: #f8fafc;
    }

    .uploader-email {
        font-size: 0.8rem;
        color: rgba(226, 232, 240, 0.6);
    }

    .warning {
        margin: 0.4rem 0 0;
        font-size: 0.8rem;
        color: #fca5a5;
    }

    .processing-status {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid rgba(59, 130, 246, 0.3);
        border-radius: 8px;
        color: #93c5fd;
        font-size: 0.875rem;
    }

    .spinner {
        width: 1rem;
        height: 1rem;
        border: 2px solid rgba(94, 234, 212, 0.3);
        border-top-color: #5eead4;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
    }

    .spinner-small {
        width: 0.875rem;
        height: 0.875rem;
        border: 2px solid rgba(94, 234, 212, 0.3);
        border-top-color: #5eead4;
        border-radius: 50%;
        animation: spin 0.8s linear infinite;
        flex-shrink: 0;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .location-status {
        display: flex;
        align-items: center;
        gap: 0.75rem;
        padding: 0.75rem 1rem;
        border-radius: 8px;
        font-size: 0.875rem;
    }

    .location-status.detecting {
        background: rgba(59, 130, 246, 0.1);
        border: 1px solid rgba(59, 130, 246, 0.3);
        color: #93c5fd;
    }

    .location-status.found {
        background: rgba(94, 234, 212, 0.1);
        border: 1px solid rgba(94, 234, 212, 0.3);
        color: #5eead4;
    }

    .location-status.not-found {
        background: rgba(251, 191, 36, 0.1);
        border: 1px solid rgba(251, 191, 36, 0.3);
        color: #fbbf24;
    }

    .location-status svg {
        flex-shrink: 0;
    }

    .video-preview {
        width: 100%;
        max-height: 400px;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.5);
    }

    .input,
    .textarea {
        width: 100%;
        padding: 0.75rem 1rem;
        background: rgba(30, 41, 59, 0.6);
        border: 1px solid rgba(148, 163, 184, 0.2);
        border-radius: 8px;
        color: #f8fafc;
        font-size: 0.95rem;
        font-family: inherit;
        transition:
            border-color 0.2s ease,
            background 0.2s ease;
    }

    .input:focus,
    .textarea:focus {
        outline: none;
        border-color: rgba(94, 234, 212, 0.5);
        background: rgba(30, 41, 59, 0.8);
    }

    .textarea {
        resize: vertical;
        min-height: 120px;
        line-height: 1.5;
    }

    select.input {
        cursor: pointer;
    }

    .word-counter {
        font-size: 0.85rem;
        color: rgba(226, 232, 240, 0.6);
        font-weight: 400;
    }

    .word-counter.over-limit {
        color: #fca5a5;
    }

    .thumbnail-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 1rem;
    }

    .thumbnail-option {
        position: relative;
        aspect-ratio: 16 / 9;
        border-radius: 8px;
        overflow: hidden;
        border: 2px solid rgba(148, 163, 184, 0.2);
        background: rgba(30, 41, 59, 0.6);
        cursor: pointer;
        transition:
            border-color 0.2s ease,
            transform 0.2s ease;
        padding: 0;
    }

    .thumbnail-option:hover {
        border-color: rgba(94, 234, 212, 0.5);
        transform: scale(1.05);
    }

    .thumbnail-option.selected {
        border-color: #5eead4;
    }

    .thumbnail-option img {
        width: 100%;
        height: 100%;
        object-fit: cover;
    }

    .selected-indicator {
        position: absolute;
        top: 0.5rem;
        right: 0.5rem;
        color: #5eead4;
        background: rgba(15, 23, 42, 0.9);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .location-detected {
        font-size: 0.85rem;
        color: #5eead4;
        font-weight: 400;
    }

    .form-actions {
        display: flex;
        justify-content: flex-end;
        padding-top: 1rem;
        border-top: 1px solid rgba(148, 163, 184, 0.2);
    }

    .submit-btn {
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 0.75rem;
        padding: 0.875rem 2rem;
        background: linear-gradient(135deg, #5eead4, #3b82f6);
        border: none;
        border-radius: 9999px;
        color: #0f172a;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition:
            transform 0.2s ease,
            box-shadow 0.2s ease;
        min-width: 200px;
    }

    .submit-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 30px -10px rgba(94, 234, 212, 0.5);
    }

    .submit-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

    @media (max-width: 640px) {
        .page {
            padding: 2rem 1rem;
        }

        .card {
            padding: 1.5rem;
            gap: 1.5rem;
        }

        header h1 {
            font-size: 1.5rem;
        }

        .thumbnail-grid {
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 0.75rem;
        }

        .form-actions {
            justify-content: stretch;
        }

        .submit-btn {
            width: 100%;
        }
    }
</style>
</file>

<file path="src/routes/account/+page.server.ts">
import { fail, redirect } from '@sveltejs/kit';
import type { Actions, PageServerLoad } from './$types';
import { createSupabaseServerClient } from '$lib/supabase/server';
import { inviteCodesEnabled, validateInviteCode } from '$lib/server/invite-codes';
import { getDb } from '$lib/server/db';
import { getVideoById, getVideosByUserId } from '$lib/server/db/videos';
import { ensureUserForAuth } from '$lib/server/db/users';

const FALLBACK_REDIRECT = '/';

function sanitizeString(value: FormDataEntryValue | null): string {
	if (typeof value !== 'string') return '';
	return value.trim();
}

function resolveRedirectTarget(url: URL, candidate: string | null | undefined): string {
	if (!candidate || typeof candidate !== 'string') return FALLBACK_REDIRECT;
	if (!candidate.startsWith('/')) return FALLBACK_REDIRECT;
	try {
		const normalised = new URL(candidate, url.origin);
		if (normalised.origin !== url.origin) return FALLBACK_REDIRECT;
		return normalised.pathname + normalised.search + normalised.hash;
	} catch {
		return FALLBACK_REDIRECT;
	}
}

export const load: PageServerLoad = async (event) => {
	const supabase = createSupabaseServerClient(event);
	const {
		data: { user },
		error
	} = await supabase.auth.getUser();

	if (error) {
		console.error('Failed to resolve authenticated user on account load:', error);
	}

const requestUrl = event.url;
const redirectTo = resolveRedirectTarget(requestUrl, requestUrl.searchParams.get('redirectTo'));
const highlightedVideoId = requestUrl.searchParams.get('uploaded');

const databaseUrl = event.platform?.env?.DATABASE_URL ?? process.env.DATABASE_URL;
let db: ReturnType<typeof getDb> | null = null;
if (databaseUrl) {
	try {
		db = getDb(databaseUrl);
	} catch (error) {
        console.error('Failed to initialise database client for account page:', error);
    }
}

let appUser = null;
if (user && db) {
	try {
		appUser = await ensureUserForAuth(db, user);
	} catch (error) {
		console.error('Failed to ensure account user record:', error);
	}
}

let uploadedVideo = null;
if (highlightedVideoId && db) {
    try {
        uploadedVideo = await getVideoById(db, highlightedVideoId);
    } catch (error) {
        console.error('Failed to resolve uploaded video for account page:', error);
    }
}

let userVideos = null;
if (appUser && db) {
    try {
        userVideos = await getVideosByUserId(db, appUser.id);
    } catch (error) {
        console.error('Failed to fetch user videos for account page:', error);
    }
}

	return {
		inviteRequired: inviteCodesEnabled(event),
		redirectTo,
		sessionUser: user ?? null,
		uploadedVideo,
		appUser: appUser,
		userVideos: userVideos
	};
};

export const actions: Actions = {
	login: async (event) => {
		const formData = await event.request.formData();
		const email = sanitizeString(formData.get('email'));
		const password = sanitizeString(formData.get('password'));
		const redirectTo = resolveRedirectTarget(event.url, sanitizeString(formData.get('redirectTo')));

		if (!email || !password) {
			return fail(400, {
				login: {
					message: 'Email and password are required.',
					email
				}
			});
		}

		const supabase = createSupabaseServerClient(event);
		const { error } = await supabase.auth.signInWithPassword({
			email,
			password
		});

		if (error) {
			return fail(400, {
				login: {
					message: error.message ?? 'Unable to sign in with those credentials.',
					email
				}
			});
		}

		throw redirect(303, redirectTo);
	},
	signup: async (event) => {
		const formData = await event.request.formData();
		const name = sanitizeString(formData.get('name'));
		const email = sanitizeString(formData.get('email'));
		const password = sanitizeString(formData.get('password'));
		const inviteCode = sanitizeString(formData.get('inviteCode'));
		const redirectTo = resolveRedirectTarget(event.url, sanitizeString(formData.get('redirectTo')));

		if (!email || !password) {
			return fail(400, {
				signup: {
					message: 'Email and password are required.',
					fields: {
						name,
						email
					}
				}
			});
		}

		const inviteValidation = validateInviteCode(event, inviteCode);
		if (!inviteValidation.valid) {
			return fail(400, {
				signup: {
					message: inviteValidation.error ?? 'Invalid invite code.',
					fields: {
						name,
						email
					}
				}
			});
		}

		const supabase = createSupabaseServerClient(event);
		const { data, error } = await supabase.auth.signUp({
			email,
			password,
			options: {
				data: {
					name,
					inviteCode
				},
				emailRedirectTo: new URL(redirectTo, event.url).toString()
			}
		});

		if (error) {
			return fail(400, {
				signup: {
					message: error.message ?? 'Unable to create account.',
					fields: {
						name,
						email
					}
				}
			});
		}

		if (data.session) {
			throw redirect(303, redirectTo);
		}

		return {
			signup: {
				success: true,
				message:
					'Thanks for signing up! Please check your email inbox to confirm your account before signing in.',
				fields: {
					name,
					email
				}
			}
		};
	},
	logout: async (event) => {
		const formData = await event.request.formData();
		const redirectTo = resolveRedirectTarget(event.url, sanitizeString(formData.get('redirectTo')));

		const supabase = createSupabaseServerClient(event);
		const { error } = await supabase.auth.signOut();

		if (error) {
			return fail(500, {
				logout: {
					message: error.message ?? 'Unable to sign out right now.'
				}
			});
		}

		throw redirect(303, redirectTo);
	},
	deleteVideo: async (event) => {
		const formData = await event.request.formData();
		const videoId = formData.get('videoId')?.toString();
		if (!videoId) return fail(400, { delete: { message: 'No video ID provided' } });
		const supabase = createSupabaseServerClient(event);
		const { data: { user } } = await supabase.auth.getUser();
		const databaseUrl = event.platform?.env?.DATABASE_URL ?? process.env.DATABASE_URL;
		if (!databaseUrl) return fail(500, { delete: { message: 'No DB connection' } });
		const db = getDb(databaseUrl);
		const video = await getVideoById(db, videoId);
		if (!video) return fail(404, { delete: { message: 'Video not found' } });
		// Only allow if the video is yours (authorId = user.slug or id)
		// Here we check authorId == user.id, this may need tune-up if slug is used
		if (!user || (video.authorId !== user.id && video.authorId !== user.slug)) {
			return fail(403, { delete: { message: 'No permission to delete this video' }});
		}
		// Perform the deletion
		await db.deleteFrom('videos').where(({ id }) => id.eq(videoId)).execute();
		// Redirect to /account after delete
		throw redirect(303, '/account');
	}
};
</file>

<file path="src/routes/account/+page.svelte">
<script lang="ts">
import type { ActionData, PageData } from './$types';
import { onMount } from 'svelte';
import { goto } from "$app/navigation";
import VideoPlayer from "$lib/components/VideoPlayer.svelte";

	export let data: PageData;
	export let form: ActionData;

	let activeTab: 'login' | 'signup' = 'login';

	type LoginFormState =
		| undefined
		| {
				message: string;
				email?: string;
		  };

	type SignupFormState =
		| undefined
		| {
				message: string;
				fields: { name: string; email: string };
		  }
		| {
				success: true;
				message: string;
				fields: { name: string; email: string };
		  };

	type LogoutFormState =
		| undefined
		| {
				message: string;
		  };

	const inviteRequired = data.inviteRequired;
	const redirectTo = data.redirectTo ?? '/';
const sessionUser = data.sessionUser;
const isAuthenticated = Boolean(sessionUser);

	let loginState: LoginFormState = undefined;
	let signupState: SignupFormState = undefined;
	let logoutState: LogoutFormState = undefined;
	let signupFields = { name: '', email: '' };
	let signupWasSuccessful = false;

	$: loginState = form?.login as LoginFormState;
	$: signupState = form?.signup as SignupFormState;
	$: logoutState = form?.logout as LogoutFormState;
	$: signupFields = signupState?.fields ?? { name: '', email: '' };
	$: signupWasSuccessful = !isAuthenticated
		? Boolean(signupState && 'success' in signupState && signupState.success)
		: false;

	// When signup succeeds, switch back to the login tab
	$: if (!isAuthenticated && signupWasSuccessful) {
		activeTab = 'login';
	}

	onMount(() => {
		if (typeof window !== 'undefined' && window.location.hash === '#signup') {
			activeTab = 'signup';
		}
	});


function onDrop(event: DragEvent) {
    event.preventDefault();
    event.stopPropagation();
    const file = event.dataTransfer?.files?.[0];
    if (file) queueUpload(file);
}

function onFileSelect(event: Event) {
    const file = (event.target as HTMLInputElement).files?.[0];
    if (file) queueUpload(file);
}

function queueUpload(file: File) {
    // Store the file on window (not persisted after reload)
    (window as any).__rushesUploadFile = file;
    goto("/account/upload");
}

function formatDateTime(value?: string | Date | null) {
	if (!value) return '';
	try {
		const date = value instanceof Date ? value : new Date(value);
		if (Number.isNaN(date.getTime())) {
			return typeof value === 'string' ? value : '';
		}
		return date.toLocaleString();
	} catch {
		return typeof value === 'string' ? value : '';
	}
}
</script>

<div class="min-h-screen p-8">
	<div class="mx-auto w-full max-w-4xl">
		{#if isAuthenticated}
			<header class="mb-8">
				<h1 class="text-3xl font-bold text-white mb-4">Your Account</h1>
				<p class="text-white/60 text-sm">Manage your profile and sign out securely.</p>
			</header>

			{#if data.uploadedVideo}
				<section class="mb-8 rounded-lg border border-white/10 bg-white/5 p-6">
					<h2 class="text-xl font-semibold text-white mb-4">Latest Upload</h2>
					<div class="grid gap-6 md:grid-cols-[minmax(0,2fr)_minmax(0,1fr)] items-start">
                        <div class="aspect-video w-full overflow-hidden rounded-xl border border-white/10 bg-black">
                            <VideoPlayer
                                videoUrl={data.uploadedVideo.videoUrl ?? data.uploadedVideo.url ?? ""}
                                controls
                            />
                        </div>
						<div class="space-y-3 text-white">
							<h3 class="text-lg font-semibold">{data.uploadedVideo.title}</h3>
							{#if data.uploadedVideo.description}
								<p class="text-sm text-white/70 leading-relaxed overflow-hidden" style="max-height: 8.5rem;">
									{data.uploadedVideo.description}
								</p>
							{/if}
							<p class="text-xs text-white/50">
								Uploaded {formatDateTime(data.uploadedVideo.uploadedAt ?? data.uploadedVideo.createdAt)}
							</p>
							<a
								class="inline-flex items-center gap-1 text-sm font-medium text-teal-300 hover:text-teal-200"
								href={`/videos/${data.uploadedVideo.id}`}
							>
								View video →
							</a>
						</div>
					</div>
				</section>
			{/if}

			<div class="rounded-lg border border-white/10 bg-white/5 p-8 mt-8">
				<h2 class="text-xl font-semibold text-white mb-5">Your uploads</h2>
				{#if data.userVideos && data.userVideos.length > 0}
					<div class="grid gap-6 sm:grid-cols-2 md:grid-cols-3">
						{#each data.userVideos as video (video.id)}
							<div class="relative group bg-white/5 rounded-xl border border-white/10 overflow-hidden shadow hover:shadow-lg transition-all flex flex-col">
								<a href={`/videos/${video.id}`}
									class="h-40 w-full block bg-black border-b border-white/10 overflow-hidden">
									<img src={video.thumbnailUrl ?? 'https://placehold.co/400x225?text=No+Thumbnail'} alt={video.title} class="w-full h-full object-cover"/>
								</a>
								<div class="flex-1 flex flex-col justify-between p-3">
									<div>
										<h3 class="font-semibold text-white text-base truncate">{video.title}</h3>
										<p class="text-xs text-white/40 truncate">{video.description ?? ''}</p>
									</div>
									<div class="flex gap-2 mt-3">
                                        <button class="text-xs px-2 py-1 rounded bg-teal-700/80 hover:bg-teal-600 text-white" onclick={() => startEditing(video)}>Edit</button>
										<form method="POST" action="?/deleteVideo" style="display:inline">
											<input type="hidden" name="videoId" value={video.id} />
                                            <button type="submit" class="text-xs px-2 py-1 rounded bg-rose-700/80 hover:bg-rose-600 text-white" onclick={event => { if (!confirm('Are you sure you want to delete this video? This cannot be undone.')) event.preventDefault(); }}>Delete</button>
										</form>
										<a href={`/videos/${video.id}`} class="text-xs px-2 py-1 rounded bg-white/10 hover:bg-white/20 text-teal-200">View</a>
									</div>
								</div>
							</div>
						{/each}
					</div>
				{:else}
					<p class="text-white/60 text-sm">You haven't uploaded any videos yet.</p>
				{/if}
			</div>
			<!-- Edit video modal/panel UI goes here; modal state and editing logic to be implemented -->

			<div class="rounded-lg border border-white/10 bg-white/5 p-8">
				<div class="flex flex-col items-center gap-4 mb-6 text-center sm:flex-row sm:items-start sm:text-left">
					<div class="flex h-16 w-16 items-center justify-center rounded-full border border-white/20 bg-white/5 text-lg font-semibold uppercase text-white">
						{sessionUser.email?.slice(0, 1) ?? 'U'}
					</div>
					<div class="space-y-2">
						<h2 class="text-xl font-semibold text-white">
							{sessionUser.user_metadata?.name ?? sessionUser.email ?? 'Account'}
						</h2>
						{#if sessionUser.email}
							<p class="text-sm text-white/60">{sessionUser.email}</p>
						{/if}
						{#if sessionUser.user_metadata?.inviteCode}
							<p class="text-xs text-white/40">Invite code: {sessionUser.user_metadata.inviteCode}</p>
						{/if}
						<p class="text-xs text-white/40">
							User id: <span class="font-mono text-white/60">{sessionUser.id}</span>
						</p>
					</div>
				</div>

				<div class="mb-8 flex justify-center">
					<div
						class="rounded-lg border-2 border-dashed border-white/20 bg-neutral-900/50 hover:bg-neutral-800/50 cursor-pointer p-8 text-center shadow transition-colors duration-150"
						style="max-width:570px;width:100%;"
						ondragover={e => { e.preventDefault(); e.stopPropagation(); }}
						ondrop={e => { e.preventDefault(); e.stopPropagation(); onDrop(e); }}
					>
						<label class="block text-white/70 text-lg font-medium mb-2 cursor-pointer">
							Drop a video to upload or <span class="underline text-orange-400 hover:text-orange-300">browse</span>
							<input type="file" accept="video/*" class="hidden" onchange={onFileSelect} />
						</label>
						<p class="text-sm text-white/50">Your video does not upload until you confirm on the next step.</p>
					</div>
				</div>

				<div class="border-t border-white/10 pt-6">
					<form method="POST" action="?/logout" class="space-y-4">
						<input type="hidden" name="redirectTo" value="/account" />
						{#if logoutState?.message}
							<p class="rounded-lg border border-red-500/40 bg-red-500/10 px-3 py-2 text-sm text-red-200">
								{logoutState.message}
							</p>
						{/if}
						<button
							type="submit"
							class="w-full rounded-lg border border-white/20 bg-white/10 px-4 py-3 text-sm font-medium text-white transition hover:bg-white/20 focus:outline-none focus:ring-2 focus:ring-white/20 focus:border-white/30"
						>
							Sign out
						</button>
					</form>
				</div>
			</div>
		{:else}
			<header class="mb-8">
				<h1 class="text-3xl font-bold text-white mb-4">Access Your Account</h1>
				<p class="text-white/60 text-sm">
					Sign in to continue, or request access with an invite code to create a new account.
				</p>
			</header>

			<!-- Tab Switcher -->
			<div class="mb-8 flex gap-2 border-b border-white/10">
				<button
					class="px-4 py-2 text-sm font-medium transition-colors border-b-2 {activeTab ===
					'login'
						? 'border-white text-white'
						: 'border-transparent text-white/60 hover:text-white'}"
          onclick={() => (activeTab = 'login')}
					type="button"
				>
					Sign in
				</button>
				<button
					class="px-4 py-2 text-sm font-medium transition-colors border-b-2 {activeTab ===
					'signup'
						? 'border-white text-white'
						: 'border-transparent text-white/60 hover:text-white'}"
          onclick={() => (activeTab = 'signup')}
					type="button"
				>
					Create account
				</button>
			</div>

			<div class="rounded-lg border border-white/10 bg-white/5 p-8">
				{#if activeTab === 'login'}
					<section>
						<header class="mb-6 space-y-2">
							<h2 class="text-xl font-semibold text-white">Welcome back</h2>
							<p class="text-sm text-white/60">
								Use your email and password to sign in.
							</p>
						</header>

						<form method="POST" action="?/login" class="space-y-5">
							<input type="hidden" name="redirectTo" value={redirectTo} />

							<label class="block space-y-2 text-sm font-medium">
								<span class="text-white">Email</span>
								<input
									class="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-3 text-sm text-white placeholder:text-white/40 focus:border-white/30 focus:outline-none focus:ring-2 focus:ring-white/20"
									autocomplete="email"
									type="email"
									name="email"
									required
									value={loginState?.email ?? ''}
								/>
							</label>

							<label class="block space-y-2 text-sm font-medium">
								<span class="text-white">Password</span>
								<input
									class="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-3 text-sm text-white placeholder:text-white/40 focus:border-white/30 focus:outline-none focus:ring-2 focus:ring-white/20"
									type="password"
									name="password"
									autocomplete="current-password"
									required
								/>
							</label>

							{#if loginState?.message}
								<p class="rounded-lg border border-red-500/40 bg-red-500/10 px-3 py-2 text-sm text-red-200">
									{loginState.message}
								</p>
							{/if}

							<button
								class="mt-2 w-full rounded-lg bg-white px-4 py-3 text-sm font-semibold text-black transition hover:bg-white/90 focus:outline-none focus:ring-2 focus:ring-white/40"
								type="submit"
							>
								Sign in
							</button>
						</form>
					</section>
				{:else}
					<section>
						<header class="mb-6 space-y-2">
							<h2 class="text-xl font-semibold text-white">Request access</h2>
							<p class="text-sm text-white/60">
								Create a new account using your invite code.
							</p>
						</header>

						<form method="POST" action="?/signup" class="space-y-5">
							<input type="hidden" name="redirectTo" value={redirectTo} />

							<label class="block space-y-2 text-sm font-medium">
								<span class="text-white">Display name</span>
								<input
									class="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-3 text-sm text-white placeholder:text-white/40 focus:border-white/30 focus:outline-none focus:ring-2 focus:ring-white/20"
									type="text"
									name="name"
									placeholder="How should we address you?"
									value={signupFields.name}
								/>
							</label>

							<label class="block space-y-2 text-sm font-medium">
								<span class="text-white">Email</span>
								<input
									class="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-3 text-sm text-white placeholder:text-white/40 focus:border-white/30 focus:outline-none focus:ring-2 focus:ring-white/20"
									type="email"
									name="email"
									autocomplete="email"
									required
									value={signupFields.email}
								/>
							</label>

							<label class="block space-y-2 text-sm font-medium">
								<span class="text-white">Password</span>
								<input
									class="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-3 text-sm text-white placeholder:text-white/40 focus:border-white/30 focus:outline-none focus:ring-2 focus:ring-white/20"
									type="password"
									name="password"
									autocomplete="new-password"
									required
								/>
							</label>

							<label class="block space-y-2 text-sm font-medium">
								<span class="text-white">Invite code</span>
								<input
									class="w-full rounded-lg border border-white/10 bg-white/5 px-4 py-3 text-sm text-white placeholder:text-white/40 focus:border-white/30 focus:outline-none focus:ring-2 focus:ring-white/20"
									type="text"
									name="inviteCode"
									required={inviteRequired}
									placeholder="Enter your invite code"
								/>
							</label>

							{#if signupState && !signupWasSuccessful && signupState.message}
								<p class="rounded-lg border border-red-500/40 bg-red-500/10 px-3 py-2 text-sm text-red-200">
									{signupState.message}
								</p>
							{:else if signupWasSuccessful && signupState?.message}
								<p class="rounded-lg border border-emerald-500/40 bg-emerald-500/10 px-3 py-2 text-sm text-emerald-200">
									{signupState.message}
								</p>
							{/if}

							<button
								class="mt-2 w-full rounded-lg border border-white/20 bg-white/10 px-4 py-3 text-sm font-medium text-white transition hover:bg-white/20 focus:outline-none focus:ring-2 focus:ring-white/20 focus:border-white/30"
								type="submit"
							>
								Request access
							</button>

							{#if inviteRequired}
								<p class="text-xs text-white/40">
									Need an invite? Reach out to your RUSHES contact to request a code.
								</p>
							{:else}
								<p class="text-xs text-emerald-300/70">
									Invite codes are optional in this environment.
								</p>
							{/if}
						</form>
					</section>
				{/if}
			</div>
		{/if}
	</div>
</div>
</file>

<file path="src/routes/faq/+page.svelte">
<script lang="ts">
    let openSections = $state<Set<string>>(new Set());
    
    function toggleSection(id: string) {
        if (openSections.has(id)) {
            openSections.delete(id);
        } else {
            openSections.add(id);
        }
        openSections = new Set(openSections);
    }
    
    const faqCategories = [
        {
            id: 'getting-started',
            title: 'Getting Started',
            questions: [
                {
                    id: 'what-is-rushes',
                    question: 'What is Rushes?',
                    answer: 'Rushes is a collective platform dedicated to filmmakers. It maps rushes — unedited footage, fragments from shoots — to create a living archive, a meeting space, and a visual experimentation laboratory. The platform allows users to find and share unedited footage, discover connections between clips using AI-powered content analysis, and explore content through keywords, locations, and dates.'
                },
                {
                    id: 'how-to-sign-up',
                    question: 'How do I create an account?',
                    answer: 'To create an account, visit the Account page and click "Create account". You\'ll need to provide a display name, email address, and password. If invite codes are enabled, you\'ll also need a valid invite code from your RUSHES contact. Once you sign up, you may need to confirm your email address before you can sign in.'
                },
                {
                    id: 'invite-code',
                    question: 'Do I need an invite code?',
                    answer: 'Invite codes may be required depending on your environment. If invite codes are enabled, you\'ll need to obtain one from your RUSHES contact to create an account. In some environments, invite codes are optional. Check the signup form on the Account page to see if an invite code is required.'
                },
                {
                    id: 'first-steps',
                    question: 'What should I do after signing up?',
                    answer: 'After signing up and confirming your account, you can start exploring the platform. Browse videos by keywords, dates, or users. Use the search feature to find specific content. If you\'re a filmmaker, you can upload your own rushes through the Upload page to contribute to the archive.'
                }
            ]
        },
        {
            id: 'uploading-content',
            title: 'Uploading Content',
            questions: [
                {
                    id: 'how-to-upload',
                    question: 'How do I upload videos?',
                    answer: 'To upload videos, navigate to the Upload page (accessible from the sidebar). You\'ll need to provide a title, optional description, and metadata such as keywords, location information, and transcript. The platform processes your upload and makes it discoverable through the various browsing and search features.'
                },
                {
                    id: 'what-to-upload',
                    question: 'What kind of content should I upload?',
                    answer: 'Rushes focuses on unedited footage — raw clips, fragments from shoots, and experimental visual content. Upload rushes that you want to share with the community. Make sure to add relevant keywords, location data, and other metadata to help others discover your content.'
                },
                {
                    id: 'video-requirements',
                    question: 'Are there requirements for video uploads?',
                    answer: 'Specific technical requirements may vary. Generally, you should upload videos in common formats and ensure they meet any size or duration limits. Check the Upload page for current specifications, and reach out to support if you encounter issues.'
                },
                {
                    id: 'metadata-importance',
                    question: 'Why is metadata important?',
                    answer: 'Metadata (keywords, location, transcripts, descriptions) helps make your content discoverable. The platform uses this information along with AI-powered content analysis to find connections between videos. The more accurate and detailed your metadata, the better others can find and connect with your content.'
                }
            ]
        },
        {
            id: 'browsing-content',
            title: 'Browsing & Discovery',
            questions: [
                {
                    id: 'browse-keywords',
                    question: 'How do I browse by keywords?',
                    answer: 'Visit the Browse page and select the "Keywords" tab. You\'ll see all available keywords organized alphabetically in a telephone book style. Click on any keyword to see all videos tagged with that keyword. Each video card displays the title, author, and description when you hover over it.'
                },
                {
                    id: 'browse-dates',
                    question: 'How do I browse by date?',
                    answer: 'On the Browse page, select the "Dates" tab to see videos organized hierarchically by year, month, and day. Click on a year, month, or specific day to view all videos from that time period. This makes it easy to explore content chronologically.'
                },
                {
                    id: 'browse-users',
                    question: 'How do I browse by users?',
                    answer: 'Select the "Users" tab on the Browse page to see all users organized alphabetically. Click on any user to visit their profile and see all videos they\'ve uploaded. You can also click on an author name from any video to navigate to their profile.'
                },
                {
                    id: 'search-feature',
                    question: 'How does the search feature work?',
                    answer: 'The search feature on the Browse page allows natural language search across video titles, descriptions, keywords, authors, and transcripts. Simply type your query and results will appear, prioritized by title matches and sorted by relevance. Search results show video cards with thumbnails and metadata.'
                },
                {
                    id: 'map-exploration',
                    question: 'How do I explore videos by location?',
                    answer: 'Use the Map page to explore videos geographically. Videos with location data are displayed on an interactive map. Click on markers or the map itself to discover content from specific locations. You can also click on location coordinates in video info panels to navigate to the map view.'
                }
            ]
        },
        {
            id: 'video-features',
            title: 'Video Features',
            questions: [
                {
                    id: 'video-player',
                    question: 'How do I watch videos?',
                    answer: 'Click on any video card or title to open the video player. The player supports HLS streaming and includes timeline controls, playback controls (previous, play/pause, next), and hover overlays with video information. The timeline component shows visual markers and can be used for navigation.'
                },
                {
                    id: 'video-info',
                    question: 'What information is shown about each video?',
                    answer: 'Each video displays its author, date of creation (with time and day/night indicator), summary/description, keywords (clickable links to keyword pages), location (with city/region name and interactive map), and transcript if available. Summary, keywords, and location are expanded by default for quick reference.'
                },
                {
                    id: 'video-navigation',
                    question: 'How do I navigate between videos?',
                    answer: 'Use the previous/next buttons in the video player controls to move between videos. You can also click on video cards from browse pages, search results, or user profiles. The selected video will load in the player automatically.'
                },
                {
                    id: 'keyword-links',
                    question: 'Can I click on keywords?',
                    answer: 'Yes! Keywords in video info panels are clickable links that take you to a page showing all videos with that keyword. This makes it easy to discover related content and explore themes across the archive.'
                }
            ]
        },
        {
            id: 'account-settings',
            title: 'Account & Settings',
            questions: [
                {
                    id: 'edit-profile',
                    question: 'How do I edit my profile?',
                    answer: 'Profile editing features may be available through your account settings. Currently, your profile displays your display name, email, and any associated metadata. Additional profile customization options may be added in future updates.'
                },
                {
                    id: 'sign-out',
                    question: 'How do I sign out?',
                    answer: 'To sign out, visit the Account page and click the "Sign out" button. You\'ll be logged out and redirected appropriately. You can sign back in at any time using your email and password.'
                },
                {
                    id: 'password-reset',
                    question: 'How do I reset my password?',
                    answer: 'Password reset functionality is typically handled through email. If you\'ve forgotten your password, contact support or use the account recovery options available on the login page. The exact process may vary depending on your authentication setup.'
                },
                {
                    id: 'data-privacy',
                    question: 'What happens to my data?',
                    answer: 'Your account data, including uploaded videos and metadata, is stored securely. The platform uses your videos and associated information to create connections and enable discovery features. For specific privacy concerns, please contact your RUSHES administrator.'
                }
            ]
        },
        {
            id: 'technical',
            title: 'Technical & Support',
            questions: [
                {
                    id: 'browser-support',
                    question: 'Which browsers are supported?',
                    answer: 'Rushes works best in modern browsers that support the latest web standards. The platform uses HLS video streaming, so ensure your browser supports this format. Chrome, Firefox, Safari, and Edge are generally well-supported.'
                },
                {
                    id: 'video-not-playing',
                    question: 'Why isn\'t my video playing?',
                    answer: 'Video playback issues can be caused by browser compatibility, network connectivity, or video format issues. Ensure you\'re using a supported browser and have a stable internet connection. If problems persist, try refreshing the page or contact support.'
                },
                {
                    id: 'performance-issues',
                    question: 'The site seems slow. What can I do?',
                    answer: 'Performance can be affected by network conditions, browser cache, or device capabilities. Try clearing your browser cache, closing unnecessary tabs, or using a faster internet connection. The platform is optimized for performance, but heavy video content may require better hardware or bandwidth.'
                },
                {
                    id: 'contact-support',
                    question: 'How do I contact support?',
                    answer: 'If you need help, reach out to your RUSHES contact or administrator. For technical issues, bugs, or feature requests, use the contact information provided by your organization. Support availability may vary depending on your setup.'
                }
            ]
        }
    ];
</script>

<div class="min-h-screen p-8">
    <div class="max-w-4xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-white mb-4">Frequently Asked Questions</h1>
            <p class="text-white/60 text-sm">
                Find answers to common questions about using Rushes.
            </p>
        </header>

        <div class="space-y-6">
            {#each faqCategories as category}
                <div class="rounded-lg border border-white/10 bg-white/5 overflow-hidden">
                    <div class="border-b border-white/10 bg-white/5 px-6 py-4">
                        <h2 class="text-xl font-semibold text-white">{category.title}</h2>
                    </div>
                    <div class="divide-y divide-white/10">
                        {#each category.questions as faq}
                            <div class="border-b border-white/10 last:border-b-0">
                                <button
                                    onclick={() => toggleSection(faq.id)}
                                    class="w-full px-6 py-4 flex items-center justify-between text-left hover:bg-white/5 transition-colors"
                                    aria-expanded={openSections.has(faq.id)}
                                >
                                    <span class="text-sm font-medium text-white pr-4">
                                        {faq.question}
                                    </span>
                                    <svg
                                        xmlns="http://www.w3.org/2000/svg"
                                        width="16"
                                        height="16"
                                        fill="none"
                                        stroke="currentColor"
                                        viewBox="0 0 24 24"
                                        class="flex-shrink-0 text-white/70 transition-transform {openSections.has(faq.id)
                                            ? 'rotate-180'
                                            : ''}"
                                    >
                                        <path
                                            stroke-linecap="round"
                                            stroke-linejoin="round"
                                            stroke-width="2"
                                            d="M19 9l-7 7-7-7"
                                        />
                                    </svg>
                                </button>
                                {#if openSections.has(faq.id)}
                                    <div class="px-6 pb-4 text-sm text-white/70 leading-relaxed">
                                        {faq.answer}
                                    </div>
                                {/if}
                            </div>
                        {/each}
                    </div>
                </div>
            {/each}
        </div>

        <!-- Contact Section -->
        <div class="mt-12 rounded-lg border border-white/10 bg-white/5 p-8 text-center">
            <h2 class="text-xl font-semibold text-white mb-2">Still have questions?</h2>
            <p class="text-sm text-white/60 mb-4">
                Can't find what you're looking for? Reach out to your RUSHES contact or administrator for assistance.
            </p>
            <a
                href="/account"
                class="inline-block rounded-lg border border-white/20 bg-white/10 px-4 py-2 text-sm font-medium text-white transition hover:bg-white/20 focus:outline-none focus:ring-2 focus:ring-white/20 focus:border-white/30"
            >
                Visit Account Page
            </a>
        </div>
    </div>
</div>
</file>

<file path="agents.md">
# Agent Instructions

- When the user requests new implementations, skip running type checks unless they explicitly ask for it.
</file>

<file path=".history/src/lib/components/Sidebar_20251028182444.svelte">
<script lang="ts">
    import { slide } from "svelte/transition";
    import { onMount, tick } from "svelte";
    import { page } from "$app/stores";
    // FIXED: This is the correct import for the component API you are using
    import { Tooltip } from "bits-ui";

    interface Props {
        isOpen?: boolean;
        onclose?: () => void;
    }

    let { isOpen = false, onclose }: Props = $props();

    function closeMobileSidebar() {
        onclose?.();
    }

    // REFACTORED: Added "Live" link to the navLinks array
    const navLinks = [
        { href: "/", label: "Home", icon: "live" },
        // { href: "/live", label: "Live", icon: "play" },
        { href: "/map", label: "Map", icon: "map" },
        { href: "/users", label: "Users", icon: "users" },
        { href: "/upload", label: "Upload", icon: "upload" },
    ] as const;

    // --- State for Highlight Logic ---
    let navContainer = $state<HTMLDivElement | null>(null);
    let highlightContainer = $state<HTMLDivElement | null>(null);
    // REMOVED: liveLinkRef is no longer needed
    // let liveLinkRef = $state<HTMLAnchorElement | null>(null);

    // This array will now be 5 elements long, and navRefs[0] will be the "Live" link
    let navRefs: Array<HTMLAnchorElement | null> = $state(
        new Array(navLinks.length).fill(null),
    );
    let highlightY = $state(0);
    let highlightX = $state(0);
    let highlightWidth = $state(0);
    let highlightHeight = $state(0);
    let highlightVisible = $state(false);
    let highlightPulse = $state(false);
    let highlightElement: HTMLDivElement | null = null;
    let resizeHandler: (() => void) | null = null;

    function routeMatches(href: string | null, currentPath: string): boolean {
        if (!href) return false;
        return currentPath === href || currentPath.startsWith(`${href}/`);
    }

    async function refreshHighlight(currentPath: string) {
        await tick();
        if (!highlightContainer) {
            highlightVisible = false;
            return;
        }

        let target: HTMLElement | null = null;

        const activeIndex = navLinks.findIndex((link) =>
            routeMatches(link.href, currentPath),
        );
        if (activeIndex !== -1) {
            const candidate = navRefs[activeIndex];
            if (candidate instanceof HTMLElement) {
                target = candidate;
            }
        }

        if (!target) {
            highlightVisible = false;
            return;
        }

        const containerRect = highlightContainer.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // UPDATED: Use the target's width and left directly.
        // Since the target <a> is h-12 w-12, this will result in a square.
        let width = targetRect.width;
        let left = targetRect.left - containerRect.left;

        // REMOVED: The block that calculated width based on the inner icon is gone.

        highlightY = targetRect.top - containerRect.top;
        highlightX = left;
        highlightWidth = width;
        highlightHeight = targetRect.height; // height will equal width (h-12)
        const isVisible = highlightHeight > 0 && highlightWidth > 0;

        if (!isVisible) {
            highlightVisible = false;
            highlightPulse = false;
            return;
        }

        highlightVisible = true;
        highlightPulse = false;
        await tick();
        highlightPulse = true;
    }

    onMount(() => {
        const handleResize = () => {
            refreshHighlight($page.url.pathname);
        };
        window.addEventListener("resize", handleResize);
        resizeHandler = handleResize;

        return () => {
            if (resizeHandler) {
                window.removeEventListener("resize", resizeHandler);
                resizeHandler = null;
            }
        };
    });

    // REFACTORED: Removed dependency on liveLinkRef
    $effect(() => {
        const path = $page.url.pathname;
        highlightContainer;
        navRefs.forEach((ref) => ref);
        refreshHighlight(path);
    });

    const icons = {
        home: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9.75L12 3l9 6.75V21a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-4.5a.75.75 0 00-.75-.75h-3a.75.75 0 00-.75.75V21a.75.75 0 01-.75.75H3.75A.75.75 0 013 21V9.75z"/></svg>`,
        map: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 3.75l6 2.5 6-2.5v14.5l-6 2.5-6-2.5-6 2.5V6.25l6-2.5zM9 3.75v14.5m6-12v14.5"/></svg>`,
        play: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347c-.75.412-1.667-.13-1.667-.986V5.653z" /></svg>`,
        users: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M6.5 21a5.5 5.5 0 0111 0M19.5 8.25a2.25 2.25 0 110 4.5M21 21a3 3 0 00-4-2.82"/></svg>`,
        upload: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16.5v1.25A2.25 2.25 0 006.25 20h11.5A2.25 2.25 0 0020 17.75V16.5M8.75 9.75L12 6.5l3.25 3.25M12 6.5v9.75"/></svg>`,
    } satisfies Record<string, string>;
</script>

<Tooltip.Provider delayDuration={100}>
    <aside
        class="hidden z-100 lg:flex lg:w-20 lg:flex-col transition-all duration-300 ease-in-out overflow-visible"
    >
        <div
            class="sidebar-shell relative flex flex-1 flex-col overflow-y-auto overflow-x-visible border-r border-white/10 bg-white/[0.02] backdrop-blur-md shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)]"
            bind:this={highlightContainer}
        >
            <div
                bind:this={highlightElement}
                class="nav-highlight"
                class:visible={highlightVisible}
                style={`--highlight-x: ${highlightX}px; --highlight-y: ${highlightY}px; height: ${highlightHeight}px; width: ${highlightWidth}px;`}
            >
                <div
                    class="nav-highlight-inner"
                    class:animate={highlightPulse}
                    on:animationend={() => {
                        highlightPulse = false;
                    }}
                ></div>
            </div>

            <nav class="mt-6 flex-1 flex justify-center px-4">
                <div class="space-y-1 nav-list" bind:this={navContainer}>
                    {#each navLinks as link, index}
                        <Tooltip.Root>
                            <Tooltip.Trigger asChild>
                                <a
                                    href={link.href}
                                    bind:this={navRefs[index]}
                                    class="nav-item flex h-10 w-10 items-center justify-center rounded-xl transition {link.icon ===
                                    'live'
                                        ? 'logo-link mb-10 '
                                        : 'text-white/70 hover:bg-white/10 hover:text-white'}"
                                    class:active={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )}
                                    aria-label={link.label}
                                    aria-current={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )
                                        ? "page"
                                        : undefined}
                                >
                                    {#if link.icon === "live"}
                                        <span
                                            class="logo-mark"
                                            aria-hidden="true"
                                        >
                                            <span
                                                class="logo-bar logo-bar--long"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--medium"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--short"
                                            ></span>
                                        </span>
                                    {:else}
                                        <span
                                            class="nav-icon text-white/80"
                                            aria-hidden="true"
                                            >{@html icons[link.icon]}</span
                                        >
                                    {/if}
                                </a>
                            </Tooltip.Trigger>

                            <Tooltip.Portal>
                                <Tooltip.Content
                                    side="right"
                                    align="center"
                                    sideOffset={3}
                                    class="tooltip-content"
                                >
                                    {link.label}
                                </Tooltip.Content>
                            </Tooltip.Portal>
                        </Tooltip.Root>
                    {/each}
                </div>
            </nav>
        </div>
    </aside>
</Tooltip.Provider>

<div class="lg:hidden">
    {#if isOpen}
        <aside
            class="fixed top-0 left-0 h-full w-64 bg-white dark:bg-black border-r border-gray-300 z-50"
            transition:slide={{ duration: 200, axis: "x" }}
        >
            <div class="flex flex-col flex-grow pt-5 pb-4 overflow-y-auto">
                <div
                    class="flex items-center justify-between flex-shrink-0 px-4"
                >
                    <h1
                        class="text-xl font-bold tracking-wider text-gray-900 dark:text-white"
                    >
                        RUSHES
                    </h1>
                    <button
                        on:click={closeMobileSidebar}
                        class="p-2 hover:bg-gray-100 dark:hover:bg-gray-900 rounded transition-colors"
                        aria-label="Close menu"
                    >
                        <svg
                            class="h-5 w-5 text-gray-900 dark:text-white"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <nav class="mt-8 flex-1 px-4 space-y-1">
                    {#each navLinks as link}
                        <a
                            href={link.href}
                            class="group flex items-center px-2 py-2 text-sm font-medium rounded-md text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
                            on:click={closeMobileSidebar}
                        >
                            {#if link.icon === "live"}
                                <span class="mr-3 h-5 w-5" aria-hidden="true">
                                    <span class="logo-mark !h-5 !w-5">
                                        <span
                                            class="logo-bar logo-bar--long bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--medium bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--short bg-gray-900 dark:bg-white"
                                        ></span>
                                    </span>
                                </span>
                            {:else}
                                <span
                                    class="mr-3 h-5 w-5 text-gray-900 dark:text-white"
                                    aria-hidden="true"
                                    >{@html icons[link.icon]}</span
                                >
                            {/if}
                            {link.label}
                        </a>
                    {/each}
                </nav>
            </div>
        </aside>
    {/if}
</div>

<style>
    .logo-mark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.2rem;
        width: 1.5rem;
        height: 1.5rem;
    }

    .logo-bar {
        width: 0.2rem;
        border-radius: 9999px;
        background: white;
    }

    .logo-bar--long {
        height: 1.15rem;
    }

    .logo-bar--medium {
        height: 0.85rem;
    }

    .logo-bar--short {
        height: 0.65rem;
    }

    .sidebar-shell {
        overflow-x: visible;
        overflow-y: auto;
    }

    .nav-list {
        position: relative;
        overflow: visible;
    }

    .nav-item {
        position: relative;
    }

    .nav-item.active {
        color: #f8fafc;
    }

    .nav-icon :global(svg) {
        display: block;
        height: 1.25rem;
        width: 1.25rem;
    }

    /* FIXED: Removed :global() and set z-index properly */
    :global(.tooltip-content) {
        background: rgba(255, 255, 255, 0.2);
        font-family: sans-serif;
        color: #f8fafc;
        padding: 0.35rem 0.6rem;
        border-radius: 0.55rem;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        white-space: nowrap;
        box-shadow: 0 18px 35px -24px rgba(15, 23, 42, 0.88);
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        z-index: 9999999;
    }

    /* Added style for tooltip arrow */
    .tooltip-arrow {
        fill: rgba(15, 23, 42, 0.92);
    }

    .nav-highlight {
        position: absolute;
        left: 0;
        top: 0;

        border-radius: 10px;
        pointer-events: none;
        z-index: -1;
        transform: translate3d(var(--highlight-x, 0), var(--highlight-y, 0), 0);
        transition:
            transform 0.32s cubic-bezier(0.28, 0.94, 0.38, 1),
            height 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            width 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            opacity 0.16s ease;
        opacity: 0;
    }

    .nav-highlight.visible {
        opacity: 1;
    }

    .nav-highlight-inner {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.18);
        transition: opacity 0.16s ease;
        opacity: 0.9;

        transform-origin: center;
    }

    .nav-highlight-inner.animate {
        animation: highlight-bounce 0.5s cubic-bezier(0.24, 1.58, 0.36, 1)
            forwards;
    }

    @keyframes highlight-bounce {
        0% {
            transform: scale(0.88);
        }
        45% {
            transform: scale(1.08);
        }
        70% {
            transform: scale(0.97);
        }
        100% {
            transform: scale(1);
        }
    }

    .nav-list a.active {
        color: orange;
    }

    .nav-list a.active span:first-child {
        color: orange;
    }

    a.active .logo-bar {
        background: orange !important;
    }
</style>
</file>

<file path=".history/src/lib/components/Sidebar_20251028192244.svelte">
<script lang="ts">
    import { slide } from "svelte/transition";
    import { onMount, tick } from "svelte";
    import { page } from "$app/stores";
    // FIXED: This is the correct import for the component API you are using
    import { Tooltip } from "bits-ui";

    interface Props {
        isOpen?: boolean;
        onclose?: () => void;
    }

    let { isOpen = false, onclose }: Props = $props();

    function closeMobileSidebar() {
        onclose?.();
    }

    // REFACTORED: Added "Live" link to the navLinks array
    const navLinks = [
        { href: "/", label: "Home", icon: "live" },
        // { href: "/live", label: "Live", icon: "play" },
        { href: "/map", label: "Map", icon: "map" },
        { href: "/users", label: "Users", icon: "users" },
        { href: "/upload", label: "Upload", icon: "upload" },
    ] as const;

    // --- State for Highlight Logic ---
    let navContainer = $state<HTMLDivElement | null>(null);
    let highlightContainer = $state<HTMLDivElement | null>(null);
    // REMOVED: liveLinkRef is no longer needed
    // let liveLinkRef = $state<HTMLAnchorElement | null>(null);

    // This array will now be 5 elements long, and navRefs[0] will be the "Live" link
    let navRefs: Array<HTMLAnchorElement | null> = $state(
        new Array(navLinks.length).fill(null),
    );
    let highlightY = $state(0);
    let highlightX = $state(0);
    let highlightWidth = $state(0);
    let highlightHeight = $state(0);
    let highlightVisible = $state(false);
    let highlightPulse = $state(false);
    let highlightElement: HTMLDivElement | null = null;
    let resizeHandler: (() => void) | null = null;

    function routeMatches(href: string | null, currentPath: string): boolean {
        if (!href) return false;
        return currentPath === href || currentPath.startsWith(`${href}/`);
    }

    async function refreshHighlight(currentPath: string) {
        await tick();
        if (!highlightContainer) {
            highlightVisible = false;
            return;
        }

        let target: HTMLElement | null = null;

        const activeIndex = navLinks.findIndex((link) =>
            routeMatches(link.href, currentPath),
        );
        if (activeIndex !== -1) {
            const candidate = navRefs[activeIndex];
            if (candidate instanceof HTMLElement) {
                target = candidate;
            }
        }

        if (!target) {
            highlightVisible = false;
            return;
        }

        const containerRect = highlightContainer.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // UPDATED: Use the target's width and left directly.
        // Since the target <a> is h-12 w-12, this will result in a square.
        let width = targetRect.width;
        let left = targetRect.left - containerRect.left;

        // REMOVED: The block that calculated width based on the inner icon is gone.

        highlightY = targetRect.top - containerRect.top;
        highlightX = left;
        highlightWidth = width;
        highlightHeight = targetRect.height; // height will equal width (h-12)
        const isVisible = highlightHeight > 0 && highlightWidth > 0;

        if (!isVisible) {
            highlightVisible = false;
            highlightPulse = false;
            return;
        }

        highlightVisible = true;
        highlightPulse = false;
        await tick();
        highlightPulse = true;
    }

    onMount(() => {
        const handleResize = () => {
            refreshHighlight($page.url.pathname);
        };
        window.addEventListener("resize", handleResize);
        resizeHandler = handleResize;

        return () => {
            if (resizeHandler) {
                window.removeEventListener("resize", resizeHandler);
                resizeHandler = null;
            }
        };
    });

    // REFACTORED: Removed dependency on liveLinkRef
    $effect(() => {
        const path = $page.url.pathname;
        highlightContainer;
        navRefs.forEach((ref) => ref);
        refreshHighlight(path);
    });

    const icons = {
        home: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9.75L12 3l9 6.75V21a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-4.5a.75.75 0 00-.75-.75h-3a.75.75 0 00-.75.75V21a.75.75 0 01-.75.75H3.75A.75.75 0 013 21V9.75z"/></svg>`,
        map: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 3.75l6 2.5 6-2.5v14.5l-6 2.5-6-2.5-6 2.5V6.25l6-2.5zM9 3.75v14.5m6-12v14.5"/></svg>`,
        play: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347c-.75.412-1.667-.13-1.667-.986V5.653z" /></svg>`,
        users: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M6.5 21a5.5 5.5 0 0111 0M19.5 8.25a2.25 2.25 0 110 4.5M21 21a3 3 0 00-4-2.82"/></svg>`,
        upload: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16.5v1.25A2.25 2.25 0 006.25 20h11.5A2.25 2.25 0 0020 17.75V16.5M8.75 9.75L12 6.5l3.25 3.25M12 6.5v9.75"/></svg>`,
    } satisfies Record<string, string>;
</script>

<Tooltip.Provider delayDuration={100}>
    <aside
        class="hidden z-100 lg:flex lg:w-20 lg:flex-col transition-all duration-300 ease-in-out overflow-visible"
    >
        <div
            class="sidebar-shell relative flex flex-1 flex-col overflow-y-auto overflow-x-visible border-r border-white/10 bg-white/[0.02] backdrop-blur-md shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)]"
            bind:this={highlightContainer}
        >
            <div
                bind:this={highlightElement}
                class="nav-highlight"
                class:visible={highlightVisible}
                style={`--highlight-x: ${highlightX}px; --highlight-y: ${highlightY}px; height: ${highlightHeight}px; width: ${highlightWidth}px;`}
            >
                <div
                    class="nav-highlight-inner"
                    class:animate={highlightPulse}
                    on:animationend={() => {
                        highlightPulse = false;
                    }}
                ></div>
            </div>

            <nav class="mt-6 flex-1 flex justify-center px-4">
                <div class="space-y-1 nav-list" bind:this={navContainer}>
                    {#each navLinks as link, index}
                        <Tooltip.Root>
                            <Tooltip.Trigger asChild>
                                <a
                                    href={link.href}
                                    bind:this={navRefs[index]}
                                    class="nav-item flex h-10 w-10 items-center justify-center rounded-xl transition {link.icon ===
                                    'live'
                                        ? 'logo-link mb-10 '
                                        : 'text-white/70 hover:bg-white/10 hover:text-white'}"
                                    class:active={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )}
                                    aria-label={link.label}
                                    aria-current={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )
                                        ? "page"
                                        : undefined}
                                >
                                    {#if link.icon === "live"}
                                        <span
                                            class="logo-mark"
                                            aria-hidden="true"
                                        >
                                            <span
                                                class="logo-bar logo-bar--long"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--medium"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--short"
                                            ></span>
                                        </span>
                                    {:else}
                                        <span
                                            class="nav-icon text-white/80"
                                            aria-hidden="true"
                                            >{@html icons[link.icon]}</span
                                        >
                                    {/if}
                                </a>
                            </Tooltip.Trigger>

                            <Tooltip.Portal>
                                <Tooltip.Content
                                    side="right"
                                    align="center"
                                    sideOffset={3}
                                    class="tooltip-content"
                                >
                                    {link.label}
                                </Tooltip.Content>
                            </Tooltip.Portal>
                        </Tooltip.Root>
                    {/each}
                </div>
            </nav>
        </div>
    </aside>
</Tooltip.Provider>

<div class="lg:hidden">
    {#if isOpen}
        <aside
            class="fixed top-0 left-0 h-full w-64 bg-white dark:bg-black border-r border-gray-300 z-50"
            transition:slide={{ duration: 200, axis: "x" }}
        >
            <div class="flex flex-col flex-grow pt-5 pb-4 overflow-y-auto">
                <div
                    class="flex items-center justify-between flex-shrink-0 px-4"
                >
                    <h1
                        class="text-xl font-bold tracking-wider text-gray-900 dark:text-white"
                    >
                        RUSHES
                    </h1>
                    <button
                        on:click={closeMobileSidebar}
                        class="p-2 hover:bg-gray-100 dark:hover:bg-gray-900 rounded transition-colors"
                        aria-label="Close menu"
                    >
                        <svg
                            class="h-5 w-5 text-gray-900 dark:text-white"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <nav class="mt-8 flex-1 px-4 space-y-1">
                    {#each navLinks as link}
                        <a
                            href={link.href}
                            class="group flex items-center px-2 py-2 text-sm font-medium rounded-md text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
                            on:click={closeMobileSidebar}
                        >
                            {#if link.icon === "live"}
                                <span class="mr-3 h-5 w-5" aria-hidden="true">
                                    <span class="logo-mark !h-5 !w-5">
                                        <span
                                            class="logo-bar logo-bar--long bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--medium bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--short bg-gray-900 dark:bg-white"
                                        ></span>
                                    </span>
                                </span>
                            {:else}
                                <span
                                    class="mr-3 h-5 w-5 text-gray-900 dark:text-white"
                                    aria-hidden="true"
                                    >{@html icons[link.icon]}</span
                                >
                            {/if}
                            {link.label}
                        </a>
                    {/each}
                </nav>
            </div>
        </aside>
    {/if}
</div>

<style>
    .logo-mark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.2rem;
        width: 1.5rem;
        height: 1.5rem;
    }

    .logo-bar {
        width: 0.2rem;
        border-radius: 9999px;
        background: white;
    }

    .logo-bar--long {
        height: 1.15rem;
    }

    .logo-bar--medium {
        height: 0.85rem;
    }

    .logo-bar--short {
        height: 0.65rem;
    }

    .sidebar-shell {
        overflow-x: visible;
        overflow-y: auto;
    }

    .nav-list {
        position: relative;
        overflow: visible;
    }

    .nav-item {
        position: relative;
    }

    .nav-item.active {
        color: #f8fafc;
    }

    .nav-icon :global(svg) {
        display: block;
        height: 1.25rem;
        width: 1.25rem;
    }

    /* FIXED: Removed :global() and set z-index properly */
    :global(.tooltip-content) {
        background: rgba(255, 255, 255, 0.2);
        font-family: sans-serif;
        color: #f8fafc;
        padding: 0.35rem 0.6rem;
        border-radius: 0.55rem;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        white-space: nowrap;
        box-shadow: 0 18px 35px -24px rgba(15, 23, 42, 0.88);
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        z-index: 9999999;
    }

    /* Added style for tooltip arrow */
    .tooltip-arrow {
        fill: rgba(15, 23, 42, 0.92);
    }

    .nav-highlight {
        position: absolute;
        left: 0;
        top: 0;

        border-radius: 10px;
        pointer-events: none;
        z-index: -1;
        transform: translate3d(var(--highlight-x, 0), var(--highlight-y, 0), 0);
        transition:
            transform 0.32s cubic-bezier(0.28, 0.94, 0.38, 1),
            height 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            width 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            opacity 0.16s ease;
        opacity: 0;
    }

    .nav-highlight.visible {
        opacity: 1;
    }

    .nav-highlight-inner {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.08);
        transition: opacity 0.16s ease;
        opacity: 0.9;

        transform-origin: center;
    }

    .nav-highlight-inner.animate {
        animation: highlight-bounce 0.5s cubic-bezier(0.24, 1.58, 0.36, 1)
            forwards;
    }

    @keyframes highlight-bounce {
        0% {
            transform: scale(0.88);
        }
        45% {
            transform: scale(1.08);
        }
        70% {
            transform: scale(0.97);
        }
        100% {
            transform: scale(1);
        }
    }

    .nav-list a.active {
        color: orange;
    }

    .nav-list a.active span:first-child {
        color: orange;
    }

    a.active .logo-bar {
        background: orange !important;
    }
</style>
</file>

<file path=".history/src/lib/components/Sidebar_20251028192303.svelte">
<script lang="ts">
    import { slide } from "svelte/transition";
    import { onMount, tick } from "svelte";
    import { page } from "$app/stores";
    // FIXED: This is the correct import for the component API you are using
    import { Tooltip } from "bits-ui";

    interface Props {
        isOpen?: boolean;
        onclose?: () => void;
    }

    let { isOpen = false, onclose }: Props = $props();

    function closeMobileSidebar() {
        onclose?.();
    }

    // REFACTORED: Added "Live" link to the navLinks array
    const navLinks = [
        { href: "/", label: "Home", icon: "live" },
        // { href: "/live", label: "Live", icon: "play" },
        { href: "/map", label: "Map", icon: "map" },
        { href: "/users", label: "Users", icon: "users" },
        { href: "/upload", label: "Upload", icon: "upload" },
    ] as const;

    // --- State for Highlight Logic ---
    let navContainer = $state<HTMLDivElement | null>(null);
    let highlightContainer = $state<HTMLDivElement | null>(null);
    // REMOVED: liveLinkRef is no longer needed
    // let liveLinkRef = $state<HTMLAnchorElement | null>(null);

    // This array will now be 5 elements long, and navRefs[0] will be the "Live" link
    let navRefs: Array<HTMLAnchorElement | null> = $state(
        new Array(navLinks.length).fill(null),
    );
    let highlightY = $state(0);
    let highlightX = $state(0);
    let highlightWidth = $state(0);
    let highlightHeight = $state(0);
    let highlightVisible = $state(false);
    let highlightPulse = $state(false);
    let highlightElement: HTMLDivElement | null = null;
    let resizeHandler: (() => void) | null = null;

    function routeMatches(href: string | null, currentPath: string): boolean {
        if (!href) return false;
        return currentPath === href || currentPath.startsWith(`${href}/`);
    }

    async function refreshHighlight(currentPath: string) {
        await tick();
        if (!highlightContainer) {
            highlightVisible = false;
            return;
        }

        let target: HTMLElement | null = null;

        const activeIndex = navLinks.findIndex((link) =>
            routeMatches(link.href, currentPath),
        );
        if (activeIndex !== -1) {
            const candidate = navRefs[activeIndex];
            if (candidate instanceof HTMLElement) {
                target = candidate;
            }
        }

        if (!target) {
            highlightVisible = false;
            return;
        }

        const containerRect = highlightContainer.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // UPDATED: Use the target's width and left directly.
        // Since the target <a> is h-12 w-12, this will result in a square.
        let width = targetRect.width;
        let left = targetRect.left - containerRect.left;

        // REMOVED: The block that calculated width based on the inner icon is gone.

        highlightY = targetRect.top - containerRect.top;
        highlightX = left;
        highlightWidth = width;
        highlightHeight = targetRect.height; // height will equal width (h-12)
        const isVisible = highlightHeight > 0 && highlightWidth > 0;

        if (!isVisible) {
            highlightVisible = false;
            highlightPulse = false;
            return;
        }

        highlightVisible = true;
        highlightPulse = false;
        await tick();
        highlightPulse = true;
    }

    onMount(() => {
        const handleResize = () => {
            refreshHighlight($page.url.pathname);
        };
        window.addEventListener("resize", handleResize);
        resizeHandler = handleResize;

        return () => {
            if (resizeHandler) {
                window.removeEventListener("resize", resizeHandler);
                resizeHandler = null;
            }
        };
    });

    // REFACTORED: Removed dependency on liveLinkRef
    $effect(() => {
        const path = $page.url.pathname;
        highlightContainer;
        navRefs.forEach((ref) => ref);
        refreshHighlight(path);
    });

    const icons = {
        home: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9.75L12 3l9 6.75V21a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-4.5a.75.75 0 00-.75-.75h-3a.75.75 0 00-.75.75V21a.75.75 0 01-.75.75H3.75A.75.75 0 013 21V9.75z"/></svg>`,
        map: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 3.75l6 2.5 6-2.5v14.5l-6 2.5-6-2.5-6 2.5V6.25l6-2.5zM9 3.75v14.5m6-12v14.5"/></svg>`,
        play: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347c-.75.412-1.667-.13-1.667-.986V5.653z" /></svg>`,
        users: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M6.5 21a5.5 5.5 0 0111 0M19.5 8.25a2.25 2.25 0 110 4.5M21 21a3 3 0 00-4-2.82"/></svg>`,
        upload: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16.5v1.25A2.25 2.25 0 006.25 20h11.5A2.25 2.25 0 0020 17.75V16.5M8.75 9.75L12 6.5l3.25 3.25M12 6.5v9.75"/></svg>`,
    } satisfies Record<string, string>;
</script>

<Tooltip.Provider delayDuration={100}>
    <aside
        class="hidden z-100 lg:flex lg:w-20 lg:flex-col transition-all duration-300 ease-in-out overflow-visible"
    >
        <div
            class="sidebar-shell relative flex flex-1 flex-col overflow-y-auto overflow-x-visible border-r border-white/10 bg-white/[0.02] backdrop-blur-md shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)]"
            bind:this={highlightContainer}
        >
            <div
                bind:this={highlightElement}
                class="nav-highlight"
                class:visible={highlightVisible}
                style={`--highlight-x: ${highlightX}px; --highlight-y: ${highlightY}px; height: ${highlightHeight}px; width: ${highlightWidth}px;`}
            >
                <div
                    class="nav-highlight-inner"
                    class:animate={highlightPulse}
                    on:animationend={() => {
                        highlightPulse = false;
                    }}
                ></div>
            </div>

            <nav class="mt-6 flex-1 flex justify-center px-4">
                <div class="space-y-1 nav-list" bind:this={navContainer}>
                    {#each navLinks as link, index}
                        <Tooltip.Root>
                            <Tooltip.Trigger asChild>
                                <a
                                    href={link.href}
                                    bind:this={navRefs[index]}
                                    class="nav-item flex h-10 w-10 items-center justify-center rounded-xl transition {link.icon ===
                                    'live'
                                        ? 'logo-link mb-10 '
                                        : 'text-white/70 hover:bg-white/10 hover:text-white'}"
                                    class:active={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )}
                                    aria-label={link.label}
                                    aria-current={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )
                                        ? "page"
                                        : undefined}
                                >
                                    {#if link.icon === "live"}
                                        <span
                                            class="logo-mark"
                                            aria-hidden="true"
                                        >
                                            <span
                                                class="logo-bar logo-bar--long"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--medium"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--short"
                                            ></span>
                                        </span>
                                    {:else}
                                        <span
                                            class="nav-icon text-white/80"
                                            aria-hidden="true"
                                            >{@html icons[link.icon]}</span
                                        >
                                    {/if}
                                </a>
                            </Tooltip.Trigger>

                            <Tooltip.Portal>
                                <Tooltip.Content
                                    side="right"
                                    align="center"
                                    sideOffset={3}
                                    class="tooltip-content"
                                >
                                    {link.label}
                                </Tooltip.Content>
                            </Tooltip.Portal>
                        </Tooltip.Root>
                    {/each}
                </div>
            </nav>
        </div>
    </aside>
</Tooltip.Provider>

<div class="lg:hidden">
    {#if isOpen}
        <aside
            class="fixed top-0 left-0 h-full w-64 bg-white dark:bg-black border-r border-gray-300 z-50"
            transition:slide={{ duration: 200, axis: "x" }}
        >
            <div class="flex flex-col flex-grow pt-5 pb-4 overflow-y-auto">
                <div
                    class="flex items-center justify-between flex-shrink-0 px-4"
                >
                    <h1
                        class="text-xl font-bold tracking-wider text-gray-900 dark:text-white"
                    >
                        RUSHES
                    </h1>
                    <button
                        on:click={closeMobileSidebar}
                        class="p-2 hover:bg-gray-100 dark:hover:bg-gray-900 rounded transition-colors"
                        aria-label="Close menu"
                    >
                        <svg
                            class="h-5 w-5 text-gray-900 dark:text-white"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <nav class="mt-8 flex-1 px-4 space-y-1">
                    {#each navLinks as link}
                        <a
                            href={link.href}
                            class="group flex items-center px-2 py-2 text-sm font-medium rounded-md text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
                            on:click={closeMobileSidebar}
                        >
                            {#if link.icon === "live"}
                                <span class="mr-3 h-5 w-5" aria-hidden="true">
                                    <span class="logo-mark !h-5 !w-5">
                                        <span
                                            class="logo-bar logo-bar--long bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--medium bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--short bg-gray-900 dark:bg-white"
                                        ></span>
                                    </span>
                                </span>
                            {:else}
                                <span
                                    class="mr-3 h-5 w-5 text-gray-900 dark:text-white"
                                    aria-hidden="true"
                                    >{@html icons[link.icon]}</span
                                >
                            {/if}
                            {link.label}
                        </a>
                    {/each}
                </nav>
            </div>
        </aside>
    {/if}
</div>

<style>
    .logo-mark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.2rem;
        width: 1.5rem;
        height: 1.5rem;
    }

    .logo-bar {
        width: 0.2rem;
        border-radius: 9999px;
        background: white;
    }

    .logo-bar--long {
        height: 1.15rem;
    }

    .logo-bar--medium {
        height: 0.85rem;
    }

    .logo-bar--short {
        height: 0.65rem;
    }

    .sidebar-shell {
        overflow-x: visible;
        overflow-y: auto;
    }

    .nav-list {
        position: relative;
        overflow: visible;
    }

    .nav-item {
        position: relative;
    }

    .nav-item.active {
        color: #f8fafc;
    }

    .nav-icon :global(svg) {
        display: block;
        height: 1.25rem;
        width: 1.25rem;
    }

    /* FIXED: Removed :global() and set z-index properly */
    :global(.tooltip-content) {
        background: rgba(255, 255, 255, 0.2);
        font-family: sans-serif;
        color: #f8fafc;
        padding: 0.35rem 0.6rem;
        border-radius: 0.55rem;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        white-space: nowrap;
        box-shadow: 0 18px 35px -24px rgba(15, 23, 42, 0.88);
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        z-index: 9999999;
    }

    /* Added style for tooltip arrow */
    .tooltip-arrow {
        fill: rgba(15, 23, 42, 0.92);
    }

    .nav-highlight {
        position: absolute;
        left: 0;
        top: 0;

        border-radius: 10px;
        pointer-events: none;
        z-index: -1;
        transform: translate3d(var(--highlight-x, 0), var(--highlight-y, 0), 0);
        transition:
            transform 0.32s cubic-bezier(0.28, 0.94, 0.38, 1),
            height 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            width 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            opacity 0.16s ease;
        opacity: 0;
    }

    .nav-highlight.visible {
        opacity: 1;
    }

    .nav-highlight-inner {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.18);
        transition: opacity 0.16s ease;
        opacity: 0.9;

        transform-origin: center;
    }

    .nav-highlight-inner.animate {
        animation: highlight-bounce 0.5s cubic-bezier(0.24, 1.58, 0.36, 1)
            forwards;
    }

    @keyframes highlight-bounce {
        0% {
            transform: scale(0.88);
        }
        45% {
            transform: scale(1.08);
        }
        70% {
            transform: scale(0.97);
        }
        100% {
            transform: scale(1);
        }
    }

    .nav-list a.active {
        color: orange;
    }

    .nav-list a.active span:first-child {
        color: orange;
    }

    a.active .logo-bar {
        background: orange !important;
    }
</style>
</file>

<file path=".history/src/lib/components/Sidebar_20251028192307.svelte">
<script lang="ts">
    import { slide } from "svelte/transition";
    import { onMount, tick } from "svelte";
    import { page } from "$app/stores";
    // FIXED: This is the correct import for the component API you are using
    import { Tooltip } from "bits-ui";

    interface Props {
        isOpen?: boolean;
        onclose?: () => void;
    }

    let { isOpen = false, onclose }: Props = $props();

    function closeMobileSidebar() {
        onclose?.();
    }

    // REFACTORED: Added "Live" link to the navLinks array
    const navLinks = [
        { href: "/", label: "Home", icon: "live" },
        // { href: "/live", label: "Live", icon: "play" },
        { href: "/map", label: "Map", icon: "map" },
        { href: "/users", label: "Users", icon: "users" },
        { href: "/upload", label: "Upload", icon: "upload" },
    ] as const;

    // --- State for Highlight Logic ---
    let navContainer = $state<HTMLDivElement | null>(null);
    let highlightContainer = $state<HTMLDivElement | null>(null);
    // REMOVED: liveLinkRef is no longer needed
    // let liveLinkRef = $state<HTMLAnchorElement | null>(null);

    // This array will now be 5 elements long, and navRefs[0] will be the "Live" link
    let navRefs: Array<HTMLAnchorElement | null> = $state(
        new Array(navLinks.length).fill(null),
    );
    let highlightY = $state(0);
    let highlightX = $state(0);
    let highlightWidth = $state(0);
    let highlightHeight = $state(0);
    let highlightVisible = $state(false);
    let highlightPulse = $state(false);
    let highlightElement: HTMLDivElement | null = null;
    let resizeHandler: (() => void) | null = null;

    function routeMatches(href: string | null, currentPath: string): boolean {
        if (!href) return false;
        return currentPath === href || currentPath.startsWith(`${href}/`);
    }

    async function refreshHighlight(currentPath: string) {
        await tick();
        if (!highlightContainer) {
            highlightVisible = false;
            return;
        }

        let target: HTMLElement | null = null;

        const activeIndex = navLinks.findIndex((link) =>
            routeMatches(link.href, currentPath),
        );
        if (activeIndex !== -1) {
            const candidate = navRefs[activeIndex];
            if (candidate instanceof HTMLElement) {
                target = candidate;
            }
        }

        if (!target) {
            highlightVisible = false;
            return;
        }

        const containerRect = highlightContainer.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // UPDATED: Use the target's width and left directly.
        // Since the target <a> is h-12 w-12, this will result in a square.
        let width = targetRect.width;
        let left = targetRect.left - containerRect.left;

        // REMOVED: The block that calculated width based on the inner icon is gone.

        highlightY = targetRect.top - containerRect.top;
        highlightX = left;
        highlightWidth = width;
        highlightHeight = targetRect.height; // height will equal width (h-12)
        const isVisible = highlightHeight > 0 && highlightWidth > 0;

        if (!isVisible) {
            highlightVisible = false;
            highlightPulse = false;
            return;
        }

        highlightVisible = true;
        highlightPulse = false;
        await tick();
        highlightPulse = true;
    }

    onMount(() => {
        const handleResize = () => {
            refreshHighlight($page.url.pathname);
        };
        window.addEventListener("resize", handleResize);
        resizeHandler = handleResize;

        return () => {
            if (resizeHandler) {
                window.removeEventListener("resize", resizeHandler);
                resizeHandler = null;
            }
        };
    });

    // REFACTORED: Removed dependency on liveLinkRef
    $effect(() => {
        const path = $page.url.pathname;
        highlightContainer;
        navRefs.forEach((ref) => ref);
        refreshHighlight(path);
    });

    const icons = {
        home: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9.75L12 3l9 6.75V21a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-4.5a.75.75 0 00-.75-.75h-3a.75.75 0 00-.75.75V21a.75.75 0 01-.75.75H3.75A.75.75 0 013 21V9.75z"/></svg>`,
        map: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 3.75l6 2.5 6-2.5v14.5l-6 2.5-6-2.5-6 2.5V6.25l6-2.5zM9 3.75v14.5m6-12v14.5"/></svg>`,
        play: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347c-.75.412-1.667-.13-1.667-.986V5.653z" /></svg>`,
        users: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M6.5 21a5.5 5.5 0 0111 0M19.5 8.25a2.25 2.25 0 110 4.5M21 21a3 3 0 00-4-2.82"/></svg>`,
        upload: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16.5v1.25A2.25 2.25 0 006.25 20h11.5A2.25 2.25 0 0020 17.75V16.5M8.75 9.75L12 6.5l3.25 3.25M12 6.5v9.75"/></svg>`,
    } satisfies Record<string, string>;
</script>

<Tooltip.Provider delayDuration={100}>
    <aside
        class="hidden z-100 lg:flex lg:w-20 lg:flex-col transition-all duration-300 ease-in-out overflow-visible"
    >
        <div
            class="sidebar-shell relative flex flex-1 flex-col overflow-y-auto overflow-x-visible border-r border-white/10 bg-white/[0.02] backdrop-blur-md shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)]"
            bind:this={highlightContainer}
        >
            <div
                bind:this={highlightElement}
                class="nav-highlight"
                class:visible={highlightVisible}
                style={`--highlight-x: ${highlightX}px; --highlight-y: ${highlightY}px; height: ${highlightHeight}px; width: ${highlightWidth}px;`}
            >
                <div
                    class="nav-highlight-inner"
                    class:animate={highlightPulse}
                    on:animationend={() => {
                        highlightPulse = false;
                    }}
                ></div>
            </div>

            <nav class="mt-6 flex-1 flex justify-center px-4">
                <div class="space-y-1 nav-list" bind:this={navContainer}>
                    {#each navLinks as link, index}
                        <Tooltip.Root>
                            <Tooltip.Trigger asChild>
                                <a
                                    href={link.href}
                                    bind:this={navRefs[index]}
                                    class="nav-item flex h-10 w-10 items-center justify-center rounded-xl transition {link.icon ===
                                    'live'
                                        ? 'logo-link mb-10 '
                                        : 'text-white/70 hover:bg-white/10 hover:text-white'}"
                                    class:active={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )}
                                    aria-label={link.label}
                                    aria-current={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )
                                        ? "page"
                                        : undefined}
                                >
                                    {#if link.icon === "live"}
                                        <span
                                            class="logo-mark"
                                            aria-hidden="true"
                                        >
                                            <span
                                                class="logo-bar logo-bar--long"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--medium"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--short"
                                            ></span>
                                        </span>
                                    {:else}
                                        <span
                                            class="nav-icon text-white/80"
                                            aria-hidden="true"
                                            >{@html icons[link.icon]}</span
                                        >
                                    {/if}
                                </a>
                            </Tooltip.Trigger>

                            <Tooltip.Portal>
                                <Tooltip.Content
                                    side="right"
                                    align="center"
                                    sideOffset={3}
                                    class="tooltip-content"
                                >
                                    {link.label}
                                </Tooltip.Content>
                            </Tooltip.Portal>
                        </Tooltip.Root>
                    {/each}
                </div>
            </nav>
        </div>
    </aside>
</Tooltip.Provider>

<div class="lg:hidden">
    {#if isOpen}
        <aside
            class="fixed top-0 left-0 h-full w-64 bg-white dark:bg-black border-r border-gray-300 z-50"
            transition:slide={{ duration: 200, axis: "x" }}
        >
            <div class="flex flex-col flex-grow pt-5 pb-4 overflow-y-auto">
                <div
                    class="flex items-center justify-between flex-shrink-0 px-4"
                >
                    <h1
                        class="text-xl font-bold tracking-wider text-gray-900 dark:text-white"
                    >
                        RUSHES
                    </h1>
                    <button
                        on:click={closeMobileSidebar}
                        class="p-2 hover:bg-gray-100 dark:hover:bg-gray-900 rounded transition-colors"
                        aria-label="Close menu"
                    >
                        <svg
                            class="h-5 w-5 text-gray-900 dark:text-white"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <nav class="mt-8 flex-1 px-4 space-y-1">
                    {#each navLinks as link}
                        <a
                            href={link.href}
                            class="group flex items-center px-2 py-2 text-sm font-medium rounded-md text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
                            on:click={closeMobileSidebar}
                        >
                            {#if link.icon === "live"}
                                <span class="mr-3 h-5 w-5" aria-hidden="true">
                                    <span class="logo-mark !h-5 !w-5">
                                        <span
                                            class="logo-bar logo-bar--long bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--medium bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--short bg-gray-900 dark:bg-white"
                                        ></span>
                                    </span>
                                </span>
                            {:else}
                                <span
                                    class="mr-3 h-5 w-5 text-gray-900 dark:text-white"
                                    aria-hidden="true"
                                    >{@html icons[link.icon]}</span
                                >
                            {/if}
                            {link.label}
                        </a>
                    {/each}
                </nav>
            </div>
        </aside>
    {/if}
</div>

<style>
    .logo-mark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.2rem;
        width: 1.5rem;
        height: 1.5rem;
    }

    .logo-bar {
        width: 0.2rem;
        border-radius: 9999px;
        background: white;
    }

    .logo-bar--long {
        height: 1.15rem;
    }

    .logo-bar--medium {
        height: 0.85rem;
    }

    .logo-bar--short {
        height: 0.65rem;
    }

    .sidebar-shell {
        overflow-x: visible;
        overflow-y: auto;
    }

    .nav-list {
        position: relative;
        overflow: visible;
    }

    .nav-item {
        position: relative;
    }

    .nav-item.active {
        color: #f8fafc;
    }

    .nav-icon :global(svg) {
        display: block;
        height: 1.25rem;
        width: 1.25rem;
    }

    /* FIXED: Removed :global() and set z-index properly */
    :global(.tooltip-content) {
        background: rgba(255, 255, 255, 0.2);
        font-family: sans-serif;
        color: #f8fafc;
        padding: 0.35rem 0.6rem;
        border-radius: 0.55rem;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        white-space: nowrap;
        box-shadow: 0 18px 35px -24px rgba(15, 23, 42, 0.88);
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        z-index: 9999999;
    }

    /* Added style for tooltip arrow */
    .tooltip-arrow {
        fill: rgba(15, 23, 42, 0.92);
    }

    .nav-highlight {
        position: absolute;
        left: 0;
        top: 0;

        border-radius: 10px;
        pointer-events: none;
        z-index: -1;
        transform: translate3d(var(--highlight-x, 0), var(--highlight-y, 0), 0);
        transition:
            transform 0.32s cubic-bezier(0.28, 0.94, 0.38, 1),
            height 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            width 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            opacity 0.16s ease;
        opacity: 0;
    }

    .nav-highlight.visible {
        opacity: 1;
    }

    .nav-highlight-inner {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.1);
        transition: opacity 0.16s ease;
        opacity: 0.9;

        transform-origin: center;
    }

    .nav-highlight-inner.animate {
        animation: highlight-bounce 0.5s cubic-bezier(0.24, 1.58, 0.36, 1)
            forwards;
    }

    @keyframes highlight-bounce {
        0% {
            transform: scale(0.88);
        }
        45% {
            transform: scale(1.08);
        }
        70% {
            transform: scale(0.97);
        }
        100% {
            transform: scale(1);
        }
    }

    .nav-list a.active {
        color: orange;
    }

    .nav-list a.active span:first-child {
        color: orange;
    }

    a.active .logo-bar {
        background: orange !important;
    }
</style>
</file>

<file path=".history/src/lib/components/VideoInfo_20251018164223.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description md:bg-slate-100/5 border border-white/5 md:rounded-lg md:p-6 mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location md:bg-slate-100/5 border border-white/5 md:rounded-lg md:p-6 mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192012.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location md:bg-slate-100/5 border border-white/5 md:rounded-lg md:p-6 mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192027.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192039.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location md:bg-slate-100/5 md:rounded-lg md:p-6 mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192045.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location md:bg-slate-100/5 md:rounded-lg  mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192048.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location md:bg-slate-100/5  mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192051.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location  mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192104.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location border-b border-white-10 mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192106.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location border-b border-white/10 mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfo_20251028192150.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import CollapsibleHeading from "$lib/components/CollapsibleHeading.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Section states
    let isLocationOpen = $state(true);
    let isMoreVideosOpen = $state(true);
    let isTranscriptOpen = $state(true);
    let isKeywordsOpen = $state(true);
    let isNotesOpen = $state(true);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    const relatedVideos = $derived(
        $videosStore
            .filter(
                (video) =>
                    video.authorId === data.video.authorId &&
                    video.id !== data.video.id,
            )
            .slice(0, 4),
    );

    let newComment = $state("");

    // Map icon path
    const mapIcon =
        "M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z";

    // Format views count
    function formatViews(views: number): string {
        if (views >= 1000000) {
            return `${(views / 1000000).toFixed(1)}M`;
        } else if (views >= 1000) {
            return `${(views / 1000).toFixed(1)}K`;
        }
        return views.toString();
    }

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }
</script>

<div
    class="w-full transition-colors"
    style="font-family: Arial, Helvetica, sans-serif;"
>
    <div class="pt-6 px-8">
        <!-- Video Metadata -->
        <!-- <div class="flex items-center gap-4 text-sm text-neutral-400 mb-4">
      <div class="flex items-center gap-1">
        <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"/>
          <path d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"/>
        </svg>
        <span>{data.video.duration}</span>
      </div>


    </div> -->

        <div
            class="description mb-6"
        >
            <div
                class="flex items-center pb-2 justify-between border-b border-white/10 mb-2 pb-4"
            >
                <a
                    class="text-white text-xs"
                    href={`/users/${data.video.authorId}`}
                    >{data.video.author}</a
                >

                <div class="flex items-center gap-1 text-white">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                        />
                        <path
                            d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                        />
                    </svg>
                    <span class="text-xs"
                        >Uploaded {formatUploadDate(
                            data.video.uploadDate ||
                                data.video.timestamp ||
                                new Date().toISOString(),
                        )}</span
                    >
                </div>
            </div>

            <p class="text-sm dark:text-neutral-400 leading-relaxed">
                {data.video.description}
            </p>
        </div>

        <!-- Location Section -->
        <div
            class="location border-b border-white/10 mb-6"
        >
            <CollapsibleHeading
                title="Location"
                bind:isOpen={isLocationOpen}
                actionButton={{
                    text: "View on map",
                    icon: mapIcon,
                    href: `/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`,
                }}
            >
                {#if dummyLocations.length}
                    <div class="h-[400px] rounded-lg overflow-hidden mb-3">
                        <Map
                            locations={dummyLocations}
                            {initialCenterLon}
                            {initialCenterLat}
                            {initialZoom}
                        />
                    </div>
                    <div
                        class="flex items-center gap-2 text-sm text-neutral-400"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                        >
                            <path d={mapIcon} />
                        </svg>
                        <span>[{initialCenterLat}, {initialCenterLon}]</span>
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No location data available for this video.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- More Videos Section -->
            <CollapsibleHeading
                title={`More from ${data.video.author}`}
                bind:isOpen={isMoreVideosOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                {#if relatedVideos.length}
                    <div class="grid grid-cols-2 gap-3">
                        {#each relatedVideos as related}
                            <a
                                class="relative aspect-video rounded-lg overflow-hidden bg-white/10 group"
                                href={`/videos/${related.id}`}
                            >
                                <img
                                    src={related.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={related.title}
                                    class="w-full h-full object-cover"
                                />
                                <div
                                    class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent"
                                >
                                    <p class="text-xs text-white">
                                        {related.title}
                                    </p>
                                    <p class="text-xs text-neutral-400">
                                        {related.duration ?? "0:00"}
                                    </p>
                                </div>
                            </a>
                        {/each}
                    </div>
                {:else}
                    <p class="text-sm text-neutral-400">
                        No additional videos from this creator yet.
                    </p>
                {/if}
            </CollapsibleHeading>

            <!-- Transcript Section -->
            <CollapsibleHeading
                title="Transcript"
                bind:isOpen={isTranscriptOpen}
                actionButton={{
                    text: "Copy",
                }}
            >
                <div class="text-sm text-neutral-400 leading-relaxed">
                    <p>
                        {data.video.transcript ?? "Transcript not available."}
                    </p>
                </div>
            </CollapsibleHeading>

            <!-- Keywords Section -->

            <CollapsibleHeading
                title="Keywords"
                bind:isOpen={isKeywordsOpen}
                actionButton={{
                    text: "View all",
                }}
            >
                <div class="flex flex-wrap gap-2">
                    {#each data.video.keywords ?? [] as keyword}
                        <a
                            href="/keywords/{keyword}"
                            class="px-3 py-1 text-sm bg-white/10 hover:bg-white/20 text-neutral-300 rounded-full transition-colors"
                        >
                            {keyword}
                        </a>
                    {/each}
                </div>
            </CollapsibleHeading>

            <!-- Notes Section -->

            <CollapsibleHeading title="Notes" bind:isOpen={isNotesOpen}>
                <!-- Comment Input -->
                <div class="mb-6">
                    <div class="flex gap-3">
                        <img
                            src="https://i.pravatar.cc/150?img=4"
                            alt="Your avatar"
                            class="w-8 h-8 rounded-full"
                        />
                        <div class="flex-1">
                            <textarea
                                bind:value={newComment}
                                placeholder="Add a note..."
                                class="w-full p-3 bg-white/5 border border-black/10 dark:border-white/10 rounded-lg text-sm text-neutral-800 dark:text-neutral-200 placeholder-neutral-400 focus:outline-none focus:ring-2 focus:ring-black/10 dark:focus:ring-white/10 resize-none"
                                rows="2"
                            ></textarea>
                            <div class="flex justify-end mt-2">
                                <button
                                    class="px-4 py-1.5 text-sm bg-black dark:bg-white text-white dark:text-black rounded-lg hover:opacity-90 transition-opacity"
                                    disabled={!newComment.trim()}
                                >
                                    Post
                                </button>
                            </div>
                        </div>
                    </div>

                    <div class="space-y-4">
                        {#each comments as comment}
                            <div class="flex gap-3">
                                <img
                                    src={comment.avatar}
                                    alt={comment.user}
                                    class="w-8 h-8 rounded-full"
                                />
                                <div class="flex-1">
                                    <div class="flex items-center gap-2 mb-1">
                                        <span
                                            class="text-sm font-medium dark:text-neutral-200"
                                            >{comment.user}</span
                                        >
                                        <span class="text-xs text-neutral-400"
                                            >{comment.timestamp}</span
                                        >
                                    </div>
                                    <p
                                        class="text-sm text-neutral-800 dark:text-neutral-200 mb-2"
                                    >
                                        {comment.content}
                                    </p>
                                    <div class="flex items-center gap-4">
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200 flex items-center gap-1"
                                        >
                                            <svg
                                                xmlns="http://www.w3.org/2000/svg"
                                                width="14"
                                                height="14"
                                                fill="currentColor"
                                                viewBox="0 0 16 16"
                                            >
                                                <path
                                                    d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"
                                                />
                                            </svg>
                                            {comment.likes}
                                        </button>
                                        <button
                                            class="text-xs text-neutral-400 hover:text-neutral-600 dark:hover:text-neutral-200"
                                        >
                                            Reply
                                        </button>
                                    </div>
                                </div>
                            </div>
                        {/each}
                    </div>
                </div></CollapsibleHeading
            >
        </div>
    </div>
</div>
</file>

<file path=".history/src/lib/components/VideoInfoContainer_20251018164107.svelte">
<script lang="ts">
    import VideoInfo from "$lib/components/VideoInfo.svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import {
        getVideoById as lookupVideo,
        videosStore,
    } from "$lib/stores/library";
    import type { Video } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    const videosList = $derived($videosStore);

    function resolveVideo(id: string | null): VideoData | null {
        if (!id) return null;
        if (id === "home") {
            const fallback = videosList[0];
            return fallback ? { video: fallback } : null;
        }
        const video = lookupVideo(id);
        return video ? { video } : null;
    }

    let data = $state<VideoData | null>(null);
    let nextVideo = $state<Video | null>(null);

    $effect(() => {
        data = resolveVideo($selectedVideo.id);

        // Resolve next video data
        const nextId = selectedVideo.nextVideoId;
        nextVideo = nextId ? (lookupVideo(nextId) ?? null) : null;
    });

    function handlePlayNext() {
        selectedVideo.playNext();
    }
</script>

{#if data}
    <VideoInfo {data} />

    {#if nextVideo}
        <div
            class="up-next-container border-t border-white/10 bg-white/[0.02] p-6 mt-6"
        >
            <div class="flex items-center justify-between mb-4">
                <h3
                    class="text-sm font-semibold uppercase tracking-[0.3em] text-slate-400"
                >
                    Up Next
                </h3>
                <button
                    onclick={handlePlayNext}
                    class="text-xs uppercase tracking-[0.25em] text-sky-400 hover:text-sky-300 transition-colors"
                >
                    Play Now →
                </button>
            </div>

            <button
                onclick={handlePlayNext}
                class="group flex gap-4 w-full text-left rounded-2xl border border-white/10 bg-white/[0.04] p-4 hover:bg-white/[0.08] hover:border-white/20 transition-all duration-200"
            >
                <div
                    class="relative aspect-video w-32 flex-shrink-0 overflow-hidden rounded-xl bg-black"
                >
                    <img
                        src={nextVideo.thumbnailUrl ??
                            "https://placehold.co/640x360?text=Video"}
                        alt={nextVideo.title}
                        class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                    />
                    <div
                        class="absolute inset-0 flex items-center justify-center bg-black/40 opacity-0 group-hover:opacity-100 transition-opacity"
                    >
                        <svg
                            class="h-8 w-8 text-white"
                            viewBox="0 0 24 24"
                            fill="currentColor"
                        >
                            <path d="M8 5v14l11-7z" />
                        </svg>
                    </div>
                </div>

                <div class="flex-1 min-w-0">
                    <h4
                        class="text-sm font-medium text-white mb-1 truncate group-hover:text-sky-400 transition-colors"
                    >
                        {nextVideo.title}
                    </h4>
                    <p class="text-xs text-slate-400 mb-2">
                        {nextVideo.author}
                    </p>
                    <div class="flex items-center gap-3 text-xs text-slate-500">
                        {#if nextVideo.duration}
                            <span class="flex items-center gap-1">
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="12"
                                    height="12"
                                    fill="currentColor"
                                    viewBox="0 0 16 16"
                                >
                                    <path
                                        d="M8 3.5a.5.5 0 0 0-1 0V9a.5.5 0 0 0 .252.434l3.5 2a.5.5 0 0 0 .496-.868L8 8.71V3.5z"
                                    />
                                    <path
                                        d="M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16zm7-8A7 7 0 1 1 1 8a7 7 0 0 1 14 0z"
                                    />
                                </svg>
                                {Math.floor(nextVideo.duration / 60)}:{String(
                                    nextVideo.duration % 60,
                                ).padStart(2, "0")}
                            </span>
                        {/if}
                        {#if nextVideo.views}
                            <span>{nextVideo.views} views</span>
                        {/if}
                    </div>
                </div>
            </button>

            <p class="mt-3 text-xs text-slate-500 text-center">
                Auto-play will begin when the current video ends
            </p>
        </div>
    {/if}
{:else}{/if}

<style>
    .placeholder {
        border: 1px dashed rgba(148, 163, 184, 0.3);
        border-radius: 0.75rem;
        padding: 2rem;
        text-align: center;
        color: rgba(71, 85, 105, 0.8);
        background: rgba(15, 23, 42, 0.05);
    }

    .placeholder h2 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: inherit;
    }

    .placeholder p {
        font-size: 0.875rem;
        line-height: 1.4;
        margin: 0;
    }
</style>
</file>

<file path=".history/src/lib/components/VideoInfoContainer_20251028192208.svelte">
<script lang="ts">
    import VideoInfo from "$lib/components/VideoInfo.svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import {
        getVideoById as lookupVideo,
        videosStore,
    } from "$lib/stores/library";
    import type { Video } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    const videosList = $derived($videosStore);

    function resolveVideo(id: string | null): VideoData | null {
        if (!id) return null;
        if (id === "home") {
            const fallback = videosList[0];
            return fallback ? { video: fallback } : null;
        }
        const video = lookupVideo(id);
        return video ? { video } : null;
    }

    let data = $state<VideoData | null>(null);
    let nextVideo = $state<Video | null>(null);

    $effect(() => {
        data = resolveVideo($selectedVideo.id);

        // Resolve next video data
        const nextId = selectedVideo.nextVideoId;
        nextVideo = nextId ? (lookupVideo(nextId) ?? null) : null;
    });

    function handlePlayNext() {
        selectedVideo.playNext();
    }
</script>

{#if data}
    <VideoInfo {data} />

  
{:else}{/if}

<style>
    .placeholder {
        border: 1px dashed rgba(148, 163, 184, 0.3);
        border-radius: 0.75rem;
        padding: 2rem;
        text-align: center;
        color: rgba(71, 85, 105, 0.8);
        background: rgba(15, 23, 42, 0.05);
    }

    .placeholder h2 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: inherit;
    }

    .placeholder p {
        font-size: 0.875rem;
        line-height: 1.4;
        margin: 0;
    }
</style>
</file>

<file path=".history/src/lib/server/db/users_20251017181528.ts">
import { db } from './index';
import { users, videos, userFollows } from './schema';
import type { User, UserVideoSummary } from '$lib/types/content';
import { eq } from 'drizzle-orm';

const DEFAULT_AVATAR = 'https://i.pravatar.cc/150?img=15';
const DEFAULT_THUMBNAIL = 'https://placehold.co/400x225?text=Video';

function summariseVideos(rows: Array<{
	id: string;
	title: string;
	thumbnailUrl: string | null;
	duration: number | null;
	userId: number;
}>): Map<number, UserVideoSummary[]> {
	const map = new Map<number, UserVideoSummary[]>();
	for (const row of rows) {
		const entry = map.get(row.userId) ?? [];
		entry.push({
			id: row.id,
			title: row.title,
			thumbnail: row.thumbnailUrl ?? DEFAULT_THUMBNAIL,
			duration: row.duration ?? 0
		});
		map.set(row.userId, entry);
	}
	return map;
}

function computeFollowMaps(rows: Array<{ followerId: number; followingId: number }>) {
	const followers = new Map<number, Set<number>>();
	const following = new Map<number, Set<number>>();

	for (const row of rows) {
		const followersSet = followers.get(row.followingId) ?? new Set<number>();
		followersSet.add(row.followerId);
		followers.set(row.followingId, followersSet);

		const followingSet = following.get(row.followerId) ?? new Set<number>();
		followingSet.add(row.followingId);
		following.set(row.followerId, followingSet);
	}

	return { followers, following };
}

function formatUser(row: typeof users.$inferSelect, options: {
	videos: UserVideoSummary[];
	followers: number;
	following: number;
}): User {
	const { videos, followers, following } = options;
	return {
		id: row.slug,
		name: row.name,
		avatar: row.avatar ?? DEFAULT_AVATAR,
		bio: row.bio ?? '',
		stats: {
			videos: videos.length,
			followers,
			following
		},
		videos,
		recentVideos: videos.slice(0, 3),
		subscribers: followers,
		joinedAt: row.createdAt ?? undefined
	};
}

export async function getAllUsers(): Promise<User[]> {
	const userRows = await db.select().from(users).execute();
	const videoRows = await db
		.select({
			id: videos.id,
			title: videos.title,
			thumbnailUrl: videos.thumbnailUrl,
			duration: videos.duration,
			userId: videos.userId
		})
		.from(videos)
		.execute();
	const followRows = await db.select().from(userFollows).execute();

	const videosByUser = summariseVideos(videoRows);
	const { followers, following } = computeFollowMaps(followRows);

	return userRows.map((row) =>
		formatUser(row, {
			videos: videosByUser.get(row.id) ?? [],
			followers: followers.get(row.id)?.size ?? 0,
			following: following.get(row.id)?.size ?? 0
		})
	);
}

export async function getUserBySlug(slug: string): Promise<User | null> {
	const rows = await db.select().from(users).where(eq(users.slug, slug)).limit(1).execute();
	if (!rows.length) return null;

	const user = rows[0];
	const userVideosRows = await db
		.select({
			id: videos.id,
			title: videos.title,
			thumbnailUrl: videos.thumbnailUrl,
			duration: videos.duration,
			userId: videos.userId
		})
		.from(videos)
		.where(eq(videos.userId, user.id))
		.execute();

	const followerRows = await db
		.select({
			followerId: userFollows.followerId
		})
		.from(userFollows)
		.where(eq(userFollows.followingId, user.id))
		.execute();

	const followingRows = await db
		.select({
			followingId: userFollows.followingId
		})
		.from(userFollows)
		.where(eq(userFollows.followerId, user.id))
		.execute();

	const followersSet = new Set<number>();
	const followingSet = new Set<number>();

	for (const follower of followerRows) {
		if (typeof follower.followerId === 'number') {
			followersSet.add(follower.followerId);
		}
	}

	for (const followee of followingRows) {
		if (typeof followee.followingId === 'number') {
			followingSet.add(followee.followingId);
		}
	}

	return formatUser(user, {
		videos: summariseVideos(userVideosRows).get(user.id) ?? [],
		followers: followersSet.size,
		following: followingSet.size
	});
}
</file>

<file path=".history/src/lib/server/db/users_20251023114327.ts">
// src/lib/server/db/users.ts

import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';
import * as schema from './schema';
import { users, videos, userFollows } from './schema';
import type { User, UserVideoSummary } from '$lib/types/content';
import { eq } from 'drizzle-orm';

// Define the type for your database instance
type DrizzleDb = PostgresJsDatabase<typeof schema>;

const DEFAULT_AVATAR = 'https://i.pravatar.cc/150?img=15';
const DEFAULT_THUMBNAIL = 'https://placehold.co/400x225?text=Video';

// --- Internal Helper Functions ---

function summariseVideos(rows: Array<{
    id: string;
    title: string;
    thumbnailUrl: string | null;
    duration: number | null;
    userId: number;
}>): Map<number, UserVideoSummary[]> {
    const map = new Map<number, UserVideoSummary[]>();
    for (const row of rows) {
        const entry = map.get(row.userId) ?? [];
        entry.push({
            id: row.id,
            title: row.title,
            thumbnail: row.thumbnailUrl ?? DEFAULT_THUMBNAIL,
            duration: row.duration ?? 0
        });
        map.set(row.userId, entry);
    }
    return map;
}

function computeFollowMaps(rows: Array<{ followerId: number; followingId: number }>) {
    const followers = new Map<number, Set<number>>();
    const following = new Map<number, Set<number>>();

    for (const row of rows) {
        const followersSet = followers.get(row.followingId) ?? new Set<number>();
        followersSet.add(row.followerId);
        followers.set(row.followingId, followersSet);

        const followingSet = following.get(row.followerId) ?? new Set<number>();
        followingSet.add(row.followingId);
        following.set(row.followerId, followingSet);
    }

    return { followers, following };
}

function formatUser(row: typeof users.$inferSelect, options: {
    videos: UserVideoSummary[];
    followers: number;
    following: number;
}): User {
    const { videos, followers, following } = options;
    return {
        id: row.slug,
        name: row.name,
        avatar: row.avatar ?? DEFAULT_AVATAR,
        bio: row.bio ?? '',
        stats: {
            videos: videos.length,
            followers,
            following
        },
        videos,
        recentVideos: videos.slice(0, 3),
        subscribers: followers,
        joinedAt: row.createdAt ?? undefined
    };
}

// --- Exported Database Functions ---

export async function getAllUsers(db: DrizzleDb): Promise<User[]> {
    const userRows = await db.select().from(users).execute();
    const videoRows = await db
        .select({
            id: videos.id,
            title: videos.title,
            thumbnailUrl: videos.thumbnailUrl,
            duration: videos.duration,
            userId: videos.userId
        })
        .from(videos)
        .execute();
    const followRows = await db.select().from(userFollows).execute();

    const videosByUser = summariseVideos(videoRows);
    const { followers, following } = computeFollowMaps(followRows);

    return userRows.map((row) =>
        formatUser(row, {
            videos: videosByUser.get(row.id) ?? [],
            followers: followers.get(row.id)?.size ?? 0,
            following: following.get(row.id)?.size ?? 0
        })
    );
}

export async function getUserBySlug(db: DrizzleDb, slug: string): Promise<User | null> {
    const rows = await db.select().from(users).where(eq(users.slug, slug)).limit(1).execute();
    if (!rows.length) return null;

    const user = rows[0];
    const userVideosRows = await db
        .select({
            id: videos.id,
            title: videos.title,
            thumbnailUrl: videos.thumbnailUrl,
            duration: videos.duration,
            userId: videos.userId
        })
        .from(videos)
        .where(eq(videos.userId, user.id))
        .execute();

    const followerRows = await db
        .select({
            followerId: userFollows.followerId
        })
        .from(userFollows)
        .where(eq(userFollows.followingId, user.id))
        .execute();

    const followingRows = await db
        .select({
            followingId: userFollows.followingId
        })
        .from(userFollows)
        .where(eq(userFollows.followerId, user.id))
        .execute();

    const followersSet = new Set<number>();
    const followingSet = new Set<number>();

    for (const follower of followerRows) {
        if (typeof follower.followerId === 'number') {
            followersSet.add(follower.followerId);
        }
    }

    for (const followee of followingRows) {
        if (typeof followee.followingId === 'number') {
            followingSet.add(followee.followingId);
        }
    }

    return formatUser(user, {
        videos: summariseVideos(userVideosRows).get(user.id) ?? [],
        followers: followersSet.size,
        following: followingSet.size
    });
}
</file>

<file path=".history/src/lib/server/db/videos_20251018153330.ts">
import { db } from "./index";
import { users, videos, videoTags, tags } from "./schema";
import { desc, eq, inArray } from "drizzle-orm";
import type { Video } from "$lib/types/content";

function mapRowToVideo(
  row: typeof videos.$inferSelect & {
    userName: string;
    userSlug: string;
    userAvatar: string | null;
  },
) {
  const coordinates =
    typeof row.latitude === "number" && typeof row.longitude === "number"
      ? [
          {
            name: row.title,
            coordinates: [row.longitude, row.latitude] as [number, number], // GeoJSON standard: [lon, lat]
            latitude: row.latitude,
            longitude: row.longitude,
            mapLat: row.latitude,
            mapLon: row.longitude,
            isExterior: 1,
            isDay: 1,
            isGuess: false,
            startTime: 0,
            endTime: 0,
          },
        ]
      : [];

  const uploadedAt =
    row.uploadedAt instanceof Date
      ? row.uploadedAt.toISOString()
      : (row.uploadedAt ?? undefined);
  const createdAt =
    row.createdAt instanceof Date
      ? row.createdAt.toISOString()
      : (row.createdAt ?? undefined);

  return {
    id: row.id,
    title: row.title,
    description: row.description,
    author: row.userName,
    authorId: row.userSlug,
    duration: row.duration ?? 0,
    uploadedAt,
    uploadDate: uploadedAt,
    url: row.videoUrl ?? undefined,
    videoUrl: row.videoUrl ?? undefined,
    thumbnailUrl: row.thumbnailUrl ?? undefined,
    locations: coordinates,
    transcript: row.transcript ?? "Transcript not available.",
    keywords: [],
    views: row.views ?? 0,
    likes: row.likes ?? 0,
    timestamp: uploadedAt ?? createdAt,
  } satisfies Video;
}

export async function getAllVideos(): Promise<Video[]> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      latitude: videos.latitude,
      longitude: videos.longitude,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .orderBy(desc(videos.createdAt))
    .execute();

  const videoIds = rows.map((row) => row.id);

  const tagRows = videoIds.length
    ? await db
        .select({
          videoId: videoTags.videoId,
          tag: tags.name,
        })
        .from(videoTags)
        .innerJoin(tags, eq(videoTags.tagId, tags.id))
        .where(inArray(videoTags.videoId, videoIds))
        .execute()
    : [];

  const tagsByVideo = new Map<string, string[]>();
  for (const tagRow of tagRows) {
    const list = tagsByVideo.get(tagRow.videoId) ?? [];
    if (typeof tagRow.tag === "string") {
      list.push(tagRow.tag);
      tagsByVideo.set(tagRow.videoId, list);
    }
  }

  return rows.map((row) => {
    const mapped = mapRowToVideo(row);
    mapped.keywords = tagsByVideo.get(row.id) ?? [];
    return mapped;
  });
}

export async function getVideoById(id: string): Promise<Video | null> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .where(eq(videos.id, id))
    .limit(1)
    .execute();

  if (!rows.length) return null;

  const videoTagsRows = await db
    .select({
      videoId: videoTags.videoId,
      tag: tags.name,
    })
    .from(videoTags)
    .innerJoin(tags, eq(videoTags.tagId, tags.id))
    .where(eq(videoTags.videoId, id))
    .execute();

  const video = mapRowToVideo(rows[0]);
  video.keywords = videoTagsRows.map((row) => row.tag ?? "").filter(Boolean);
  return video;
}

export async function getVideosByUserId(userId: number): Promise<Video[]> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .where(eq(videos.userId, userId))
    .orderBy(desc(videos.createdAt))
    .execute();

  const videoIds = rows.map((row) => row.id);

  const tagRows = videoIds.length
    ? await db
        .select({
          videoId: videoTags.videoId,
          tag: tags.name,
        })
        .from(videoTags)
        .innerJoin(tags, eq(videoTags.tagId, tags.id))
        .where(inArray(videoTags.videoId, videoIds))
        .execute()
    : [];

  const tagsByVideo = new Map<string, string[]>();
  for (const tagRow of tagRows) {
    const list = tagsByVideo.get(tagRow.videoId) ?? [];
    if (typeof tagRow.tag === "string") {
      list.push(tagRow.tag);
      tagsByVideo.set(tagRow.videoId, list);
    }
  }

  return rows.map((row) => {
    const mapped = mapRowToVideo(row);
    mapped.keywords = tagsByVideo.get(row.id) ?? [];
    return mapped;
  });
}
</file>

<file path=".history/src/lib/server/db/videos_20251023114416.ts">
// src/lib/server/db/videos.ts

import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';
import * as schema from './schema';
import { users, videos, videoTags, tags } from './schema';
import { desc, eq, inArray } from 'drizzle-orm';
import type { Video } from '$lib/types/content';

// Define the type for your database instance
type DrizzleDb = PostgresJsDatabase<typeof schema>;

// --- Internal Helper Function ---

function mapRowToVideo(
  row: typeof videos.$inferSelect & {
    userName: string;
    userSlug: string;
    userAvatar: string | null;
  },
) {
  const coordinates =
    typeof row.latitude === "number" && typeof row.longitude === "number"
      ? [
          {
            name: row.title,
            coordinates: [row.longitude, row.latitude] as [number, number], // GeoJSON standard: [lon, lat]
            latitude: row.latitude,
            longitude: row.longitude,
            mapLat: row.latitude,
            mapLon: row.longitude,
            isExterior: 1,
            isDay: 1,
            isGuess: false,
            startTime: 0,
            endTime: 0,
          },
        ]
      : [];

  const uploadedAt =
    row.uploadedAt instanceof Date
      ? row.uploadedAt.toISOString()
      : (row.uploadedAt ?? undefined);
  const createdAt =
    row.createdAt instanceof Date
      ? row.createdAt.toISOString()
      : (row.createdAt ?? undefined);

  return {
    id: row.id,
    title: row.title,
    description: row.description,
    author: row.userName,
    authorId: row.userSlug,
    duration: row.duration ?? 0,
    uploadedAt,
    uploadDate: uploadedAt,
    url: row.videoUrl ?? undefined,
    videoUrl: row.videoUrl ?? undefined,
    thumbnailUrl: row.thumbnailUrl ?? undefined,
    locations: coordinates,
    transcript: row.transcript ?? "Transcript not available.",
    keywords: [],
    views: row.views ?? 0,
    likes: row.likes ?? 0,
    timestamp: uploadedAt ?? createdAt,
  } satisfies Video;
}

// --- Exported Database Functions ---

export async function getAllVideos(db: DrizzleDb): Promise<Video[]> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      latitude: videos.latitude,
      longitude: videos.longitude,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .orderBy(desc(videos.createdAt))
    .execute();

  const videoIds = rows.map((row) => row.id);

  const tagRows = videoIds.length
    ? await db
        .select({
          videoId: videoTags.videoId,
          tag: tags.name,
        })
        .from(videoTags)
        .innerJoin(tags, eq(videoTags.tagId, tags.id))
        .where(inArray(videoTags.videoId, videoIds))
        .execute()
    : [];

  const tagsByVideo = new Map<string, string[]>();
  for (const tagRow of tagRows) {
    const list = tagsByVideo.get(tagRow.videoId) ?? [];
    if (typeof tagRow.tag === "string") {
      list.push(tagRow.tag);
      tagsByVideo.set(tagRow.videoId, list);
    }
  }

  return rows.map((row) => {
    const mapped = mapRowToVideo(row);
    mapped.keywords = tagsByVideo.get(row.id) ?? [];
    return mapped;
  });
}

export async function getVideoById(db: DrizzleDb, id: string): Promise<Video | null> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .where(eq(videos.id, id))
    .limit(1)
    .execute();

  if (!rows.length) return null;

  const videoTagsRows = await db
    .select({
      videoId: videoTags.videoId,
      tag: tags.name,
    })
    .from(videoTags)
    .innerJoin(tags, eq(videoTags.tagId, tags.id))
    .where(eq(videoTags.videoId, id))
    .execute();

  const video = mapRowToVideo(rows[0]);
  video.keywords = videoTagsRows.map((row) => row.tag ?? "").filter(Boolean);
  return video;
}

export async function getVideosByUserId(db: DrizzleDb, userId: number): Promise<Video[]> {
  const rows = await db
    .select({
      ...videos,
      userName: users.name,
      userSlug: users.slug,
      userAvatar: users.avatar,
    })
    .from(videos)
    .innerJoin(users, eq(videos.userId, users.id))
    .where(eq(videos.userId, userId))
    .orderBy(desc(videos.createdAt))
    .execute();

  const videoIds = rows.map((row) => row.id);

  const tagRows = videoIds.length
    ? await db
        .select({
          videoId: videoTags.videoId,
          tag: tags.name,
        })
        .from(videoTags)
        .innerJoin(tags, eq(videoTags.tagId, tags.id))
        .where(inArray(videoTags.videoId, videoIds))
        .execute()
    : [];

  const tagsByVideo = new Map<string, string[]>();
  for (const tagRow of tagRows) {
    const list = tagsByVideo.get(tagRow.videoId) ?? [];
    if (typeof tagRow.tag === "string") {
      list.push(tagRow.tag);
      tagsByVideo.set(tagRow.videoId, list);
    }
  }

  return rows.map((row) => {
    const mapped = mapRowToVideo(row);
    mapped.keywords = tagsByVideo.get(row.id) ?? [];
    return mapped;
  });
}
</file>

<file path=".history/src/routes/upload/+page.server_20251018123924.ts">
import { fail } from '@sveltejs/kit';
import type { Actions, PageServerLoad } from './$types';
import { db } from '$lib/server/db';
import { videos } from '$lib/server/db/schema';
import { getAllUsers } from '$lib/server/db/users';
import { nanoid } from 'nanoid';

export const load: PageServerLoad = async () => {
	// Get all users for the upload form (to select which user is uploading)
	const users = await getAllUsers();
	return {
		users
	};
};

export const actions: Actions = {
	upload: async ({ request }) => {
		const formData = await request.formData();

		const title = formData.get('title') as string;
		const description = formData.get('description') as string;
		const userId = formData.get('userId') as string;
		const uploadedAt = formData.get('uploadedAt') as string;
		const latitude = formData.get('latitude') as string;
		const longitude = formData.get('longitude') as string;
		const videoUrl = formData.get('videoUrl') as string;
		const thumbnailUrl = formData.get('thumbnailUrl') as string;
		const duration = formData.get('duration') as string;

		// Validation
		if (!title || title.trim().length === 0) {
			return fail(400, { error: 'Title is required', field: 'title' });
		}

		if (!description || description.trim().length === 0) {
			return fail(400, { error: 'Description is required', field: 'description' });
		}

		// Check word count (max 300 words)
		const wordCount = description.trim().split(/\s+/).length;
		if (wordCount > 300) {
			return fail(400, {
				error: `Description must be 300 words or less (currently ${wordCount} words)`,
				field: 'description'
			});
		}

		if (!userId) {
			return fail(400, { error: 'User selection is required', field: 'userId' });
		}

		if (!videoUrl || videoUrl.trim().length === 0) {
			return fail(400, { error: 'Video URL is required. Please upload a video file first.', field: 'video' });
		}

		try {
			// Generate unique video ID
			const videoId = nanoid(12);

			// Parse numeric values
			const userIdNum = parseInt(userId);
			const durationNum = duration ? parseInt(duration) : 0;
			const lat = latitude ? parseFloat(latitude) : null;
			const lon = longitude ? parseFloat(longitude) : null;

			// Validate userId is valid number
			if (isNaN(userIdNum)) {
				return fail(400, { error: 'Invalid user selection', field: 'userId' });
			}

			// Create video record
			await db.insert(videos).values({
				id: videoId,
				title: title.trim(),
				description: description.trim(),
				userId: userIdNum,
				videoUrl: videoUrl.trim(),
				thumbnailUrl: thumbnailUrl?.trim() || null,
				duration: durationNum,
				uploadedAt: uploadedAt ? new Date(uploadedAt) : new Date(),
				latitude: lat,
				longitude: lon,
				views: 0,
				likes: 0,
				transcript: null
			});

			return {
				success: true,
				videoId
			};
		} catch (error) {
			console.error('Upload error:', error);
			return fail(500, {
				error: 'Failed to save video. Please try again.',
				details: error instanceof Error ? error.message : 'Unknown error'
			});
		}
	}
};
</file>

<file path=".history/src/routes/upload/+page.server_20251023114733.ts">
// src/routes/upload/+page.server.ts

import { fail } from '@sveltejs/kit';
import type { Actions, PageServerLoad } from './$types';
import { getDb } from '$lib/server/db'; // <-- FIXED: Import getDb factory
import { videos } from '$lib/server/db/schema';
import { getAllUsers } from '$lib/server/db/users';
import { nanoid } from 'nanoid';

export const load: PageServerLoad = async ({ platform }) => {
	// 1. Check for the database binding
	if (!platform?.env.DATABASE_URL) {
		console.error('DATABASE_URL binding not found in load()');
		return { users: [] };
	}

	// 2. Create the db instance
	const db = getDb(platform.env.DATABASE_URL);

	// 3. Pass the db instance to your query function
	const users = await getAllUsers(db);
	return {
		users
	};
};

export const actions: Actions = {
	upload: async ({ request, platform }) => {
		// 1. Check for the database binding
		if (!platform?.env.DATABASE_URL) {
			console.error('DATABASE_URL binding not found in action()');
			return fail(500, { error: 'Database not configured.' });
		}

		// 2. Create the db instance
		const db = getDb(platform.env.DATABASE_URL);

		const formData = await request.formData();

		const title = formData.get('title') as string;
		const description = formData.get('description') as string;
		const userId = formData.get('userId') as string;
		const uploadedAt = formData.get('uploadedAt') as string;
		const latitude = formData.get('latitude') as string;
		const longitude = formData.get('longitude') as string;
		const videoUrl = formData.get('videoUrl') as string;
		const thumbnailUrl = formData.get('thumbnailUrl') as string;
		const duration = formData.get('duration') as string;

		// Validation
		if (!title || title.trim().length === 0) {
			return fail(400, { error: 'Title is required', field: 'title' });
		}

		if (!description || description.trim().length === 0) {
			return fail(400, { error: 'Description is required', field: 'description' });
		}

		// Check word count (max 300 words)
		const wordCount = description.trim().split(/\s+/).length;
		if (wordCount > 300) {
			return fail(400, {
				error: `Description must be 300 words or less (currently ${wordCount} words)`,
				field: 'description'
			});
		}

		if (!userId) {
			return fail(400, { error: 'User selection is required', field: 'userId' });
		}

		if (!videoUrl || videoUrl.trim().length === 0) {
			return fail(400, { error: 'Video URL is required. Please upload a video file first.', field: 'video' });
		}

		try {
			// Generate unique video ID
			const videoId = nanoid(12);

			// Parse numeric values
			const userIdNum = parseInt(userId);
			const durationNum = duration ? parseInt(duration) : 0;
			const lat = latitude ? parseFloat(latitude) : null;
			const lon = longitude ? parseFloat(longitude) : null;

			// Validate userId is valid number
			if (isNaN(userIdNum)) {
				return fail(400, { error: 'Invalid user selection', field: 'userId' });
			}

			// 3. Use the db instance to insert
			await db.insert(videos).values({
				id: videoId,
				title: title.trim(),
				description: description.trim(),
				userId: userIdNum,
				videoUrl: videoUrl.trim(),
				thumbnailUrl: thumbnailUrl?.trim() || null,
				duration: durationNum,
				uploadedAt: uploadedAt ? new Date(uploadedAt) : new Date(),
				latitude: lat,
				longitude: lon,
				views: 0,
				likes: 0,
				transcript: null
			});

			return {
				success: true,
				videoId
			};
		} catch (error) {
			console.error('Upload error:', error);
			return fail(500, {
				error: 'Failed to save video. Please try again.',
				details: error instanceof Error ? error.message : 'Unknown error'
			});
		}
	}
};
</file>

<file path=".history/src/routes/+page_20251028185051.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid  lg:grid-cols-2">
			<article class="space-y-4   ">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 ">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185056.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid  lg:grid-cols-2">
			<article class="space-y-4   ">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 ">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185609.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185634.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185643.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-2 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185645.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185654.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold mb-2 text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185656.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold mb-1 text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185716.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/4 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold mb-1 text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185718.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold mb-1 text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185721.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x divide-white/10 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold mb-1 text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185746.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x divide-white border-white/19 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold mb-1 text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028185951.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:divide-x lg:divide-[rgba(255,255,255,0.1)] lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Videos</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="text-[11px] uppercase tracking-[0.35em] text-slate-400">Latest Sounds</h2>
				</header>

				<ul class="space-y-3">
					{#each latestSounds as sound (sound.id)}
						<li
							class="group flex items-center "
						>
						
							<div class="flex flex-1 flex-col gap-2 border-b pb-4 border-white/10">
								<div class="flex items-center gap-3">
									<button
										type="button"
										class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
										aria-label={`Play ${sound.title}`}
									>
										<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
											<path d="M2 1.5v11l9-5.5-9-5.5z" />
										</svg>
									</button>
									<div class="flex flex-col">
									<p class="truncate text-sm font-semibold mb-1 text-white">
										{sound.title}
									</p>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
									</div>
								</div>
								</div>
								
							</div>
						</li>
					{/each}
				</ul>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190756.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
					<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-5 w-5 text-slate-400/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190808.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-5 w-5 text-slate-400/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M2 5h14v4h2V7h2V5h2v14h-2v-2h-2v-2h-2v4H2zm2 12h10V7H4z"
							/>
						</svg>

						<svg class="h-5 w-5 text-slate-400/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-5 w-5 text-slate-400/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190812.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-5 w-5 text-slate-400/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-5 w-5 text-slate-400/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190819.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-4 w-4 text-slate-400/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-5 w-5 text-slate-400/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190828.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-4 w-4 text-slate-400/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-400/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190842.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-4 w-4 text-slate-400/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190853.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190856.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-4 w-4 text-slate-200" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190859.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-4 w-4 text-slate-300" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190904.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190914.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-200">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190922.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-200">
			

						<svg class="h-4 w-4 text-slate-200" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190929.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-200">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190932.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-400">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190940.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190946.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-slate-200"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190950.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-slate-200/90"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028190954.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-slate-200"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191005.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191011.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="orange"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191029.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="orange"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="orange"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191046.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191138.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0 divide-x">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191152.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0 divide-x divide-[rgba(255,255,255,0.1)]">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191229.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0 divide-x divide-[rgba(255,255,255,0.1)]">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191236.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0 divide-x divide-[rgba(255,255,255,0.1)]">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 ">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191241.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0 divide-x divide-[rgba(255,255,255,0.1)]">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2  lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191254.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191307.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191314.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg>
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191326.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.1)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191341.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.03)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191343.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.05)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191346.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191355.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8  lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191413.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8  lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191415.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8  lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191428.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-3 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191446.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191510.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04]  shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191514.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] "
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191521.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] p-5"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191525.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] p-8"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191540.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 border-l-2 bg-white/[0.04] p-8"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191544.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border  border-l-2 bg-white/[0.04] p-8"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191548.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  border-white/10 border-l-2 bg-white/[0.04] p-8"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191556.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191621.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px]  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191625.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191644.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191648.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm font-bold  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191653.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm font-bold border-b  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191657.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm font-bold border-b w-full  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191702.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191722.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> 
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191736.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<svg class="h-4 w-3 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> 
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191740.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> 
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191742.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-1 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> 
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191744.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-2 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg> 
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191810.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-2 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>  -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-3 text-[11px] uppercase tracking-[0.35em] text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/src/routes/+page_20251028191819.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden  bg-white/[0.04]"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-2 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>  -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-2 text-sm font-bold border-b w-full pb-2  text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path=".history/package-lock_20251022225014.json">
{
	"name": "rushesbe",
	"version": "0.0.1",
	"lockfileVersion": 3,
	"requires": true,
	"packages": {
		"": {
			"name": "rushesbe",
			"version": "0.0.1",
			"dependencies": {
				"postgres": "^3.4.7"
			},
			"devDependencies": {
				"@sveltejs/adapter-cloudflare": "^7.2.4",
				"@sveltejs/kit": "^2.43.2",
				"@sveltejs/vite-plugin-svelte": "^6.2.0",
				"@tailwindcss/forms": "^0.5.10",
				"@tailwindcss/typography": "^0.5.18",
				"@tailwindcss/vite": "^4.1.13",
				"@types/node": "^22",
				"@vitest/browser": "^3.2.4",
				"drizzle-kit": "^0.31.4",
				"drizzle-orm": "^0.44.5",
				"playwright": "^1.55.1",
				"prettier": "^3.6.2",
				"prettier-plugin-svelte": "^3.4.0",
				"prettier-plugin-tailwindcss": "^0.6.14",
				"svelte": "^5.39.5",
				"svelte-check": "^4.3.2",
				"tailwindcss": "^4.1.13",
				"typescript": "^5.9.2",
				"vite": "^7.1.7",
				"vitest": "^3.2.4",
				"vitest-browser-svelte": "^1.1.0",
				"wrangler": "^4.44.0"
			}
		},
		"node_modules/@babel/code-frame": {
			"version": "7.27.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@babel/helper-validator-identifier": "^7.27.1",
				"js-tokens": "^4.0.0",
				"picocolors": "^1.1.1"
			},
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/helper-validator-identifier": {
			"version": "7.27.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/runtime": {
			"version": "7.28.4",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@cloudflare/kv-asset-handler": {
			"version": "0.4.0",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"dependencies": {
				"mime": "^3.0.0"
			},
			"engines": {
				"node": ">=18.0.0"
			}
		},
		"node_modules/@cloudflare/unenv-preset": {
			"version": "2.7.8",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"peerDependencies": {
				"unenv": "2.0.0-rc.21",
				"workerd": "^1.20250927.0"
			},
			"peerDependenciesMeta": {
				"workerd": {
					"optional": true
				}
			}
		},
		"node_modules/@cloudflare/workerd-darwin-arm64": {
			"version": "1.20251011.0",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=16"
			}
		},
		"node_modules/@cloudflare/workers-types": {
			"version": "4.20251014.0",
			"dev": true,
			"license": "MIT OR Apache-2.0"
		},
		"node_modules/@cspotcode/source-map-support": {
			"version": "0.8.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/trace-mapping": "0.3.9"
			},
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping": {
			"version": "0.3.9",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/resolve-uri": "^3.0.3",
				"@jridgewell/sourcemap-codec": "^1.4.10"
			}
		},
		"node_modules/@drizzle-team/brocli": {
			"version": "0.10.2",
			"dev": true,
			"license": "Apache-2.0"
		},
		"node_modules/@esbuild-kit/core-utils": {
			"version": "3.3.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"esbuild": "~0.18.20",
				"source-map-support": "^0.5.21"
			}
		},
		"node_modules/@esbuild-kit/core-utils/node_modules/esbuild": {
			"version": "0.18.20",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=12"
			},
			"optionalDependencies": {
				"@esbuild/android-arm": "0.18.20",
				"@esbuild/android-arm64": "0.18.20",
				"@esbuild/android-x64": "0.18.20",
				"@esbuild/darwin-arm64": "0.18.20",
				"@esbuild/darwin-x64": "0.18.20",
				"@esbuild/freebsd-arm64": "0.18.20",
				"@esbuild/freebsd-x64": "0.18.20",
				"@esbuild/linux-arm": "0.18.20",
				"@esbuild/linux-arm64": "0.18.20",
				"@esbuild/linux-ia32": "0.18.20",
				"@esbuild/linux-loong64": "0.18.20",
				"@esbuild/linux-mips64el": "0.18.20",
				"@esbuild/linux-ppc64": "0.18.20",
				"@esbuild/linux-riscv64": "0.18.20",
				"@esbuild/linux-s390x": "0.18.20",
				"@esbuild/linux-x64": "0.18.20",
				"@esbuild/netbsd-x64": "0.18.20",
				"@esbuild/openbsd-x64": "0.18.20",
				"@esbuild/sunos-x64": "0.18.20",
				"@esbuild/win32-arm64": "0.18.20",
				"@esbuild/win32-ia32": "0.18.20",
				"@esbuild/win32-x64": "0.18.20"
			}
		},
		"node_modules/@esbuild-kit/core-utils/node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
			"version": "0.18.20",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/@esbuild-kit/esm-loader": {
			"version": "2.6.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@esbuild-kit/core-utils": "^3.3.2",
				"get-tsconfig": "^4.7.0"
			}
		},
		"node_modules/@esbuild/darwin-arm64": {
			"version": "0.25.11",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/@img/sharp-darwin-arm64": {
			"version": "0.33.5",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^18.17.0 || ^20.3.0 || >=21.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/libvips"
			},
			"optionalDependencies": {
				"@img/sharp-libvips-darwin-arm64": "1.0.4"
			}
		},
		"node_modules/@img/sharp-libvips-darwin-arm64": {
			"version": "1.0.4",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "LGPL-3.0-or-later",
			"optional": true,
			"os": [
				"darwin"
			],
			"funding": {
				"url": "https://opencollective.com/libvips"
			}
		},
		"node_modules/@jridgewell/gen-mapping": {
			"version": "0.3.13",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.5.0",
				"@jridgewell/trace-mapping": "^0.3.24"
			}
		},
		"node_modules/@jridgewell/remapping": {
			"version": "2.3.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/gen-mapping": "^0.3.5",
				"@jridgewell/trace-mapping": "^0.3.24"
			}
		},
		"node_modules/@jridgewell/resolve-uri": {
			"version": "3.1.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.0.0"
			}
		},
		"node_modules/@jridgewell/sourcemap-codec": {
			"version": "1.5.5",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@jridgewell/trace-mapping": {
			"version": "0.3.31",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/resolve-uri": "^3.1.0",
				"@jridgewell/sourcemap-codec": "^1.4.14"
			}
		},
		"node_modules/@polka/url": {
			"version": "1.0.0-next.29",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@poppinss/colors": {
			"version": "4.1.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"kleur": "^4.1.5"
			}
		},
		"node_modules/@poppinss/dumper": {
			"version": "0.6.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/colors": "^4.1.5",
				"@sindresorhus/is": "^7.0.2",
				"supports-color": "^10.0.0"
			}
		},
		"node_modules/@poppinss/exception": {
			"version": "1.2.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@rollup/rollup-darwin-arm64": {
			"version": "4.52.5",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			]
		},
		"node_modules/@sindresorhus/is": {
			"version": "7.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			},
			"funding": {
				"url": "https://github.com/sindresorhus/is?sponsor=1"
			}
		},
		"node_modules/@speed-highlight/core": {
			"version": "1.2.7",
			"dev": true,
			"license": "CC0-1.0"
		},
		"node_modules/@standard-schema/spec": {
			"version": "1.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@sveltejs/acorn-typescript": {
			"version": "1.0.6",
			"dev": true,
			"license": "MIT",
			"peerDependencies": {
				"acorn": "^8.9.0"
			}
		},
		"node_modules/@sveltejs/adapter-cloudflare": {
			"version": "7.2.4",
			"resolved": "https://registry.npmjs.org/@sveltejs/adapter-cloudflare/-/adapter-cloudflare-7.2.4.tgz",
			"integrity": "sha512-uD8VlOuGXGuZWL+zbBYSjtmC4WDtlonUodfqAZ/COd5uIy2Z0QptIicB/nkTrGNI9sbmzgf7z0N09CHyWYlUvQ==",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@cloudflare/workers-types": "^4.20250507.0",
				"worktop": "0.8.0-next.18"
			},
			"peerDependencies": {
				"@sveltejs/kit": "^2.0.0",
				"wrangler": "^4.0.0"
			}
		},
		"node_modules/@sveltejs/kit": {
			"version": "2.47.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@standard-schema/spec": "^1.0.0",
				"@sveltejs/acorn-typescript": "^1.0.5",
				"@types/cookie": "^0.6.0",
				"acorn": "^8.14.1",
				"cookie": "^0.6.0",
				"devalue": "^5.3.2",
				"esm-env": "^1.2.2",
				"kleur": "^4.1.5",
				"magic-string": "^0.30.5",
				"mrmime": "^2.0.0",
				"sade": "^1.8.1",
				"set-cookie-parser": "^2.6.0",
				"sirv": "^3.0.0"
			},
			"bin": {
				"svelte-kit": "svelte-kit.js"
			},
			"engines": {
				"node": ">=18.13"
			},
			"peerDependencies": {
				"@opentelemetry/api": "^1.0.0",
				"@sveltejs/vite-plugin-svelte": "^3.0.0 || ^4.0.0-next.1 || ^5.0.0 || ^6.0.0-next.0",
				"svelte": "^4.0.0 || ^5.0.0-next.0",
				"vite": "^5.0.3 || ^6.0.0 || ^7.0.0-beta.0"
			},
			"peerDependenciesMeta": {
				"@opentelemetry/api": {
					"optional": true
				}
			}
		},
		"node_modules/@sveltejs/vite-plugin-svelte": {
			"version": "6.2.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@sveltejs/vite-plugin-svelte-inspector": "^5.0.0",
				"debug": "^4.4.1",
				"deepmerge": "^4.3.1",
				"magic-string": "^0.30.17",
				"vitefu": "^1.1.1"
			},
			"engines": {
				"node": "^20.19 || ^22.12 || >=24"
			},
			"peerDependencies": {
				"svelte": "^5.0.0",
				"vite": "^6.3.0 || ^7.0.0"
			}
		},
		"node_modules/@sveltejs/vite-plugin-svelte-inspector": {
			"version": "5.0.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"debug": "^4.4.1"
			},
			"engines": {
				"node": "^20.19 || ^22.12 || >=24"
			},
			"peerDependencies": {
				"@sveltejs/vite-plugin-svelte": "^6.0.0-next.0",
				"svelte": "^5.0.0",
				"vite": "^6.3.0 || ^7.0.0"
			}
		},
		"node_modules/@tailwindcss/forms": {
			"version": "0.5.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mini-svg-data-uri": "^1.2.3"
			},
			"peerDependencies": {
				"tailwindcss": ">=3.0.0 || >= 3.0.0-alpha.1 || >= 4.0.0-alpha.20 || >= 4.0.0-beta.1"
			}
		},
		"node_modules/@tailwindcss/node": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/remapping": "^2.3.4",
				"enhanced-resolve": "^5.18.3",
				"jiti": "^2.6.0",
				"lightningcss": "1.30.2",
				"magic-string": "^0.30.19",
				"source-map-js": "^1.2.1",
				"tailwindcss": "4.1.15"
			}
		},
		"node_modules/@tailwindcss/oxide": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 10"
			},
			"optionalDependencies": {
				"@tailwindcss/oxide-android-arm64": "4.1.15",
				"@tailwindcss/oxide-darwin-arm64": "4.1.15",
				"@tailwindcss/oxide-darwin-x64": "4.1.15",
				"@tailwindcss/oxide-freebsd-x64": "4.1.15",
				"@tailwindcss/oxide-linux-arm-gnueabihf": "4.1.15",
				"@tailwindcss/oxide-linux-arm64-gnu": "4.1.15",
				"@tailwindcss/oxide-linux-arm64-musl": "4.1.15",
				"@tailwindcss/oxide-linux-x64-gnu": "4.1.15",
				"@tailwindcss/oxide-linux-x64-musl": "4.1.15",
				"@tailwindcss/oxide-wasm32-wasi": "4.1.15",
				"@tailwindcss/oxide-win32-arm64-msvc": "4.1.15",
				"@tailwindcss/oxide-win32-x64-msvc": "4.1.15"
			}
		},
		"node_modules/@tailwindcss/oxide-darwin-arm64": {
			"version": "4.1.15",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">= 10"
			}
		},
		"node_modules/@tailwindcss/typography": {
			"version": "0.5.19",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"postcss-selector-parser": "6.0.10"
			},
			"peerDependencies": {
				"tailwindcss": ">=3.0.0 || insiders || >=4.0.0-alpha.20 || >=4.0.0-beta.1"
			}
		},
		"node_modules/@tailwindcss/vite": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@tailwindcss/node": "4.1.15",
				"@tailwindcss/oxide": "4.1.15",
				"tailwindcss": "4.1.15"
			},
			"peerDependencies": {
				"vite": "^5.2.0 || ^6 || ^7"
			}
		},
		"node_modules/@testing-library/dom": {
			"version": "10.4.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@babel/code-frame": "^7.10.4",
				"@babel/runtime": "^7.12.5",
				"@types/aria-query": "^5.0.1",
				"aria-query": "5.3.0",
				"dom-accessibility-api": "^0.5.9",
				"lz-string": "^1.5.0",
				"picocolors": "1.1.1",
				"pretty-format": "^27.0.2"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/@testing-library/dom/node_modules/aria-query": {
			"version": "5.3.0",
			"dev": true,
			"license": "Apache-2.0",
			"dependencies": {
				"dequal": "^2.0.3"
			}
		},
		"node_modules/@testing-library/user-event": {
			"version": "14.6.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12",
				"npm": ">=6"
			},
			"peerDependencies": {
				"@testing-library/dom": ">=7.21.4"
			}
		},
		"node_modules/@types/aria-query": {
			"version": "5.0.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/chai": {
			"version": "5.2.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/deep-eql": "*",
				"assertion-error": "^2.0.1"
			}
		},
		"node_modules/@types/cookie": {
			"version": "0.6.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/deep-eql": {
			"version": "4.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/estree": {
			"version": "1.0.8",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/node": {
			"version": "22.18.12",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"undici-types": "~6.21.0"
			}
		},
		"node_modules/@vitest/browser": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@testing-library/dom": "^10.4.0",
				"@testing-library/user-event": "^14.6.1",
				"@vitest/mocker": "3.2.4",
				"@vitest/utils": "3.2.4",
				"magic-string": "^0.30.17",
				"sirv": "^3.0.1",
				"tinyrainbow": "^2.0.0",
				"ws": "^8.18.2"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"playwright": "*",
				"vitest": "3.2.4",
				"webdriverio": "^7.0.0 || ^8.0.0 || ^9.0.0"
			},
			"peerDependenciesMeta": {
				"playwright": {
					"optional": true
				},
				"safaridriver": {
					"optional": true
				},
				"webdriverio": {
					"optional": true
				}
			}
		},
		"node_modules/@vitest/expect": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/chai": "^5.2.2",
				"@vitest/spy": "3.2.4",
				"@vitest/utils": "3.2.4",
				"chai": "^5.2.0",
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/mocker": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/spy": "3.2.4",
				"estree-walker": "^3.0.3",
				"magic-string": "^0.30.17"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"msw": "^2.4.9",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
			},
			"peerDependenciesMeta": {
				"msw": {
					"optional": true
				},
				"vite": {
					"optional": true
				}
			}
		},
		"node_modules/@vitest/pretty-format": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/runner": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/utils": "3.2.4",
				"pathe": "^2.0.3",
				"strip-literal": "^3.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/snapshot": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/pretty-format": "3.2.4",
				"magic-string": "^0.30.17",
				"pathe": "^2.0.3"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/spy": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"tinyspy": "^4.0.3"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/utils": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/pretty-format": "3.2.4",
				"loupe": "^3.1.4",
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/acorn": {
			"version": "8.15.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"acorn": "bin/acorn"
			},
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/acorn-walk": {
			"version": "8.3.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/ansi-regex": {
			"version": "5.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/ansi-styles": {
			"version": "5.2.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/chalk/ansi-styles?sponsor=1"
			}
		},
		"node_modules/aria-query": {
			"version": "5.3.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">= 0.4"
			}
		},
		"node_modules/assertion-error": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/axobject-query": {
			"version": "4.1.0",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">= 0.4"
			}
		},
		"node_modules/blake3-wasm": {
			"version": "2.1.5",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/buffer-from": {
			"version": "1.1.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/cac": {
			"version": "6.7.14",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/chai": {
			"version": "5.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"assertion-error": "^2.0.1",
				"check-error": "^2.1.1",
				"deep-eql": "^5.0.1",
				"loupe": "^3.1.0",
				"pathval": "^2.0.0"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/check-error": {
			"version": "2.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 16"
			}
		},
		"node_modules/chokidar": {
			"version": "4.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"readdirp": "^4.0.1"
			},
			"engines": {
				"node": ">= 14.16.0"
			},
			"funding": {
				"url": "https://paulmillr.com/funding/"
			}
		},
		"node_modules/clsx": {
			"version": "2.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/color": {
			"version": "4.2.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-convert": "^2.0.1",
				"color-string": "^1.9.0"
			},
			"engines": {
				"node": ">=12.5.0"
			}
		},
		"node_modules/color-convert": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-name": "~1.1.4"
			},
			"engines": {
				"node": ">=7.0.0"
			}
		},
		"node_modules/color-name": {
			"version": "1.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/color-string": {
			"version": "1.9.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-name": "^1.0.0",
				"simple-swizzle": "^0.2.2"
			}
		},
		"node_modules/cookie": {
			"version": "0.6.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 0.6"
			}
		},
		"node_modules/cssesc": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"cssesc": "bin/cssesc"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/debug": {
			"version": "4.4.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"ms": "^2.1.3"
			},
			"engines": {
				"node": ">=6.0"
			},
			"peerDependenciesMeta": {
				"supports-color": {
					"optional": true
				}
			}
		},
		"node_modules/deep-eql": {
			"version": "5.0.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/deepmerge": {
			"version": "4.3.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/defu": {
			"version": "6.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/dequal": {
			"version": "2.0.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/detect-libc": {
			"version": "2.1.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/devalue": {
			"version": "5.4.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/dom-accessibility-api": {
			"version": "0.5.16",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/drizzle-kit": {
			"version": "0.31.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@drizzle-team/brocli": "^0.10.2",
				"@esbuild-kit/esm-loader": "^2.5.5",
				"esbuild": "^0.25.4",
				"esbuild-register": "^3.5.0"
			},
			"bin": {
				"drizzle-kit": "bin.cjs"
			}
		},
		"node_modules/drizzle-orm": {
			"version": "0.44.6",
			"dev": true,
			"license": "Apache-2.0",
			"peerDependencies": {
				"@aws-sdk/client-rds-data": ">=3",
				"@cloudflare/workers-types": ">=4",
				"@electric-sql/pglite": ">=0.2.0",
				"@libsql/client": ">=0.10.0",
				"@libsql/client-wasm": ">=0.10.0",
				"@neondatabase/serverless": ">=0.10.0",
				"@op-engineering/op-sqlite": ">=2",
				"@opentelemetry/api": "^1.4.1",
				"@planetscale/database": ">=1.13",
				"@prisma/client": "*",
				"@tidbcloud/serverless": "*",
				"@types/better-sqlite3": "*",
				"@types/pg": "*",
				"@types/sql.js": "*",
				"@upstash/redis": ">=1.34.7",
				"@vercel/postgres": ">=0.8.0",
				"@xata.io/client": "*",
				"better-sqlite3": ">=7",
				"bun-types": "*",
				"expo-sqlite": ">=14.0.0",
				"gel": ">=2",
				"knex": "*",
				"kysely": "*",
				"mysql2": ">=2",
				"pg": ">=8",
				"postgres": ">=3",
				"sql.js": ">=1",
				"sqlite3": ">=5"
			},
			"peerDependenciesMeta": {
				"@aws-sdk/client-rds-data": {
					"optional": true
				},
				"@cloudflare/workers-types": {
					"optional": true
				},
				"@electric-sql/pglite": {
					"optional": true
				},
				"@libsql/client": {
					"optional": true
				},
				"@libsql/client-wasm": {
					"optional": true
				},
				"@neondatabase/serverless": {
					"optional": true
				},
				"@op-engineering/op-sqlite": {
					"optional": true
				},
				"@opentelemetry/api": {
					"optional": true
				},
				"@planetscale/database": {
					"optional": true
				},
				"@prisma/client": {
					"optional": true
				},
				"@tidbcloud/serverless": {
					"optional": true
				},
				"@types/better-sqlite3": {
					"optional": true
				},
				"@types/pg": {
					"optional": true
				},
				"@types/sql.js": {
					"optional": true
				},
				"@upstash/redis": {
					"optional": true
				},
				"@vercel/postgres": {
					"optional": true
				},
				"@xata.io/client": {
					"optional": true
				},
				"better-sqlite3": {
					"optional": true
				},
				"bun-types": {
					"optional": true
				},
				"expo-sqlite": {
					"optional": true
				},
				"gel": {
					"optional": true
				},
				"knex": {
					"optional": true
				},
				"kysely": {
					"optional": true
				},
				"mysql2": {
					"optional": true
				},
				"pg": {
					"optional": true
				},
				"postgres": {
					"optional": true
				},
				"prisma": {
					"optional": true
				},
				"sql.js": {
					"optional": true
				},
				"sqlite3": {
					"optional": true
				}
			}
		},
		"node_modules/enhanced-resolve": {
			"version": "5.18.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"graceful-fs": "^4.2.4",
				"tapable": "^2.2.0"
			},
			"engines": {
				"node": ">=10.13.0"
			}
		},
		"node_modules/error-stack-parser-es": {
			"version": "1.0.5",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/sponsors/antfu"
			}
		},
		"node_modules/es-module-lexer": {
			"version": "1.7.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/esbuild": {
			"version": "0.25.11",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"@esbuild/aix-ppc64": "0.25.11",
				"@esbuild/android-arm": "0.25.11",
				"@esbuild/android-arm64": "0.25.11",
				"@esbuild/android-x64": "0.25.11",
				"@esbuild/darwin-arm64": "0.25.11",
				"@esbuild/darwin-x64": "0.25.11",
				"@esbuild/freebsd-arm64": "0.25.11",
				"@esbuild/freebsd-x64": "0.25.11",
				"@esbuild/linux-arm": "0.25.11",
				"@esbuild/linux-arm64": "0.25.11",
				"@esbuild/linux-ia32": "0.25.11",
				"@esbuild/linux-loong64": "0.25.11",
				"@esbuild/linux-mips64el": "0.25.11",
				"@esbuild/linux-ppc64": "0.25.11",
				"@esbuild/linux-riscv64": "0.25.11",
				"@esbuild/linux-s390x": "0.25.11",
				"@esbuild/linux-x64": "0.25.11",
				"@esbuild/netbsd-arm64": "0.25.11",
				"@esbuild/netbsd-x64": "0.25.11",
				"@esbuild/openbsd-arm64": "0.25.11",
				"@esbuild/openbsd-x64": "0.25.11",
				"@esbuild/openharmony-arm64": "0.25.11",
				"@esbuild/sunos-x64": "0.25.11",
				"@esbuild/win32-arm64": "0.25.11",
				"@esbuild/win32-ia32": "0.25.11",
				"@esbuild/win32-x64": "0.25.11"
			}
		},
		"node_modules/esbuild-register": {
			"version": "3.6.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"debug": "^4.3.4"
			},
			"peerDependencies": {
				"esbuild": ">=0.12 <1"
			}
		},
		"node_modules/esm-env": {
			"version": "1.2.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/esrap": {
			"version": "2.1.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.4.15"
			}
		},
		"node_modules/estree-walker": {
			"version": "3.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "^1.0.0"
			}
		},
		"node_modules/exit-hook": {
			"version": "2.2.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/expect-type": {
			"version": "1.2.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">=12.0.0"
			}
		},
		"node_modules/exsolve": {
			"version": "1.0.7",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/fdir": {
			"version": "6.5.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12.0.0"
			},
			"peerDependencies": {
				"picomatch": "^3 || ^4"
			},
			"peerDependenciesMeta": {
				"picomatch": {
					"optional": true
				}
			}
		},
		"node_modules/fsevents": {
			"version": "2.3.2",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/get-tsconfig": {
			"version": "4.13.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"resolve-pkg-maps": "^1.0.0"
			},
			"funding": {
				"url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
			}
		},
		"node_modules/glob-to-regexp": {
			"version": "0.4.1",
			"dev": true,
			"license": "BSD-2-Clause"
		},
		"node_modules/graceful-fs": {
			"version": "4.2.11",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/is-arrayish": {
			"version": "0.3.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/is-reference": {
			"version": "3.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "^1.0.6"
			}
		},
		"node_modules/jiti": {
			"version": "2.6.1",
			"dev": true,
			"license": "MIT",
			"bin": {
				"jiti": "lib/jiti-cli.mjs"
			}
		},
		"node_modules/js-tokens": {
			"version": "4.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/kleur": {
			"version": "4.1.5",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/lightningcss": {
			"version": "1.30.2",
			"dev": true,
			"license": "MPL-2.0",
			"dependencies": {
				"detect-libc": "^2.0.3"
			},
			"engines": {
				"node": ">= 12.0.0"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/parcel"
			},
			"optionalDependencies": {
				"lightningcss-android-arm64": "1.30.2",
				"lightningcss-darwin-arm64": "1.30.2",
				"lightningcss-darwin-x64": "1.30.2",
				"lightningcss-freebsd-x64": "1.30.2",
				"lightningcss-linux-arm-gnueabihf": "1.30.2",
				"lightningcss-linux-arm64-gnu": "1.30.2",
				"lightningcss-linux-arm64-musl": "1.30.2",
				"lightningcss-linux-x64-gnu": "1.30.2",
				"lightningcss-linux-x64-musl": "1.30.2",
				"lightningcss-win32-arm64-msvc": "1.30.2",
				"lightningcss-win32-x64-msvc": "1.30.2"
			}
		},
		"node_modules/lightningcss-darwin-arm64": {
			"version": "1.30.2",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MPL-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">= 12.0.0"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/parcel"
			}
		},
		"node_modules/locate-character": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/loupe": {
			"version": "3.2.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/lz-string": {
			"version": "1.5.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"lz-string": "bin/bin.js"
			}
		},
		"node_modules/magic-string": {
			"version": "0.30.19",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.5.5"
			}
		},
		"node_modules/mime": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"mime": "cli.js"
			},
			"engines": {
				"node": ">=10.0.0"
			}
		},
		"node_modules/mini-svg-data-uri": {
			"version": "1.4.4",
			"dev": true,
			"license": "MIT",
			"bin": {
				"mini-svg-data-uri": "cli.js"
			}
		},
		"node_modules/miniflare": {
			"version": "4.20251011.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@cspotcode/source-map-support": "0.8.1",
				"acorn": "8.14.0",
				"acorn-walk": "8.3.2",
				"exit-hook": "2.2.1",
				"glob-to-regexp": "0.4.1",
				"sharp": "^0.33.5",
				"stoppable": "1.1.0",
				"undici": "7.14.0",
				"workerd": "1.20251011.0",
				"ws": "8.18.0",
				"youch": "4.1.0-beta.10",
				"zod": "3.22.3"
			},
			"bin": {
				"miniflare": "bootstrap.js"
			},
			"engines": {
				"node": ">=18.0.0"
			}
		},
		"node_modules/miniflare/node_modules/acorn": {
			"version": "8.14.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"acorn": "bin/acorn"
			},
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/miniflare/node_modules/ws": {
			"version": "8.18.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10.0.0"
			},
			"peerDependencies": {
				"bufferutil": "^4.0.1",
				"utf-8-validate": ">=5.0.2"
			},
			"peerDependenciesMeta": {
				"bufferutil": {
					"optional": true
				},
				"utf-8-validate": {
					"optional": true
				}
			}
		},
		"node_modules/mri": {
			"version": "1.2.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/mrmime": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/ms": {
			"version": "2.1.3",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/nanoid": {
			"version": "3.3.11",
			"dev": true,
			"funding": [
				{
					"type": "github",
					"url": "https://github.com/sponsors/ai"
				}
			],
			"license": "MIT",
			"bin": {
				"nanoid": "bin/nanoid.cjs"
			},
			"engines": {
				"node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
			}
		},
		"node_modules/ohash": {
			"version": "2.0.11",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/path-to-regexp": {
			"version": "6.3.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/pathe": {
			"version": "2.0.3",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/pathval": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 14.16"
			}
		},
		"node_modules/picocolors": {
			"version": "1.1.1",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/picomatch": {
			"version": "4.0.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12"
			},
			"funding": {
				"url": "https://github.com/sponsors/jonschlinkert"
			}
		},
		"node_modules/playwright": {
			"version": "1.56.1",
			"dev": true,
			"license": "Apache-2.0",
			"dependencies": {
				"playwright-core": "1.56.1"
			},
			"bin": {
				"playwright": "cli.js"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"fsevents": "2.3.2"
			}
		},
		"node_modules/playwright-core": {
			"version": "1.56.1",
			"dev": true,
			"license": "Apache-2.0",
			"bin": {
				"playwright-core": "cli.js"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/postcss": {
			"version": "8.5.6",
			"dev": true,
			"funding": [
				{
					"type": "opencollective",
					"url": "https://opencollective.com/postcss/"
				},
				{
					"type": "tidelift",
					"url": "https://tidelift.com/funding/github/npm/postcss"
				},
				{
					"type": "github",
					"url": "https://github.com/sponsors/ai"
				}
			],
			"license": "MIT",
			"dependencies": {
				"nanoid": "^3.3.11",
				"picocolors": "^1.1.1",
				"source-map-js": "^1.2.1"
			},
			"engines": {
				"node": "^10 || ^12 || >=14"
			}
		},
		"node_modules/postcss-selector-parser": {
			"version": "6.0.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"cssesc": "^3.0.0",
				"util-deprecate": "^1.0.2"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/postgres": {
			"version": "3.4.7",
			"license": "Unlicense",
			"engines": {
				"node": ">=12"
			},
			"funding": {
				"type": "individual",
				"url": "https://github.com/sponsors/porsager"
			}
		},
		"node_modules/prettier": {
			"version": "3.6.2",
			"dev": true,
			"license": "MIT",
			"bin": {
				"prettier": "bin/prettier.cjs"
			},
			"engines": {
				"node": ">=14"
			},
			"funding": {
				"url": "https://github.com/prettier/prettier?sponsor=1"
			}
		},
		"node_modules/prettier-plugin-svelte": {
			"version": "3.4.0",
			"dev": true,
			"license": "MIT",
			"peerDependencies": {
				"prettier": "^3.0.0",
				"svelte": "^3.2.0 || ^4.0.0-next.0 || ^5.0.0-next.0"
			}
		},
		"node_modules/prettier-plugin-tailwindcss": {
			"version": "0.6.14",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.21.3"
			},
			"peerDependencies": {
				"@ianvs/prettier-plugin-sort-imports": "*",
				"@prettier/plugin-hermes": "*",
				"@prettier/plugin-oxc": "*",
				"@prettier/plugin-pug": "*",
				"@shopify/prettier-plugin-liquid": "*",
				"@trivago/prettier-plugin-sort-imports": "*",
				"@zackad/prettier-plugin-twig": "*",
				"prettier": "^3.0",
				"prettier-plugin-astro": "*",
				"prettier-plugin-css-order": "*",
				"prettier-plugin-import-sort": "*",
				"prettier-plugin-jsdoc": "*",
				"prettier-plugin-marko": "*",
				"prettier-plugin-multiline-arrays": "*",
				"prettier-plugin-organize-attributes": "*",
				"prettier-plugin-organize-imports": "*",
				"prettier-plugin-sort-imports": "*",
				"prettier-plugin-style-order": "*",
				"prettier-plugin-svelte": "*"
			},
			"peerDependenciesMeta": {
				"@ianvs/prettier-plugin-sort-imports": {
					"optional": true
				},
				"@prettier/plugin-hermes": {
					"optional": true
				},
				"@prettier/plugin-oxc": {
					"optional": true
				},
				"@prettier/plugin-pug": {
					"optional": true
				},
				"@shopify/prettier-plugin-liquid": {
					"optional": true
				},
				"@trivago/prettier-plugin-sort-imports": {
					"optional": true
				},
				"@zackad/prettier-plugin-twig": {
					"optional": true
				},
				"prettier-plugin-astro": {
					"optional": true
				},
				"prettier-plugin-css-order": {
					"optional": true
				},
				"prettier-plugin-import-sort": {
					"optional": true
				},
				"prettier-plugin-jsdoc": {
					"optional": true
				},
				"prettier-plugin-marko": {
					"optional": true
				},
				"prettier-plugin-multiline-arrays": {
					"optional": true
				},
				"prettier-plugin-organize-attributes": {
					"optional": true
				},
				"prettier-plugin-organize-imports": {
					"optional": true
				},
				"prettier-plugin-sort-imports": {
					"optional": true
				},
				"prettier-plugin-style-order": {
					"optional": true
				},
				"prettier-plugin-svelte": {
					"optional": true
				}
			}
		},
		"node_modules/pretty-format": {
			"version": "27.5.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"ansi-regex": "^5.0.1",
				"ansi-styles": "^5.0.0",
				"react-is": "^17.0.1"
			},
			"engines": {
				"node": "^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"
			}
		},
		"node_modules/react-is": {
			"version": "17.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/readdirp": {
			"version": "4.1.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 14.18.0"
			},
			"funding": {
				"type": "individual",
				"url": "https://paulmillr.com/funding/"
			}
		},
		"node_modules/regexparam": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/resolve-pkg-maps": {
			"version": "1.0.0",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
			}
		},
		"node_modules/rollup": {
			"version": "4.52.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "1.0.8"
			},
			"bin": {
				"rollup": "dist/bin/rollup"
			},
			"engines": {
				"node": ">=18.0.0",
				"npm": ">=8.0.0"
			},
			"optionalDependencies": {
				"@rollup/rollup-android-arm-eabi": "4.52.5",
				"@rollup/rollup-android-arm64": "4.52.5",
				"@rollup/rollup-darwin-arm64": "4.52.5",
				"@rollup/rollup-darwin-x64": "4.52.5",
				"@rollup/rollup-freebsd-arm64": "4.52.5",
				"@rollup/rollup-freebsd-x64": "4.52.5",
				"@rollup/rollup-linux-arm-gnueabihf": "4.52.5",
				"@rollup/rollup-linux-arm-musleabihf": "4.52.5",
				"@rollup/rollup-linux-arm64-gnu": "4.52.5",
				"@rollup/rollup-linux-arm64-musl": "4.52.5",
				"@rollup/rollup-linux-loong64-gnu": "4.52.5",
				"@rollup/rollup-linux-ppc64-gnu": "4.52.5",
				"@rollup/rollup-linux-riscv64-gnu": "4.52.5",
				"@rollup/rollup-linux-riscv64-musl": "4.52.5",
				"@rollup/rollup-linux-s390x-gnu": "4.52.5",
				"@rollup/rollup-linux-x64-gnu": "4.52.5",
				"@rollup/rollup-linux-x64-musl": "4.52.5",
				"@rollup/rollup-openharmony-arm64": "4.52.5",
				"@rollup/rollup-win32-arm64-msvc": "4.52.5",
				"@rollup/rollup-win32-ia32-msvc": "4.52.5",
				"@rollup/rollup-win32-x64-gnu": "4.52.5",
				"@rollup/rollup-win32-x64-msvc": "4.52.5",
				"fsevents": "~2.3.2"
			}
		},
		"node_modules/rollup/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/sade": {
			"version": "1.8.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mri": "^1.1.0"
			},
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/semver": {
			"version": "7.7.3",
			"dev": true,
			"license": "ISC",
			"bin": {
				"semver": "bin/semver.js"
			},
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/set-cookie-parser": {
			"version": "2.7.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/sharp": {
			"version": "0.33.5",
			"dev": true,
			"hasInstallScript": true,
			"license": "Apache-2.0",
			"dependencies": {
				"color": "^4.2.3",
				"detect-libc": "^2.0.3",
				"semver": "^7.6.3"
			},
			"engines": {
				"node": "^18.17.0 || ^20.3.0 || >=21.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/libvips"
			},
			"optionalDependencies": {
				"@img/sharp-darwin-arm64": "0.33.5",
				"@img/sharp-darwin-x64": "0.33.5",
				"@img/sharp-libvips-darwin-arm64": "1.0.4",
				"@img/sharp-libvips-darwin-x64": "1.0.4",
				"@img/sharp-libvips-linux-arm": "1.0.5",
				"@img/sharp-libvips-linux-arm64": "1.0.4",
				"@img/sharp-libvips-linux-s390x": "1.0.4",
				"@img/sharp-libvips-linux-x64": "1.0.4",
				"@img/sharp-libvips-linuxmusl-arm64": "1.0.4",
				"@img/sharp-libvips-linuxmusl-x64": "1.0.4",
				"@img/sharp-linux-arm": "0.33.5",
				"@img/sharp-linux-arm64": "0.33.5",
				"@img/sharp-linux-s390x": "0.33.5",
				"@img/sharp-linux-x64": "0.33.5",
				"@img/sharp-linuxmusl-arm64": "0.33.5",
				"@img/sharp-linuxmusl-x64": "0.33.5",
				"@img/sharp-wasm32": "0.33.5",
				"@img/sharp-win32-ia32": "0.33.5",
				"@img/sharp-win32-x64": "0.33.5"
			}
		},
		"node_modules/siginfo": {
			"version": "2.0.0",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/simple-swizzle": {
			"version": "0.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"is-arrayish": "^0.3.1"
			}
		},
		"node_modules/sirv": {
			"version": "3.0.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@polka/url": "^1.0.0-next.24",
				"mrmime": "^2.0.0",
				"totalist": "^3.0.0"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/source-map": {
			"version": "0.6.1",
			"dev": true,
			"license": "BSD-3-Clause",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/source-map-js": {
			"version": "1.2.1",
			"dev": true,
			"license": "BSD-3-Clause",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/source-map-support": {
			"version": "0.5.21",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"buffer-from": "^1.0.0",
				"source-map": "^0.6.0"
			}
		},
		"node_modules/stackback": {
			"version": "0.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/std-env": {
			"version": "3.10.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/stoppable": {
			"version": "1.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=4",
				"npm": ">=6"
			}
		},
		"node_modules/strip-literal": {
			"version": "3.1.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"js-tokens": "^9.0.1"
			},
			"funding": {
				"url": "https://github.com/sponsors/antfu"
			}
		},
		"node_modules/strip-literal/node_modules/js-tokens": {
			"version": "9.0.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/supports-color": {
			"version": "10.2.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			},
			"funding": {
				"url": "https://github.com/chalk/supports-color?sponsor=1"
			}
		},
		"node_modules/svelte": {
			"version": "5.41.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/remapping": "^2.3.4",
				"@jridgewell/sourcemap-codec": "^1.5.0",
				"@sveltejs/acorn-typescript": "^1.0.5",
				"@types/estree": "^1.0.5",
				"acorn": "^8.12.1",
				"aria-query": "^5.3.1",
				"axobject-query": "^4.1.0",
				"clsx": "^2.1.1",
				"esm-env": "^1.2.1",
				"esrap": "^2.1.0",
				"is-reference": "^3.0.3",
				"locate-character": "^3.0.0",
				"magic-string": "^0.30.11",
				"zimmerframe": "^1.1.2"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/svelte-check": {
			"version": "4.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/trace-mapping": "^0.3.25",
				"chokidar": "^4.0.1",
				"fdir": "^6.2.0",
				"picocolors": "^1.0.0",
				"sade": "^1.7.4"
			},
			"bin": {
				"svelte-check": "bin/svelte-check"
			},
			"engines": {
				"node": ">= 18.0.0"
			},
			"peerDependencies": {
				"svelte": "^4.0.0 || ^5.0.0-next.0",
				"typescript": ">=5.0.0"
			}
		},
		"node_modules/tailwindcss": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tapable": {
			"version": "2.3.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/webpack"
			}
		},
		"node_modules/tinybench": {
			"version": "2.9.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tinyexec": {
			"version": "0.3.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tinyglobby": {
			"version": "0.2.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"fdir": "^6.5.0",
				"picomatch": "^4.0.3"
			},
			"engines": {
				"node": ">=12.0.0"
			},
			"funding": {
				"url": "https://github.com/sponsors/SuperchupuDev"
			}
		},
		"node_modules/tinypool": {
			"version": "1.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": "^18.0.0 || >=20.0.0"
			}
		},
		"node_modules/tinyrainbow": {
			"version": "2.0.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.0.0"
			}
		},
		"node_modules/tinyspy": {
			"version": "4.0.4",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.0.0"
			}
		},
		"node_modules/totalist": {
			"version": "3.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/typescript": {
			"version": "5.9.3",
			"dev": true,
			"license": "Apache-2.0",
			"bin": {
				"tsc": "bin/tsc",
				"tsserver": "bin/tsserver"
			},
			"engines": {
				"node": ">=14.17"
			}
		},
		"node_modules/ufo": {
			"version": "1.6.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/undici": {
			"version": "7.14.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=20.18.1"
			}
		},
		"node_modules/undici-types": {
			"version": "6.21.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/unenv": {
			"version": "2.0.0-rc.21",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"defu": "^6.1.4",
				"exsolve": "^1.0.7",
				"ohash": "^2.0.11",
				"pathe": "^2.0.3",
				"ufo": "^1.6.1"
			}
		},
		"node_modules/util-deprecate": {
			"version": "1.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/vite": {
			"version": "7.1.11",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"esbuild": "^0.25.0",
				"fdir": "^6.5.0",
				"picomatch": "^4.0.3",
				"postcss": "^8.5.6",
				"rollup": "^4.43.0",
				"tinyglobby": "^0.2.15"
			},
			"bin": {
				"vite": "bin/vite.js"
			},
			"engines": {
				"node": "^20.19.0 || >=22.12.0"
			},
			"funding": {
				"url": "https://github.com/vitejs/vite?sponsor=1"
			},
			"optionalDependencies": {
				"fsevents": "~2.3.3"
			},
			"peerDependencies": {
				"@types/node": "^20.19.0 || >=22.12.0",
				"jiti": ">=1.21.0",
				"less": "^4.0.0",
				"lightningcss": "^1.21.0",
				"sass": "^1.70.0",
				"sass-embedded": "^1.70.0",
				"stylus": ">=0.54.8",
				"sugarss": "^5.0.0",
				"terser": "^5.16.0",
				"tsx": "^4.8.1",
				"yaml": "^2.4.2"
			},
			"peerDependenciesMeta": {
				"@types/node": {
					"optional": true
				},
				"jiti": {
					"optional": true
				},
				"less": {
					"optional": true
				},
				"lightningcss": {
					"optional": true
				},
				"sass": {
					"optional": true
				},
				"sass-embedded": {
					"optional": true
				},
				"stylus": {
					"optional": true
				},
				"sugarss": {
					"optional": true
				},
				"terser": {
					"optional": true
				},
				"tsx": {
					"optional": true
				},
				"yaml": {
					"optional": true
				}
			}
		},
		"node_modules/vite-node": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"cac": "^6.7.14",
				"debug": "^4.4.1",
				"es-module-lexer": "^1.7.0",
				"pathe": "^2.0.3",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
			},
			"bin": {
				"vite-node": "vite-node.mjs"
			},
			"engines": {
				"node": "^18.0.0 || ^20.0.0 || >=22.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/vite/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/vitefu": {
			"version": "1.1.1",
			"dev": true,
			"license": "MIT",
			"workspaces": [
				"tests/deps/*",
				"tests/projects/*",
				"tests/projects/workspace/packages/*"
			],
			"peerDependencies": {
				"vite": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0-beta.0"
			},
			"peerDependenciesMeta": {
				"vite": {
					"optional": true
				}
			}
		},
		"node_modules/vitest": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/chai": "^5.2.2",
				"@vitest/expect": "3.2.4",
				"@vitest/mocker": "3.2.4",
				"@vitest/pretty-format": "^3.2.4",
				"@vitest/runner": "3.2.4",
				"@vitest/snapshot": "3.2.4",
				"@vitest/spy": "3.2.4",
				"@vitest/utils": "3.2.4",
				"chai": "^5.2.0",
				"debug": "^4.4.1",
				"expect-type": "^1.2.1",
				"magic-string": "^0.30.17",
				"pathe": "^2.0.3",
				"picomatch": "^4.0.2",
				"std-env": "^3.9.0",
				"tinybench": "^2.9.0",
				"tinyexec": "^0.3.2",
				"tinyglobby": "^0.2.14",
				"tinypool": "^1.1.1",
				"tinyrainbow": "^2.0.0",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0",
				"vite-node": "3.2.4",
				"why-is-node-running": "^2.3.0"
			},
			"bin": {
				"vitest": "vitest.mjs"
			},
			"engines": {
				"node": "^18.0.0 || ^20.0.0 || >=22.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"@edge-runtime/vm": "*",
				"@types/debug": "^4.1.12",
				"@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
				"@vitest/browser": "3.2.4",
				"@vitest/ui": "3.2.4",
				"happy-dom": "*",
				"jsdom": "*"
			},
			"peerDependenciesMeta": {
				"@edge-runtime/vm": {
					"optional": true
				},
				"@types/debug": {
					"optional": true
				},
				"@types/node": {
					"optional": true
				},
				"@vitest/browser": {
					"optional": true
				},
				"@vitest/ui": {
					"optional": true
				},
				"happy-dom": {
					"optional": true
				},
				"jsdom": {
					"optional": true
				}
			}
		},
		"node_modules/vitest-browser-svelte": {
			"version": "1.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": "^18.0.0 || >=20.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"@vitest/browser": "^2.1.0 || ^3.0.0 || ^4.0.0-0",
				"svelte": "^3 || ^4 || ^5 || ^5.0.0-next.0",
				"vitest": "^2.1.0 || ^3.0.0 || ^4.0.0-0"
			}
		},
		"node_modules/why-is-node-running": {
			"version": "2.3.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"siginfo": "^2.0.0",
				"stackback": "0.0.2"
			},
			"bin": {
				"why-is-node-running": "cli.js"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/workerd": {
			"version": "1.20251011.0",
			"dev": true,
			"hasInstallScript": true,
			"license": "Apache-2.0",
			"bin": {
				"workerd": "bin/workerd"
			},
			"engines": {
				"node": ">=16"
			},
			"optionalDependencies": {
				"@cloudflare/workerd-darwin-64": "1.20251011.0",
				"@cloudflare/workerd-darwin-arm64": "1.20251011.0",
				"@cloudflare/workerd-linux-64": "1.20251011.0",
				"@cloudflare/workerd-linux-arm64": "1.20251011.0",
				"@cloudflare/workerd-windows-64": "1.20251011.0"
			}
		},
		"node_modules/worktop": {
			"version": "0.8.0-next.18",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mrmime": "^2.0.0",
				"regexparam": "^3.0.0"
			},
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/wrangler": {
			"version": "4.44.0",
			"resolved": "https://registry.npmjs.org/wrangler/-/wrangler-4.44.0.tgz",
			"integrity": "sha512-BLOUigckcWZ0r4rm7b5PuaTpb9KP9as0XeCRSJ8kqcNgXcKoUD3Ij8FlPvN25KybLnFnetaO0ZdfRYUPWle4qw==",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"dependencies": {
				"@cloudflare/kv-asset-handler": "0.4.0",
				"@cloudflare/unenv-preset": "2.7.8",
				"blake3-wasm": "2.1.5",
				"esbuild": "0.25.4",
				"miniflare": "4.20251011.0",
				"path-to-regexp": "6.3.0",
				"unenv": "2.0.0-rc.21",
				"workerd": "1.20251011.0"
			},
			"bin": {
				"wrangler": "bin/wrangler.js",
				"wrangler2": "bin/wrangler.js"
			},
			"engines": {
				"node": ">=18.0.0"
			},
			"optionalDependencies": {
				"fsevents": "~2.3.2"
			},
			"peerDependencies": {
				"@cloudflare/workers-types": "^4.20251011.0"
			},
			"peerDependenciesMeta": {
				"@cloudflare/workers-types": {
					"optional": true
				}
			}
		},
		"node_modules/wrangler/node_modules/esbuild": {
			"version": "0.25.4",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"@esbuild/aix-ppc64": "0.25.4",
				"@esbuild/android-arm": "0.25.4",
				"@esbuild/android-arm64": "0.25.4",
				"@esbuild/android-x64": "0.25.4",
				"@esbuild/darwin-arm64": "0.25.4",
				"@esbuild/darwin-x64": "0.25.4",
				"@esbuild/freebsd-arm64": "0.25.4",
				"@esbuild/freebsd-x64": "0.25.4",
				"@esbuild/linux-arm": "0.25.4",
				"@esbuild/linux-arm64": "0.25.4",
				"@esbuild/linux-ia32": "0.25.4",
				"@esbuild/linux-loong64": "0.25.4",
				"@esbuild/linux-mips64el": "0.25.4",
				"@esbuild/linux-ppc64": "0.25.4",
				"@esbuild/linux-riscv64": "0.25.4",
				"@esbuild/linux-s390x": "0.25.4",
				"@esbuild/linux-x64": "0.25.4",
				"@esbuild/netbsd-arm64": "0.25.4",
				"@esbuild/netbsd-x64": "0.25.4",
				"@esbuild/openbsd-arm64": "0.25.4",
				"@esbuild/openbsd-x64": "0.25.4",
				"@esbuild/sunos-x64": "0.25.4",
				"@esbuild/win32-arm64": "0.25.4",
				"@esbuild/win32-ia32": "0.25.4",
				"@esbuild/win32-x64": "0.25.4"
			}
		},
		"node_modules/wrangler/node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
			"version": "0.25.4",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/wrangler/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/ws": {
			"version": "8.18.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10.0.0"
			},
			"peerDependencies": {
				"bufferutil": "^4.0.1",
				"utf-8-validate": ">=5.0.2"
			},
			"peerDependenciesMeta": {
				"bufferutil": {
					"optional": true
				},
				"utf-8-validate": {
					"optional": true
				}
			}
		},
		"node_modules/youch": {
			"version": "4.1.0-beta.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/colors": "^4.1.5",
				"@poppinss/dumper": "^0.6.4",
				"@speed-highlight/core": "^1.2.7",
				"cookie": "^1.0.2",
				"youch-core": "^0.3.3"
			}
		},
		"node_modules/youch-core": {
			"version": "0.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/exception": "^1.2.2",
				"error-stack-parser-es": "^1.0.5"
			}
		},
		"node_modules/youch/node_modules/cookie": {
			"version": "1.0.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/zimmerframe": {
			"version": "1.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/zod": {
			"version": "3.22.3",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/sponsors/colinhacks"
			}
		}
	}
}
</file>

<file path=".history/package-lock_20251023113848.json">
{
	"name": "rushesbe",
	"version": "0.0.1",
	"lockfileVersion": 3,
	"requires": true,
	"packages": {
		"": {
			"name": "rushesbe",
			"version": "0.0.1",
			"dependencies": {
				"postgres": "^3.4.7"
			},
			"devDependencies": {
				"@sveltejs/adapter-cloudflare": "^7.2.4",
				"@sveltejs/kit": "^2.43.2",
				"@sveltejs/vite-plugin-svelte": "^6.2.0",
				"@tailwindcss/forms": "^0.5.10",
				"@tailwindcss/typography": "^0.5.18",
				"@tailwindcss/vite": "^4.1.13",
				"@types/node": "^22",
				"@vitest/browser": "^3.2.4",
				"drizzle-kit": "^0.31.4",
				"drizzle-orm": "^0.44.5",
				"playwright": "^1.55.1",
				"prettier": "^3.6.2",
				"prettier-plugin-svelte": "^3.4.0",
				"prettier-plugin-tailwindcss": "^0.6.14",
				"svelte": "^5.39.5",
				"svelte-check": "^4.3.2",
				"tailwindcss": "^4.1.13",
				"typescript": "^5.9.2",
				"vite": "^7.1.7",
				"vitest": "^3.2.4",
				"vitest-browser-svelte": "^1.1.0",
				"wrangler": "^4.44.0"
			}
		},
		"node_modules/@babel/code-frame": {
			"version": "7.27.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@babel/helper-validator-identifier": "^7.27.1",
				"js-tokens": "^4.0.0",
				"picocolors": "^1.1.1"
			},
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/helper-validator-identifier": {
			"version": "7.27.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/runtime": {
			"version": "7.28.4",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@cloudflare/kv-asset-handler": {
			"version": "0.4.0",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"dependencies": {
				"mime": "^3.0.0"
			},
			"engines": {
				"node": ">=18.0.0"
			}
		},
		"node_modules/@cloudflare/unenv-preset": {
			"version": "2.7.8",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"peerDependencies": {
				"unenv": "2.0.0-rc.21",
				"workerd": "^1.20250927.0"
			},
			"peerDependenciesMeta": {
				"workerd": {
					"optional": true
				}
			}
		},
		"node_modules/@cloudflare/workerd-darwin-arm64": {
			"version": "1.20251011.0",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=16"
			}
		},
		"node_modules/@cloudflare/workers-types": {
			"version": "4.20251014.0",
			"dev": true,
			"license": "MIT OR Apache-2.0"
		},
		"node_modules/@cspotcode/source-map-support": {
			"version": "0.8.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/trace-mapping": "0.3.9"
			},
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping": {
			"version": "0.3.9",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/resolve-uri": "^3.0.3",
				"@jridgewell/sourcemap-codec": "^1.4.10"
			}
		},
		"node_modules/@drizzle-team/brocli": {
			"version": "0.10.2",
			"dev": true,
			"license": "Apache-2.0"
		},
		"node_modules/@esbuild-kit/core-utils": {
			"version": "3.3.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"esbuild": "~0.18.20",
				"source-map-support": "^0.5.21"
			}
		},
		"node_modules/@esbuild-kit/core-utils/node_modules/esbuild": {
			"version": "0.18.20",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=12"
			},
			"optionalDependencies": {
				"@esbuild/android-arm": "0.18.20",
				"@esbuild/android-arm64": "0.18.20",
				"@esbuild/android-x64": "0.18.20",
				"@esbuild/darwin-arm64": "0.18.20",
				"@esbuild/darwin-x64": "0.18.20",
				"@esbuild/freebsd-arm64": "0.18.20",
				"@esbuild/freebsd-x64": "0.18.20",
				"@esbuild/linux-arm": "0.18.20",
				"@esbuild/linux-arm64": "0.18.20",
				"@esbuild/linux-ia32": "0.18.20",
				"@esbuild/linux-loong64": "0.18.20",
				"@esbuild/linux-mips64el": "0.18.20",
				"@esbuild/linux-ppc64": "0.18.20",
				"@esbuild/linux-riscv64": "0.18.20",
				"@esbuild/linux-s390x": "0.18.20",
				"@esbuild/linux-x64": "0.18.20",
				"@esbuild/netbsd-x64": "0.18.20",
				"@esbuild/openbsd-x64": "0.18.20",
				"@esbuild/sunos-x64": "0.18.20",
				"@esbuild/win32-arm64": "0.18.20",
				"@esbuild/win32-ia32": "0.18.20",
				"@esbuild/win32-x64": "0.18.20"
			}
		},
		"node_modules/@esbuild-kit/core-utils/node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
			"version": "0.18.20",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/@esbuild-kit/esm-loader": {
			"version": "2.6.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@esbuild-kit/core-utils": "^3.3.2",
				"get-tsconfig": "^4.7.0"
			}
		},
		"node_modules/@esbuild/darwin-arm64": {
			"version": "0.25.11",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/@img/sharp-darwin-arm64": {
			"version": "0.33.5",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^18.17.0 || ^20.3.0 || >=21.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/libvips"
			},
			"optionalDependencies": {
				"@img/sharp-libvips-darwin-arm64": "1.0.4"
			}
		},
		"node_modules/@img/sharp-libvips-darwin-arm64": {
			"version": "1.0.4",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "LGPL-3.0-or-later",
			"optional": true,
			"os": [
				"darwin"
			],
			"funding": {
				"url": "https://opencollective.com/libvips"
			}
		},
		"node_modules/@jridgewell/gen-mapping": {
			"version": "0.3.13",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.5.0",
				"@jridgewell/trace-mapping": "^0.3.24"
			}
		},
		"node_modules/@jridgewell/remapping": {
			"version": "2.3.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/gen-mapping": "^0.3.5",
				"@jridgewell/trace-mapping": "^0.3.24"
			}
		},
		"node_modules/@jridgewell/resolve-uri": {
			"version": "3.1.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.0.0"
			}
		},
		"node_modules/@jridgewell/sourcemap-codec": {
			"version": "1.5.5",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@jridgewell/trace-mapping": {
			"version": "0.3.31",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/resolve-uri": "^3.1.0",
				"@jridgewell/sourcemap-codec": "^1.4.14"
			}
		},
		"node_modules/@polka/url": {
			"version": "1.0.0-next.29",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@poppinss/colors": {
			"version": "4.1.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"kleur": "^4.1.5"
			}
		},
		"node_modules/@poppinss/dumper": {
			"version": "0.6.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/colors": "^4.1.5",
				"@sindresorhus/is": "^7.0.2",
				"supports-color": "^10.0.0"
			}
		},
		"node_modules/@poppinss/exception": {
			"version": "1.2.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@rollup/rollup-darwin-arm64": {
			"version": "4.52.5",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			]
		},
		"node_modules/@sindresorhus/is": {
			"version": "7.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			},
			"funding": {
				"url": "https://github.com/sindresorhus/is?sponsor=1"
			}
		},
		"node_modules/@speed-highlight/core": {
			"version": "1.2.7",
			"dev": true,
			"license": "CC0-1.0"
		},
		"node_modules/@standard-schema/spec": {
			"version": "1.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@sveltejs/acorn-typescript": {
			"version": "1.0.6",
			"dev": true,
			"license": "MIT",
			"peerDependencies": {
				"acorn": "^8.9.0"
			}
		},
		"node_modules/@sveltejs/adapter-cloudflare": {
			"version": "7.2.4",
			"resolved": "https://registry.npmjs.org/@sveltejs/adapter-cloudflare/-/adapter-cloudflare-7.2.4.tgz",
			"integrity": "sha512-uD8VlOuGXGuZWL+zbBYSjtmC4WDtlonUodfqAZ/COd5uIy2Z0QptIicB/nkTrGNI9sbmzgf7z0N09CHyWYlUvQ==",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@cloudflare/workers-types": "^4.20250507.0",
				"worktop": "0.8.0-next.18"
			},
			"peerDependencies": {
				"@sveltejs/kit": "^2.0.0",
				"wrangler": "^4.0.0"
			}
		},
		"node_modules/@sveltejs/kit": {
			"version": "2.47.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@standard-schema/spec": "^1.0.0",
				"@sveltejs/acorn-typescript": "^1.0.5",
				"@types/cookie": "^0.6.0",
				"acorn": "^8.14.1",
				"cookie": "^0.6.0",
				"devalue": "^5.3.2",
				"esm-env": "^1.2.2",
				"kleur": "^4.1.5",
				"magic-string": "^0.30.5",
				"mrmime": "^2.0.0",
				"sade": "^1.8.1",
				"set-cookie-parser": "^2.6.0",
				"sirv": "^3.0.0"
			},
			"bin": {
				"svelte-kit": "svelte-kit.js"
			},
			"engines": {
				"node": ">=18.13"
			},
			"peerDependencies": {
				"@opentelemetry/api": "^1.0.0",
				"@sveltejs/vite-plugin-svelte": "^3.0.0 || ^4.0.0-next.1 || ^5.0.0 || ^6.0.0-next.0",
				"svelte": "^4.0.0 || ^5.0.0-next.0",
				"vite": "^5.0.3 || ^6.0.0 || ^7.0.0-beta.0"
			},
			"peerDependenciesMeta": {
				"@opentelemetry/api": {
					"optional": true
				}
			}
		},
		"node_modules/@sveltejs/vite-plugin-svelte": {
			"version": "6.2.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@sveltejs/vite-plugin-svelte-inspector": "^5.0.0",
				"debug": "^4.4.1",
				"deepmerge": "^4.3.1",
				"magic-string": "^0.30.17",
				"vitefu": "^1.1.1"
			},
			"engines": {
				"node": "^20.19 || ^22.12 || >=24"
			},
			"peerDependencies": {
				"svelte": "^5.0.0",
				"vite": "^6.3.0 || ^7.0.0"
			}
		},
		"node_modules/@sveltejs/vite-plugin-svelte-inspector": {
			"version": "5.0.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"debug": "^4.4.1"
			},
			"engines": {
				"node": "^20.19 || ^22.12 || >=24"
			},
			"peerDependencies": {
				"@sveltejs/vite-plugin-svelte": "^6.0.0-next.0",
				"svelte": "^5.0.0",
				"vite": "^6.3.0 || ^7.0.0"
			}
		},
		"node_modules/@tailwindcss/forms": {
			"version": "0.5.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mini-svg-data-uri": "^1.2.3"
			},
			"peerDependencies": {
				"tailwindcss": ">=3.0.0 || >= 3.0.0-alpha.1 || >= 4.0.0-alpha.20 || >= 4.0.0-beta.1"
			}
		},
		"node_modules/@tailwindcss/node": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/remapping": "^2.3.4",
				"enhanced-resolve": "^5.18.3",
				"jiti": "^2.6.0",
				"lightningcss": "1.30.2",
				"magic-string": "^0.30.19",
				"source-map-js": "^1.2.1",
				"tailwindcss": "4.1.15"
			}
		},
		"node_modules/@tailwindcss/oxide": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 10"
			},
			"optionalDependencies": {
				"@tailwindcss/oxide-android-arm64": "4.1.15",
				"@tailwindcss/oxide-darwin-arm64": "4.1.15",
				"@tailwindcss/oxide-darwin-x64": "4.1.15",
				"@tailwindcss/oxide-freebsd-x64": "4.1.15",
				"@tailwindcss/oxide-linux-arm-gnueabihf": "4.1.15",
				"@tailwindcss/oxide-linux-arm64-gnu": "4.1.15",
				"@tailwindcss/oxide-linux-arm64-musl": "4.1.15",
				"@tailwindcss/oxide-linux-x64-gnu": "4.1.15",
				"@tailwindcss/oxide-linux-x64-musl": "4.1.15",
				"@tailwindcss/oxide-wasm32-wasi": "4.1.15",
				"@tailwindcss/oxide-win32-arm64-msvc": "4.1.15",
				"@tailwindcss/oxide-win32-x64-msvc": "4.1.15"
			}
		},
		"node_modules/@tailwindcss/oxide-darwin-arm64": {
			"version": "4.1.15",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">= 10"
			}
		},
		"node_modules/@tailwindcss/typography": {
			"version": "0.5.19",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"postcss-selector-parser": "6.0.10"
			},
			"peerDependencies": {
				"tailwindcss": ">=3.0.0 || insiders || >=4.0.0-alpha.20 || >=4.0.0-beta.1"
			}
		},
		"node_modules/@tailwindcss/vite": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@tailwindcss/node": "4.1.15",
				"@tailwindcss/oxide": "4.1.15",
				"tailwindcss": "4.1.15"
			},
			"peerDependencies": {
				"vite": "^5.2.0 || ^6 || ^7"
			}
		},
		"node_modules/@testing-library/dom": {
			"version": "10.4.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@babel/code-frame": "^7.10.4",
				"@babel/runtime": "^7.12.5",
				"@types/aria-query": "^5.0.1",
				"aria-query": "5.3.0",
				"dom-accessibility-api": "^0.5.9",
				"lz-string": "^1.5.0",
				"picocolors": "1.1.1",
				"pretty-format": "^27.0.2"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/@testing-library/dom/node_modules/aria-query": {
			"version": "5.3.0",
			"dev": true,
			"license": "Apache-2.0",
			"dependencies": {
				"dequal": "^2.0.3"
			}
		},
		"node_modules/@testing-library/user-event": {
			"version": "14.6.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12",
				"npm": ">=6"
			},
			"peerDependencies": {
				"@testing-library/dom": ">=7.21.4"
			}
		},
		"node_modules/@types/aria-query": {
			"version": "5.0.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/chai": {
			"version": "5.2.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/deep-eql": "*",
				"assertion-error": "^2.0.1"
			}
		},
		"node_modules/@types/cookie": {
			"version": "0.6.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/deep-eql": {
			"version": "4.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/estree": {
			"version": "1.0.8",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/node": {
			"version": "22.18.12",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"undici-types": "~6.21.0"
			}
		},
		"node_modules/@vitest/browser": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@testing-library/dom": "^10.4.0",
				"@testing-library/user-event": "^14.6.1",
				"@vitest/mocker": "3.2.4",
				"@vitest/utils": "3.2.4",
				"magic-string": "^0.30.17",
				"sirv": "^3.0.1",
				"tinyrainbow": "^2.0.0",
				"ws": "^8.18.2"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"playwright": "*",
				"vitest": "3.2.4",
				"webdriverio": "^7.0.0 || ^8.0.0 || ^9.0.0"
			},
			"peerDependenciesMeta": {
				"playwright": {
					"optional": true
				},
				"safaridriver": {
					"optional": true
				},
				"webdriverio": {
					"optional": true
				}
			}
		},
		"node_modules/@vitest/expect": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/chai": "^5.2.2",
				"@vitest/spy": "3.2.4",
				"@vitest/utils": "3.2.4",
				"chai": "^5.2.0",
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/mocker": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/spy": "3.2.4",
				"estree-walker": "^3.0.3",
				"magic-string": "^0.30.17"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"msw": "^2.4.9",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
			},
			"peerDependenciesMeta": {
				"msw": {
					"optional": true
				},
				"vite": {
					"optional": true
				}
			}
		},
		"node_modules/@vitest/pretty-format": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/runner": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/utils": "3.2.4",
				"pathe": "^2.0.3",
				"strip-literal": "^3.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/snapshot": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/pretty-format": "3.2.4",
				"magic-string": "^0.30.17",
				"pathe": "^2.0.3"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/spy": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"tinyspy": "^4.0.3"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/utils": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/pretty-format": "3.2.4",
				"loupe": "^3.1.4",
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/acorn": {
			"version": "8.15.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"acorn": "bin/acorn"
			},
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/acorn-walk": {
			"version": "8.3.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/ansi-regex": {
			"version": "5.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/ansi-styles": {
			"version": "5.2.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/chalk/ansi-styles?sponsor=1"
			}
		},
		"node_modules/aria-query": {
			"version": "5.3.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">= 0.4"
			}
		},
		"node_modules/assertion-error": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/axobject-query": {
			"version": "4.1.0",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">= 0.4"
			}
		},
		"node_modules/blake3-wasm": {
			"version": "2.1.5",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/buffer-from": {
			"version": "1.1.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/cac": {
			"version": "6.7.14",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/chai": {
			"version": "5.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"assertion-error": "^2.0.1",
				"check-error": "^2.1.1",
				"deep-eql": "^5.0.1",
				"loupe": "^3.1.0",
				"pathval": "^2.0.0"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/check-error": {
			"version": "2.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 16"
			}
		},
		"node_modules/chokidar": {
			"version": "4.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"readdirp": "^4.0.1"
			},
			"engines": {
				"node": ">= 14.16.0"
			},
			"funding": {
				"url": "https://paulmillr.com/funding/"
			}
		},
		"node_modules/clsx": {
			"version": "2.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/color": {
			"version": "4.2.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-convert": "^2.0.1",
				"color-string": "^1.9.0"
			},
			"engines": {
				"node": ">=12.5.0"
			}
		},
		"node_modules/color-convert": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-name": "~1.1.4"
			},
			"engines": {
				"node": ">=7.0.0"
			}
		},
		"node_modules/color-name": {
			"version": "1.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/color-string": {
			"version": "1.9.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-name": "^1.0.0",
				"simple-swizzle": "^0.2.2"
			}
		},
		"node_modules/cookie": {
			"version": "0.6.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 0.6"
			}
		},
		"node_modules/cssesc": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"cssesc": "bin/cssesc"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/debug": {
			"version": "4.4.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"ms": "^2.1.3"
			},
			"engines": {
				"node": ">=6.0"
			},
			"peerDependenciesMeta": {
				"supports-color": {
					"optional": true
				}
			}
		},
		"node_modules/deep-eql": {
			"version": "5.0.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/deepmerge": {
			"version": "4.3.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/defu": {
			"version": "6.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/dequal": {
			"version": "2.0.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/detect-libc": {
			"version": "2.1.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/devalue": {
			"version": "5.4.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/dom-accessibility-api": {
			"version": "0.5.16",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/drizzle-kit": {
			"version": "0.31.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@drizzle-team/brocli": "^0.10.2",
				"@esbuild-kit/esm-loader": "^2.5.5",
				"esbuild": "^0.25.4",
				"esbuild-register": "^3.5.0"
			},
			"bin": {
				"drizzle-kit": "bin.cjs"
			}
		},
		"node_modules/drizzle-orm": {
			"version": "0.44.6",
			"dev": true,
			"license": "Apache-2.0",
			"peerDependencies": {
				"@aws-sdk/client-rds-data": ">=3",
				"@cloudflare/workers-types": ">=4",
				"@electric-sql/pglite": ">=0.2.0",
				"@libsql/client": ">=0.10.0",
				"@libsql/client-wasm": ">=0.10.0",
				"@op-engineering/op-sqlite": ">=2",
				"@opentelemetry/api": "^1.4.1",
				"@planetscale/database": ">=1.13",
				"@prisma/client": "*",
				"@tidbcloud/serverless": "*",
				"@types/better-sqlite3": "*",
				"@types/pg": "*",
				"@types/sql.js": "*",
				"@upstash/redis": ">=1.34.7",
				"@vercel/postgres": ">=0.8.0",
				"@xata.io/client": "*",
				"better-sqlite3": ">=7",
				"bun-types": "*",
				"expo-sqlite": ">=14.0.0",
				"gel": ">=2",
				"knex": "*",
				"kysely": "*",
				"mysql2": ">=2",
				"pg": ">=8",
				"postgres": ">=3",
				"sql.js": ">=1",
				"sqlite3": ">=5"
			},
			"peerDependenciesMeta": {
				"@aws-sdk/client-rds-data": {
					"optional": true
				},
				"@cloudflare/workers-types": {
					"optional": true
				},
				"@electric-sql/pglite": {
					"optional": true
				},
				"@libsql/client": {
					"optional": true
				},
				"@libsql/client-wasm": {
					"optional": true
				},
				"@neondatabase/serverless": {
					"optional": true
				},
				"@op-engineering/op-sqlite": {
					"optional": true
				},
				"@opentelemetry/api": {
					"optional": true
				},
				"@planetscale/database": {
					"optional": true
				},
				"@prisma/client": {
					"optional": true
				},
				"@tidbcloud/serverless": {
					"optional": true
				},
				"@types/better-sqlite3": {
					"optional": true
				},
				"@types/pg": {
					"optional": true
				},
				"@types/sql.js": {
					"optional": true
				},
				"@upstash/redis": {
					"optional": true
				},
				"@vercel/postgres": {
					"optional": true
				},
				"@xata.io/client": {
					"optional": true
				},
				"better-sqlite3": {
					"optional": true
				},
				"bun-types": {
					"optional": true
				},
				"expo-sqlite": {
					"optional": true
				},
				"gel": {
					"optional": true
				},
				"knex": {
					"optional": true
				},
				"kysely": {
					"optional": true
				},
				"mysql2": {
					"optional": true
				},
				"pg": {
					"optional": true
				},
				"postgres": {
					"optional": true
				},
				"prisma": {
					"optional": true
				},
				"sql.js": {
					"optional": true
				},
				"sqlite3": {
					"optional": true
				}
			}
		},
		"node_modules/enhanced-resolve": {
			"version": "5.18.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"graceful-fs": "^4.2.4",
				"tapable": "^2.2.0"
			},
			"engines": {
				"node": ">=10.13.0"
			}
		},
		"node_modules/error-stack-parser-es": {
			"version": "1.0.5",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/sponsors/antfu"
			}
		},
		"node_modules/es-module-lexer": {
			"version": "1.7.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/esbuild": {
			"version": "0.25.11",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"@esbuild/aix-ppc64": "0.25.11",
				"@esbuild/android-arm": "0.25.11",
				"@esbuild/android-arm64": "0.25.11",
				"@esbuild/android-x64": "0.25.11",
				"@esbuild/darwin-arm64": "0.25.11",
				"@esbuild/darwin-x64": "0.25.11",
				"@esbuild/freebsd-arm64": "0.25.11",
				"@esbuild/freebsd-x64": "0.25.11",
				"@esbuild/linux-arm": "0.25.11",
				"@esbuild/linux-arm64": "0.25.11",
				"@esbuild/linux-ia32": "0.25.11",
				"@esbuild/linux-loong64": "0.25.11",
				"@esbuild/linux-mips64el": "0.25.11",
				"@esbuild/linux-ppc64": "0.25.11",
				"@esbuild/linux-riscv64": "0.25.11",
				"@esbuild/linux-s390x": "0.25.11",
				"@esbuild/linux-x64": "0.25.11",
				"@esbuild/netbsd-arm64": "0.25.11",
				"@esbuild/netbsd-x64": "0.25.11",
				"@esbuild/openbsd-arm64": "0.25.11",
				"@esbuild/openbsd-x64": "0.25.11",
				"@esbuild/openharmony-arm64": "0.25.11",
				"@esbuild/sunos-x64": "0.25.11",
				"@esbuild/win32-arm64": "0.25.11",
				"@esbuild/win32-ia32": "0.25.11",
				"@esbuild/win32-x64": "0.25.11"
			}
		},
		"node_modules/esbuild-register": {
			"version": "3.6.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"debug": "^4.3.4"
			},
			"peerDependencies": {
				"esbuild": ">=0.12 <1"
			}
		},
		"node_modules/esm-env": {
			"version": "1.2.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/esrap": {
			"version": "2.1.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.4.15"
			}
		},
		"node_modules/estree-walker": {
			"version": "3.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "^1.0.0"
			}
		},
		"node_modules/exit-hook": {
			"version": "2.2.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/expect-type": {
			"version": "1.2.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">=12.0.0"
			}
		},
		"node_modules/exsolve": {
			"version": "1.0.7",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/fdir": {
			"version": "6.5.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12.0.0"
			},
			"peerDependencies": {
				"picomatch": "^3 || ^4"
			},
			"peerDependenciesMeta": {
				"picomatch": {
					"optional": true
				}
			}
		},
		"node_modules/fsevents": {
			"version": "2.3.2",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/get-tsconfig": {
			"version": "4.13.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"resolve-pkg-maps": "^1.0.0"
			},
			"funding": {
				"url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
			}
		},
		"node_modules/glob-to-regexp": {
			"version": "0.4.1",
			"dev": true,
			"license": "BSD-2-Clause"
		},
		"node_modules/graceful-fs": {
			"version": "4.2.11",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/is-arrayish": {
			"version": "0.3.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/is-reference": {
			"version": "3.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "^1.0.6"
			}
		},
		"node_modules/jiti": {
			"version": "2.6.1",
			"dev": true,
			"license": "MIT",
			"bin": {
				"jiti": "lib/jiti-cli.mjs"
			}
		},
		"node_modules/js-tokens": {
			"version": "4.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/kleur": {
			"version": "4.1.5",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/lightningcss": {
			"version": "1.30.2",
			"dev": true,
			"license": "MPL-2.0",
			"dependencies": {
				"detect-libc": "^2.0.3"
			},
			"engines": {
				"node": ">= 12.0.0"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/parcel"
			},
			"optionalDependencies": {
				"lightningcss-android-arm64": "1.30.2",
				"lightningcss-darwin-arm64": "1.30.2",
				"lightningcss-darwin-x64": "1.30.2",
				"lightningcss-freebsd-x64": "1.30.2",
				"lightningcss-linux-arm-gnueabihf": "1.30.2",
				"lightningcss-linux-arm64-gnu": "1.30.2",
				"lightningcss-linux-arm64-musl": "1.30.2",
				"lightningcss-linux-x64-gnu": "1.30.2",
				"lightningcss-linux-x64-musl": "1.30.2",
				"lightningcss-win32-arm64-msvc": "1.30.2",
				"lightningcss-win32-x64-msvc": "1.30.2"
			}
		},
		"node_modules/lightningcss-darwin-arm64": {
			"version": "1.30.2",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MPL-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">= 12.0.0"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/parcel"
			}
		},
		"node_modules/locate-character": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/loupe": {
			"version": "3.2.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/lz-string": {
			"version": "1.5.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"lz-string": "bin/bin.js"
			}
		},
		"node_modules/magic-string": {
			"version": "0.30.19",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.5.5"
			}
		},
		"node_modules/mime": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"mime": "cli.js"
			},
			"engines": {
				"node": ">=10.0.0"
			}
		},
		"node_modules/mini-svg-data-uri": {
			"version": "1.4.4",
			"dev": true,
			"license": "MIT",
			"bin": {
				"mini-svg-data-uri": "cli.js"
			}
		},
		"node_modules/miniflare": {
			"version": "4.20251011.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@cspotcode/source-map-support": "0.8.1",
				"acorn": "8.14.0",
				"acorn-walk": "8.3.2",
				"exit-hook": "2.2.1",
				"glob-to-regexp": "0.4.1",
				"sharp": "^0.33.5",
				"stoppable": "1.1.0",
				"undici": "7.14.0",
				"workerd": "1.20251011.0",
				"ws": "8.18.0",
				"youch": "4.1.0-beta.10",
				"zod": "3.22.3"
			},
			"bin": {
				"miniflare": "bootstrap.js"
			},
			"engines": {
				"node": ">=18.0.0"
			}
		},
		"node_modules/miniflare/node_modules/acorn": {
			"version": "8.14.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"acorn": "bin/acorn"
			},
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/miniflare/node_modules/ws": {
			"version": "8.18.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10.0.0"
			},
			"peerDependencies": {
				"bufferutil": "^4.0.1",
				"utf-8-validate": ">=5.0.2"
			},
			"peerDependenciesMeta": {
				"bufferutil": {
					"optional": true
				},
				"utf-8-validate": {
					"optional": true
				}
			}
		},
		"node_modules/mri": {
			"version": "1.2.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/mrmime": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/ms": {
			"version": "2.1.3",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/nanoid": {
			"version": "3.3.11",
			"dev": true,
			"funding": [
				{
					"type": "github",
					"url": "https://github.com/sponsors/ai"
				}
			],
			"license": "MIT",
			"bin": {
				"nanoid": "bin/nanoid.cjs"
			},
			"engines": {
				"node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
			}
		},
		"node_modules/ohash": {
			"version": "2.0.11",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/path-to-regexp": {
			"version": "6.3.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/pathe": {
			"version": "2.0.3",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/pathval": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 14.16"
			}
		},
		"node_modules/picocolors": {
			"version": "1.1.1",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/picomatch": {
			"version": "4.0.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12"
			},
			"funding": {
				"url": "https://github.com/sponsors/jonschlinkert"
			}
		},
		"node_modules/playwright": {
			"version": "1.56.1",
			"dev": true,
			"license": "Apache-2.0",
			"dependencies": {
				"playwright-core": "1.56.1"
			},
			"bin": {
				"playwright": "cli.js"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"fsevents": "2.3.2"
			}
		},
		"node_modules/playwright-core": {
			"version": "1.56.1",
			"dev": true,
			"license": "Apache-2.0",
			"bin": {
				"playwright-core": "cli.js"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/postcss": {
			"version": "8.5.6",
			"dev": true,
			"funding": [
				{
					"type": "opencollective",
					"url": "https://opencollective.com/postcss/"
				},
				{
					"type": "tidelift",
					"url": "https://tidelift.com/funding/github/npm/postcss"
				},
				{
					"type": "github",
					"url": "https://github.com/sponsors/ai"
				}
			],
			"license": "MIT",
			"dependencies": {
				"nanoid": "^3.3.11",
				"picocolors": "^1.1.1",
				"source-map-js": "^1.2.1"
			},
			"engines": {
				"node": "^10 || ^12 || >=14"
			}
		},
		"node_modules/postcss-selector-parser": {
			"version": "6.0.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"cssesc": "^3.0.0",
				"util-deprecate": "^1.0.2"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/postgres": {
			"version": "3.4.7",
			"license": "Unlicense",
			"engines": {
				"node": ">=12"
			},
			"funding": {
				"type": "individual",
				"url": "https://github.com/sponsors/porsager"
			}
		},
		"node_modules/prettier": {
			"version": "3.6.2",
			"dev": true,
			"license": "MIT",
			"bin": {
				"prettier": "bin/prettier.cjs"
			},
			"engines": {
				"node": ">=14"
			},
			"funding": {
				"url": "https://github.com/prettier/prettier?sponsor=1"
			}
		},
		"node_modules/prettier-plugin-svelte": {
			"version": "3.4.0",
			"dev": true,
			"license": "MIT",
			"peerDependencies": {
				"prettier": "^3.0.0",
				"svelte": "^3.2.0 || ^4.0.0-next.0 || ^5.0.0-next.0"
			}
		},
		"node_modules/prettier-plugin-tailwindcss": {
			"version": "0.6.14",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.21.3"
			},
			"peerDependencies": {
				"@ianvs/prettier-plugin-sort-imports": "*",
				"@prettier/plugin-hermes": "*",
				"@prettier/plugin-oxc": "*",
				"@prettier/plugin-pug": "*",
				"@shopify/prettier-plugin-liquid": "*",
				"@trivago/prettier-plugin-sort-imports": "*",
				"@zackad/prettier-plugin-twig": "*",
				"prettier": "^3.0",
				"prettier-plugin-astro": "*",
				"prettier-plugin-css-order": "*",
				"prettier-plugin-import-sort": "*",
				"prettier-plugin-jsdoc": "*",
				"prettier-plugin-marko": "*",
				"prettier-plugin-multiline-arrays": "*",
				"prettier-plugin-organize-attributes": "*",
				"prettier-plugin-organize-imports": "*",
				"prettier-plugin-sort-imports": "*",
				"prettier-plugin-style-order": "*",
				"prettier-plugin-svelte": "*"
			},
			"peerDependenciesMeta": {
				"@ianvs/prettier-plugin-sort-imports": {
					"optional": true
				},
				"@prettier/plugin-hermes": {
					"optional": true
				},
				"@prettier/plugin-oxc": {
					"optional": true
				},
				"@prettier/plugin-pug": {
					"optional": true
				},
				"@shopify/prettier-plugin-liquid": {
					"optional": true
				},
				"@trivago/prettier-plugin-sort-imports": {
					"optional": true
				},
				"@zackad/prettier-plugin-twig": {
					"optional": true
				},
				"prettier-plugin-astro": {
					"optional": true
				},
				"prettier-plugin-css-order": {
					"optional": true
				},
				"prettier-plugin-import-sort": {
					"optional": true
				},
				"prettier-plugin-jsdoc": {
					"optional": true
				},
				"prettier-plugin-marko": {
					"optional": true
				},
				"prettier-plugin-multiline-arrays": {
					"optional": true
				},
				"prettier-plugin-organize-attributes": {
					"optional": true
				},
				"prettier-plugin-organize-imports": {
					"optional": true
				},
				"prettier-plugin-sort-imports": {
					"optional": true
				},
				"prettier-plugin-style-order": {
					"optional": true
				},
				"prettier-plugin-svelte": {
					"optional": true
				}
			}
		},
		"node_modules/pretty-format": {
			"version": "27.5.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"ansi-regex": "^5.0.1",
				"ansi-styles": "^5.0.0",
				"react-is": "^17.0.1"
			},
			"engines": {
				"node": "^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"
			}
		},
		"node_modules/react-is": {
			"version": "17.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/readdirp": {
			"version": "4.1.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 14.18.0"
			},
			"funding": {
				"type": "individual",
				"url": "https://paulmillr.com/funding/"
			}
		},
		"node_modules/regexparam": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/resolve-pkg-maps": {
			"version": "1.0.0",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
			}
		},
		"node_modules/rollup": {
			"version": "4.52.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "1.0.8"
			},
			"bin": {
				"rollup": "dist/bin/rollup"
			},
			"engines": {
				"node": ">=18.0.0",
				"npm": ">=8.0.0"
			},
			"optionalDependencies": {
				"@rollup/rollup-android-arm-eabi": "4.52.5",
				"@rollup/rollup-android-arm64": "4.52.5",
				"@rollup/rollup-darwin-arm64": "4.52.5",
				"@rollup/rollup-darwin-x64": "4.52.5",
				"@rollup/rollup-freebsd-arm64": "4.52.5",
				"@rollup/rollup-freebsd-x64": "4.52.5",
				"@rollup/rollup-linux-arm-gnueabihf": "4.52.5",
				"@rollup/rollup-linux-arm-musleabihf": "4.52.5",
				"@rollup/rollup-linux-arm64-gnu": "4.52.5",
				"@rollup/rollup-linux-arm64-musl": "4.52.5",
				"@rollup/rollup-linux-loong64-gnu": "4.52.5",
				"@rollup/rollup-linux-ppc64-gnu": "4.52.5",
				"@rollup/rollup-linux-riscv64-gnu": "4.52.5",
				"@rollup/rollup-linux-riscv64-musl": "4.52.5",
				"@rollup/rollup-linux-s390x-gnu": "4.52.5",
				"@rollup/rollup-linux-x64-gnu": "4.52.5",
				"@rollup/rollup-linux-x64-musl": "4.52.5",
				"@rollup/rollup-openharmony-arm64": "4.52.5",
				"@rollup/rollup-win32-arm64-msvc": "4.52.5",
				"@rollup/rollup-win32-ia32-msvc": "4.52.5",
				"@rollup/rollup-win32-x64-gnu": "4.52.5",
				"@rollup/rollup-win32-x64-msvc": "4.52.5",
				"fsevents": "~2.3.2"
			}
		},
		"node_modules/rollup/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/sade": {
			"version": "1.8.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mri": "^1.1.0"
			},
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/semver": {
			"version": "7.7.3",
			"dev": true,
			"license": "ISC",
			"bin": {
				"semver": "bin/semver.js"
			},
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/set-cookie-parser": {
			"version": "2.7.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/sharp": {
			"version": "0.33.5",
			"dev": true,
			"hasInstallScript": true,
			"license": "Apache-2.0",
			"dependencies": {
				"color": "^4.2.3",
				"detect-libc": "^2.0.3",
				"semver": "^7.6.3"
			},
			"engines": {
				"node": "^18.17.0 || ^20.3.0 || >=21.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/libvips"
			},
			"optionalDependencies": {
				"@img/sharp-darwin-arm64": "0.33.5",
				"@img/sharp-darwin-x64": "0.33.5",
				"@img/sharp-libvips-darwin-arm64": "1.0.4",
				"@img/sharp-libvips-darwin-x64": "1.0.4",
				"@img/sharp-libvips-linux-arm": "1.0.5",
				"@img/sharp-libvips-linux-arm64": "1.0.4",
				"@img/sharp-libvips-linux-s390x": "1.0.4",
				"@img/sharp-libvips-linux-x64": "1.0.4",
				"@img/sharp-libvips-linuxmusl-arm64": "1.0.4",
				"@img/sharp-libvips-linuxmusl-x64": "1.0.4",
				"@img/sharp-linux-arm": "0.33.5",
				"@img/sharp-linux-arm64": "0.33.5",
				"@img/sharp-linux-s390x": "0.33.5",
				"@img/sharp-linux-x64": "0.33.5",
				"@img/sharp-linuxmusl-arm64": "0.33.5",
				"@img/sharp-linuxmusl-x64": "0.33.5",
				"@img/sharp-wasm32": "0.33.5",
				"@img/sharp-win32-ia32": "0.33.5",
				"@img/sharp-win32-x64": "0.33.5"
			}
		},
		"node_modules/siginfo": {
			"version": "2.0.0",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/simple-swizzle": {
			"version": "0.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"is-arrayish": "^0.3.1"
			}
		},
		"node_modules/sirv": {
			"version": "3.0.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@polka/url": "^1.0.0-next.24",
				"mrmime": "^2.0.0",
				"totalist": "^3.0.0"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/source-map": {
			"version": "0.6.1",
			"dev": true,
			"license": "BSD-3-Clause",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/source-map-js": {
			"version": "1.2.1",
			"dev": true,
			"license": "BSD-3-Clause",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/source-map-support": {
			"version": "0.5.21",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"buffer-from": "^1.0.0",
				"source-map": "^0.6.0"
			}
		},
		"node_modules/stackback": {
			"version": "0.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/std-env": {
			"version": "3.10.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/stoppable": {
			"version": "1.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=4",
				"npm": ">=6"
			}
		},
		"node_modules/strip-literal": {
			"version": "3.1.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"js-tokens": "^9.0.1"
			},
			"funding": {
				"url": "https://github.com/sponsors/antfu"
			}
		},
		"node_modules/strip-literal/node_modules/js-tokens": {
			"version": "9.0.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/supports-color": {
			"version": "10.2.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			},
			"funding": {
				"url": "https://github.com/chalk/supports-color?sponsor=1"
			}
		},
		"node_modules/svelte": {
			"version": "5.41.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/remapping": "^2.3.4",
				"@jridgewell/sourcemap-codec": "^1.5.0",
				"@sveltejs/acorn-typescript": "^1.0.5",
				"@types/estree": "^1.0.5",
				"acorn": "^8.12.1",
				"aria-query": "^5.3.1",
				"axobject-query": "^4.1.0",
				"clsx": "^2.1.1",
				"esm-env": "^1.2.1",
				"esrap": "^2.1.0",
				"is-reference": "^3.0.3",
				"locate-character": "^3.0.0",
				"magic-string": "^0.30.11",
				"zimmerframe": "^1.1.2"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/svelte-check": {
			"version": "4.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/trace-mapping": "^0.3.25",
				"chokidar": "^4.0.1",
				"fdir": "^6.2.0",
				"picocolors": "^1.0.0",
				"sade": "^1.7.4"
			},
			"bin": {
				"svelte-check": "bin/svelte-check"
			},
			"engines": {
				"node": ">= 18.0.0"
			},
			"peerDependencies": {
				"svelte": "^4.0.0 || ^5.0.0-next.0",
				"typescript": ">=5.0.0"
			}
		},
		"node_modules/tailwindcss": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tapable": {
			"version": "2.3.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/webpack"
			}
		},
		"node_modules/tinybench": {
			"version": "2.9.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tinyexec": {
			"version": "0.3.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tinyglobby": {
			"version": "0.2.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"fdir": "^6.5.0",
				"picomatch": "^4.0.3"
			},
			"engines": {
				"node": ">=12.0.0"
			},
			"funding": {
				"url": "https://github.com/sponsors/SuperchupuDev"
			}
		},
		"node_modules/tinypool": {
			"version": "1.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": "^18.0.0 || >=20.0.0"
			}
		},
		"node_modules/tinyrainbow": {
			"version": "2.0.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.0.0"
			}
		},
		"node_modules/tinyspy": {
			"version": "4.0.4",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.0.0"
			}
		},
		"node_modules/totalist": {
			"version": "3.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/typescript": {
			"version": "5.9.3",
			"dev": true,
			"license": "Apache-2.0",
			"bin": {
				"tsc": "bin/tsc",
				"tsserver": "bin/tsserver"
			},
			"engines": {
				"node": ">=14.17"
			}
		},
		"node_modules/ufo": {
			"version": "1.6.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/undici": {
			"version": "7.14.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=20.18.1"
			}
		},
		"node_modules/undici-types": {
			"version": "6.21.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/unenv": {
			"version": "2.0.0-rc.21",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"defu": "^6.1.4",
				"exsolve": "^1.0.7",
				"ohash": "^2.0.11",
				"pathe": "^2.0.3",
				"ufo": "^1.6.1"
			}
		},
		"node_modules/util-deprecate": {
			"version": "1.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/vite": {
			"version": "7.1.11",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"esbuild": "^0.25.0",
				"fdir": "^6.5.0",
				"picomatch": "^4.0.3",
				"postcss": "^8.5.6",
				"rollup": "^4.43.0",
				"tinyglobby": "^0.2.15"
			},
			"bin": {
				"vite": "bin/vite.js"
			},
			"engines": {
				"node": "^20.19.0 || >=22.12.0"
			},
			"funding": {
				"url": "https://github.com/vitejs/vite?sponsor=1"
			},
			"optionalDependencies": {
				"fsevents": "~2.3.3"
			},
			"peerDependencies": {
				"@types/node": "^20.19.0 || >=22.12.0",
				"jiti": ">=1.21.0",
				"less": "^4.0.0",
				"lightningcss": "^1.21.0",
				"sass": "^1.70.0",
				"sass-embedded": "^1.70.0",
				"stylus": ">=0.54.8",
				"sugarss": "^5.0.0",
				"terser": "^5.16.0",
				"tsx": "^4.8.1",
				"yaml": "^2.4.2"
			},
			"peerDependenciesMeta": {
				"@types/node": {
					"optional": true
				},
				"jiti": {
					"optional": true
				},
				"less": {
					"optional": true
				},
				"lightningcss": {
					"optional": true
				},
				"sass": {
					"optional": true
				},
				"sass-embedded": {
					"optional": true
				},
				"stylus": {
					"optional": true
				},
				"sugarss": {
					"optional": true
				},
				"terser": {
					"optional": true
				},
				"tsx": {
					"optional": true
				},
				"yaml": {
					"optional": true
				}
			}
		},
		"node_modules/vite-node": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"cac": "^6.7.14",
				"debug": "^4.4.1",
				"es-module-lexer": "^1.7.0",
				"pathe": "^2.0.3",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
			},
			"bin": {
				"vite-node": "vite-node.mjs"
			},
			"engines": {
				"node": "^18.0.0 || ^20.0.0 || >=22.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/vite/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/vitefu": {
			"version": "1.1.1",
			"dev": true,
			"license": "MIT",
			"workspaces": [
				"tests/deps/*",
				"tests/projects/*",
				"tests/projects/workspace/packages/*"
			],
			"peerDependencies": {
				"vite": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0-beta.0"
			},
			"peerDependenciesMeta": {
				"vite": {
					"optional": true
				}
			}
		},
		"node_modules/vitest": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/chai": "^5.2.2",
				"@vitest/expect": "3.2.4",
				"@vitest/mocker": "3.2.4",
				"@vitest/pretty-format": "^3.2.4",
				"@vitest/runner": "3.2.4",
				"@vitest/snapshot": "3.2.4",
				"@vitest/spy": "3.2.4",
				"@vitest/utils": "3.2.4",
				"chai": "^5.2.0",
				"debug": "^4.4.1",
				"expect-type": "^1.2.1",
				"magic-string": "^0.30.17",
				"pathe": "^2.0.3",
				"picomatch": "^4.0.2",
				"std-env": "^3.9.0",
				"tinybench": "^2.9.0",
				"tinyexec": "^0.3.2",
				"tinyglobby": "^0.2.14",
				"tinypool": "^1.1.1",
				"tinyrainbow": "^2.0.0",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0",
				"vite-node": "3.2.4",
				"why-is-node-running": "^2.3.0"
			},
			"bin": {
				"vitest": "vitest.mjs"
			},
			"engines": {
				"node": "^18.0.0 || ^20.0.0 || >=22.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"@edge-runtime/vm": "*",
				"@types/debug": "^4.1.12",
				"@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
				"@vitest/browser": "3.2.4",
				"@vitest/ui": "3.2.4",
				"happy-dom": "*",
				"jsdom": "*"
			},
			"peerDependenciesMeta": {
				"@edge-runtime/vm": {
					"optional": true
				},
				"@types/debug": {
					"optional": true
				},
				"@types/node": {
					"optional": true
				},
				"@vitest/browser": {
					"optional": true
				},
				"@vitest/ui": {
					"optional": true
				},
				"happy-dom": {
					"optional": true
				},
				"jsdom": {
					"optional": true
				}
			}
		},
		"node_modules/vitest-browser-svelte": {
			"version": "1.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": "^18.0.0 || >=20.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"@vitest/browser": "^2.1.0 || ^3.0.0 || ^4.0.0-0",
				"svelte": "^3 || ^4 || ^5 || ^5.0.0-next.0",
				"vitest": "^2.1.0 || ^3.0.0 || ^4.0.0-0"
			}
		},
		"node_modules/why-is-node-running": {
			"version": "2.3.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"siginfo": "^2.0.0",
				"stackback": "0.0.2"
			},
			"bin": {
				"why-is-node-running": "cli.js"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/workerd": {
			"version": "1.20251011.0",
			"dev": true,
			"hasInstallScript": true,
			"license": "Apache-2.0",
			"bin": {
				"workerd": "bin/workerd"
			},
			"engines": {
				"node": ">=16"
			},
			"optionalDependencies": {
				"@cloudflare/workerd-darwin-64": "1.20251011.0",
				"@cloudflare/workerd-darwin-arm64": "1.20251011.0",
				"@cloudflare/workerd-linux-64": "1.20251011.0",
				"@cloudflare/workerd-linux-arm64": "1.20251011.0",
				"@cloudflare/workerd-windows-64": "1.20251011.0"
			}
		},
		"node_modules/worktop": {
			"version": "0.8.0-next.18",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mrmime": "^2.0.0",
				"regexparam": "^3.0.0"
			},
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/wrangler": {
			"version": "4.44.0",
			"resolved": "https://registry.npmjs.org/wrangler/-/wrangler-4.44.0.tgz",
			"integrity": "sha512-BLOUigckcWZ0r4rm7b5PuaTpb9KP9as0XeCRSJ8kqcNgXcKoUD3Ij8FlPvN25KybLnFnetaO0ZdfRYUPWle4qw==",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"dependencies": {
				"@cloudflare/kv-asset-handler": "0.4.0",
				"@cloudflare/unenv-preset": "2.7.8",
				"blake3-wasm": "2.1.5",
				"esbuild": "0.25.4",
				"miniflare": "4.20251011.0",
				"path-to-regexp": "6.3.0",
				"unenv": "2.0.0-rc.21",
				"workerd": "1.20251011.0"
			},
			"bin": {
				"wrangler": "bin/wrangler.js",
				"wrangler2": "bin/wrangler.js"
			},
			"engines": {
				"node": ">=18.0.0"
			},
			"optionalDependencies": {
				"fsevents": "~2.3.2"
			},
			"peerDependencies": {
				"@cloudflare/workers-types": "^4.20251011.0"
			},
			"peerDependenciesMeta": {
				"@cloudflare/workers-types": {
					"optional": true
				}
			}
		},
		"node_modules/wrangler/node_modules/esbuild": {
			"version": "0.25.4",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"@esbuild/aix-ppc64": "0.25.4",
				"@esbuild/android-arm": "0.25.4",
				"@esbuild/android-arm64": "0.25.4",
				"@esbuild/android-x64": "0.25.4",
				"@esbuild/darwin-arm64": "0.25.4",
				"@esbuild/darwin-x64": "0.25.4",
				"@esbuild/freebsd-arm64": "0.25.4",
				"@esbuild/freebsd-x64": "0.25.4",
				"@esbuild/linux-arm": "0.25.4",
				"@esbuild/linux-arm64": "0.25.4",
				"@esbuild/linux-ia32": "0.25.4",
				"@esbuild/linux-loong64": "0.25.4",
				"@esbuild/linux-mips64el": "0.25.4",
				"@esbuild/linux-ppc64": "0.25.4",
				"@esbuild/linux-riscv64": "0.25.4",
				"@esbuild/linux-s390x": "0.25.4",
				"@esbuild/linux-x64": "0.25.4",
				"@esbuild/netbsd-arm64": "0.25.4",
				"@esbuild/netbsd-x64": "0.25.4",
				"@esbuild/openbsd-arm64": "0.25.4",
				"@esbuild/openbsd-x64": "0.25.4",
				"@esbuild/sunos-x64": "0.25.4",
				"@esbuild/win32-arm64": "0.25.4",
				"@esbuild/win32-ia32": "0.25.4",
				"@esbuild/win32-x64": "0.25.4"
			}
		},
		"node_modules/wrangler/node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
			"version": "0.25.4",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/wrangler/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/ws": {
			"version": "8.18.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10.0.0"
			},
			"peerDependencies": {
				"bufferutil": "^4.0.1",
				"utf-8-validate": ">=5.0.2"
			},
			"peerDependenciesMeta": {
				"bufferutil": {
					"optional": true
				},
				"utf-8-validate": {
					"optional": true
				}
			}
		},
		"node_modules/youch": {
			"version": "4.1.0-beta.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/colors": "^4.1.5",
				"@poppinss/dumper": "^0.6.4",
				"@speed-highlight/core": "^1.2.7",
				"cookie": "^1.0.2",
				"youch-core": "^0.3.3"
			}
		},
		"node_modules/youch-core": {
			"version": "0.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/exception": "^1.2.2",
				"error-stack-parser-es": "^1.0.5"
			}
		},
		"node_modules/youch/node_modules/cookie": {
			"version": "1.0.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/zimmerframe": {
			"version": "1.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/zod": {
			"version": "3.22.3",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/sponsors/colinhacks"
			}
		}
	}
}
</file>

<file path=".history/package-lock_20251023113853.json">
{
	"name": "rushesbe",
	"version": "0.0.1",
	"lockfileVersion": 3,
	"requires": true,
	"packages": {
		"": {
			"name": "rushesbe",
			"version": "0.0.1",
			"dependencies": {
				"postgres": "^3.4.7"
			},
			"devDependencies": {
				"@sveltejs/adapter-cloudflare": "^7.2.4",
				"@sveltejs/kit": "^2.43.2",
				"@sveltejs/vite-plugin-svelte": "^6.2.0",
				"@tailwindcss/forms": "^0.5.10",
				"@tailwindcss/typography": "^0.5.18",
				"@tailwindcss/vite": "^4.1.13",
				"@types/node": "^22",
				"@vitest/browser": "^3.2.4",
				"drizzle-kit": "^0.31.4",
				"drizzle-orm": "^0.44.5",
				"playwright": "^1.55.1",
				"prettier": "^3.6.2",
				"prettier-plugin-svelte": "^3.4.0",
				"prettier-plugin-tailwindcss": "^0.6.14",
				"svelte": "^5.39.5",
				"svelte-check": "^4.3.2",
				"tailwindcss": "^4.1.13",
				"typescript": "^5.9.2",
				"vite": "^7.1.7",
				"vitest": "^3.2.4",
				"vitest-browser-svelte": "^1.1.0",
				"wrangler": "^4.44.0"
			}
		},
		"node_modules/@babel/code-frame": {
			"version": "7.27.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@babel/helper-validator-identifier": "^7.27.1",
				"js-tokens": "^4.0.0",
				"picocolors": "^1.1.1"
			},
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/helper-validator-identifier": {
			"version": "7.27.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@babel/runtime": {
			"version": "7.28.4",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.9.0"
			}
		},
		"node_modules/@cloudflare/kv-asset-handler": {
			"version": "0.4.0",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"dependencies": {
				"mime": "^3.0.0"
			},
			"engines": {
				"node": ">=18.0.0"
			}
		},
		"node_modules/@cloudflare/unenv-preset": {
			"version": "2.7.8",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"peerDependencies": {
				"unenv": "2.0.0-rc.21",
				"workerd": "^1.20250927.0"
			},
			"peerDependenciesMeta": {
				"workerd": {
					"optional": true
				}
			}
		},
		"node_modules/@cloudflare/workerd-darwin-arm64": {
			"version": "1.20251011.0",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=16"
			}
		},
		"node_modules/@cloudflare/workers-types": {
			"version": "4.20251014.0",
			"dev": true,
			"license": "MIT OR Apache-2.0"
		},
		"node_modules/@cspotcode/source-map-support": {
			"version": "0.8.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/trace-mapping": "0.3.9"
			},
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/@cspotcode/source-map-support/node_modules/@jridgewell/trace-mapping": {
			"version": "0.3.9",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/resolve-uri": "^3.0.3",
				"@jridgewell/sourcemap-codec": "^1.4.10"
			}
		},
		"node_modules/@drizzle-team/brocli": {
			"version": "0.10.2",
			"dev": true,
			"license": "Apache-2.0"
		},
		"node_modules/@esbuild-kit/core-utils": {
			"version": "3.3.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"esbuild": "~0.18.20",
				"source-map-support": "^0.5.21"
			}
		},
		"node_modules/@esbuild-kit/core-utils/node_modules/esbuild": {
			"version": "0.18.20",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=12"
			},
			"optionalDependencies": {
				"@esbuild/android-arm": "0.18.20",
				"@esbuild/android-arm64": "0.18.20",
				"@esbuild/android-x64": "0.18.20",
				"@esbuild/darwin-arm64": "0.18.20",
				"@esbuild/darwin-x64": "0.18.20",
				"@esbuild/freebsd-arm64": "0.18.20",
				"@esbuild/freebsd-x64": "0.18.20",
				"@esbuild/linux-arm": "0.18.20",
				"@esbuild/linux-arm64": "0.18.20",
				"@esbuild/linux-ia32": "0.18.20",
				"@esbuild/linux-loong64": "0.18.20",
				"@esbuild/linux-mips64el": "0.18.20",
				"@esbuild/linux-ppc64": "0.18.20",
				"@esbuild/linux-riscv64": "0.18.20",
				"@esbuild/linux-s390x": "0.18.20",
				"@esbuild/linux-x64": "0.18.20",
				"@esbuild/netbsd-x64": "0.18.20",
				"@esbuild/openbsd-x64": "0.18.20",
				"@esbuild/sunos-x64": "0.18.20",
				"@esbuild/win32-arm64": "0.18.20",
				"@esbuild/win32-ia32": "0.18.20",
				"@esbuild/win32-x64": "0.18.20"
			}
		},
		"node_modules/@esbuild-kit/core-utils/node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
			"version": "0.18.20",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/@esbuild-kit/esm-loader": {
			"version": "2.6.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@esbuild-kit/core-utils": "^3.3.2",
				"get-tsconfig": "^4.7.0"
			}
		},
		"node_modules/@esbuild/darwin-arm64": {
			"version": "0.25.11",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/@img/sharp-darwin-arm64": {
			"version": "0.33.5",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "Apache-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^18.17.0 || ^20.3.0 || >=21.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/libvips"
			},
			"optionalDependencies": {
				"@img/sharp-libvips-darwin-arm64": "1.0.4"
			}
		},
		"node_modules/@img/sharp-libvips-darwin-arm64": {
			"version": "1.0.4",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "LGPL-3.0-or-later",
			"optional": true,
			"os": [
				"darwin"
			],
			"funding": {
				"url": "https://opencollective.com/libvips"
			}
		},
		"node_modules/@jridgewell/gen-mapping": {
			"version": "0.3.13",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.5.0",
				"@jridgewell/trace-mapping": "^0.3.24"
			}
		},
		"node_modules/@jridgewell/remapping": {
			"version": "2.3.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/gen-mapping": "^0.3.5",
				"@jridgewell/trace-mapping": "^0.3.24"
			}
		},
		"node_modules/@jridgewell/resolve-uri": {
			"version": "3.1.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6.0.0"
			}
		},
		"node_modules/@jridgewell/sourcemap-codec": {
			"version": "1.5.5",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@jridgewell/trace-mapping": {
			"version": "0.3.31",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/resolve-uri": "^3.1.0",
				"@jridgewell/sourcemap-codec": "^1.4.14"
			}
		},
		"node_modules/@polka/url": {
			"version": "1.0.0-next.29",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@poppinss/colors": {
			"version": "4.1.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"kleur": "^4.1.5"
			}
		},
		"node_modules/@poppinss/dumper": {
			"version": "0.6.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/colors": "^4.1.5",
				"@sindresorhus/is": "^7.0.2",
				"supports-color": "^10.0.0"
			}
		},
		"node_modules/@poppinss/exception": {
			"version": "1.2.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@rollup/rollup-darwin-arm64": {
			"version": "4.52.5",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			]
		},
		"node_modules/@sindresorhus/is": {
			"version": "7.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			},
			"funding": {
				"url": "https://github.com/sindresorhus/is?sponsor=1"
			}
		},
		"node_modules/@speed-highlight/core": {
			"version": "1.2.7",
			"dev": true,
			"license": "CC0-1.0"
		},
		"node_modules/@standard-schema/spec": {
			"version": "1.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@sveltejs/acorn-typescript": {
			"version": "1.0.6",
			"dev": true,
			"license": "MIT",
			"peerDependencies": {
				"acorn": "^8.9.0"
			}
		},
		"node_modules/@sveltejs/adapter-cloudflare": {
			"version": "7.2.4",
			"resolved": "https://registry.npmjs.org/@sveltejs/adapter-cloudflare/-/adapter-cloudflare-7.2.4.tgz",
			"integrity": "sha512-uD8VlOuGXGuZWL+zbBYSjtmC4WDtlonUodfqAZ/COd5uIy2Z0QptIicB/nkTrGNI9sbmzgf7z0N09CHyWYlUvQ==",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@cloudflare/workers-types": "^4.20250507.0",
				"worktop": "0.8.0-next.18"
			},
			"peerDependencies": {
				"@sveltejs/kit": "^2.0.0",
				"wrangler": "^4.0.0"
			}
		},
		"node_modules/@sveltejs/kit": {
			"version": "2.47.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@standard-schema/spec": "^1.0.0",
				"@sveltejs/acorn-typescript": "^1.0.5",
				"@types/cookie": "^0.6.0",
				"acorn": "^8.14.1",
				"cookie": "^0.6.0",
				"devalue": "^5.3.2",
				"esm-env": "^1.2.2",
				"kleur": "^4.1.5",
				"magic-string": "^0.30.5",
				"mrmime": "^2.0.0",
				"sade": "^1.8.1",
				"set-cookie-parser": "^2.6.0",
				"sirv": "^3.0.0"
			},
			"bin": {
				"svelte-kit": "svelte-kit.js"
			},
			"engines": {
				"node": ">=18.13"
			},
			"peerDependencies": {
				"@opentelemetry/api": "^1.0.0",
				"@sveltejs/vite-plugin-svelte": "^3.0.0 || ^4.0.0-next.1 || ^5.0.0 || ^6.0.0-next.0",
				"svelte": "^4.0.0 || ^5.0.0-next.0",
				"vite": "^5.0.3 || ^6.0.0 || ^7.0.0-beta.0"
			},
			"peerDependenciesMeta": {
				"@opentelemetry/api": {
					"optional": true
				}
			}
		},
		"node_modules/@sveltejs/vite-plugin-svelte": {
			"version": "6.2.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@sveltejs/vite-plugin-svelte-inspector": "^5.0.0",
				"debug": "^4.4.1",
				"deepmerge": "^4.3.1",
				"magic-string": "^0.30.17",
				"vitefu": "^1.1.1"
			},
			"engines": {
				"node": "^20.19 || ^22.12 || >=24"
			},
			"peerDependencies": {
				"svelte": "^5.0.0",
				"vite": "^6.3.0 || ^7.0.0"
			}
		},
		"node_modules/@sveltejs/vite-plugin-svelte-inspector": {
			"version": "5.0.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"debug": "^4.4.1"
			},
			"engines": {
				"node": "^20.19 || ^22.12 || >=24"
			},
			"peerDependencies": {
				"@sveltejs/vite-plugin-svelte": "^6.0.0-next.0",
				"svelte": "^5.0.0",
				"vite": "^6.3.0 || ^7.0.0"
			}
		},
		"node_modules/@tailwindcss/forms": {
			"version": "0.5.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mini-svg-data-uri": "^1.2.3"
			},
			"peerDependencies": {
				"tailwindcss": ">=3.0.0 || >= 3.0.0-alpha.1 || >= 4.0.0-alpha.20 || >= 4.0.0-beta.1"
			}
		},
		"node_modules/@tailwindcss/node": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/remapping": "^2.3.4",
				"enhanced-resolve": "^5.18.3",
				"jiti": "^2.6.0",
				"lightningcss": "1.30.2",
				"magic-string": "^0.30.19",
				"source-map-js": "^1.2.1",
				"tailwindcss": "4.1.15"
			}
		},
		"node_modules/@tailwindcss/oxide": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 10"
			},
			"optionalDependencies": {
				"@tailwindcss/oxide-android-arm64": "4.1.15",
				"@tailwindcss/oxide-darwin-arm64": "4.1.15",
				"@tailwindcss/oxide-darwin-x64": "4.1.15",
				"@tailwindcss/oxide-freebsd-x64": "4.1.15",
				"@tailwindcss/oxide-linux-arm-gnueabihf": "4.1.15",
				"@tailwindcss/oxide-linux-arm64-gnu": "4.1.15",
				"@tailwindcss/oxide-linux-arm64-musl": "4.1.15",
				"@tailwindcss/oxide-linux-x64-gnu": "4.1.15",
				"@tailwindcss/oxide-linux-x64-musl": "4.1.15",
				"@tailwindcss/oxide-wasm32-wasi": "4.1.15",
				"@tailwindcss/oxide-win32-arm64-msvc": "4.1.15",
				"@tailwindcss/oxide-win32-x64-msvc": "4.1.15"
			}
		},
		"node_modules/@tailwindcss/oxide-darwin-arm64": {
			"version": "4.1.15",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">= 10"
			}
		},
		"node_modules/@tailwindcss/typography": {
			"version": "0.5.19",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"postcss-selector-parser": "6.0.10"
			},
			"peerDependencies": {
				"tailwindcss": ">=3.0.0 || insiders || >=4.0.0-alpha.20 || >=4.0.0-beta.1"
			}
		},
		"node_modules/@tailwindcss/vite": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@tailwindcss/node": "4.1.15",
				"@tailwindcss/oxide": "4.1.15",
				"tailwindcss": "4.1.15"
			},
			"peerDependencies": {
				"vite": "^5.2.0 || ^6 || ^7"
			}
		},
		"node_modules/@testing-library/dom": {
			"version": "10.4.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@babel/code-frame": "^7.10.4",
				"@babel/runtime": "^7.12.5",
				"@types/aria-query": "^5.0.1",
				"aria-query": "5.3.0",
				"dom-accessibility-api": "^0.5.9",
				"lz-string": "^1.5.0",
				"picocolors": "1.1.1",
				"pretty-format": "^27.0.2"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/@testing-library/dom/node_modules/aria-query": {
			"version": "5.3.0",
			"dev": true,
			"license": "Apache-2.0",
			"dependencies": {
				"dequal": "^2.0.3"
			}
		},
		"node_modules/@testing-library/user-event": {
			"version": "14.6.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12",
				"npm": ">=6"
			},
			"peerDependencies": {
				"@testing-library/dom": ">=7.21.4"
			}
		},
		"node_modules/@types/aria-query": {
			"version": "5.0.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/chai": {
			"version": "5.2.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/deep-eql": "*",
				"assertion-error": "^2.0.1"
			}
		},
		"node_modules/@types/cookie": {
			"version": "0.6.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/deep-eql": {
			"version": "4.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/estree": {
			"version": "1.0.8",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/@types/node": {
			"version": "22.18.12",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"undici-types": "~6.21.0"
			}
		},
		"node_modules/@vitest/browser": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@testing-library/dom": "^10.4.0",
				"@testing-library/user-event": "^14.6.1",
				"@vitest/mocker": "3.2.4",
				"@vitest/utils": "3.2.4",
				"magic-string": "^0.30.17",
				"sirv": "^3.0.1",
				"tinyrainbow": "^2.0.0",
				"ws": "^8.18.2"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"playwright": "*",
				"vitest": "3.2.4",
				"webdriverio": "^7.0.0 || ^8.0.0 || ^9.0.0"
			},
			"peerDependenciesMeta": {
				"playwright": {
					"optional": true
				},
				"safaridriver": {
					"optional": true
				},
				"webdriverio": {
					"optional": true
				}
			}
		},
		"node_modules/@vitest/expect": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/chai": "^5.2.2",
				"@vitest/spy": "3.2.4",
				"@vitest/utils": "3.2.4",
				"chai": "^5.2.0",
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/mocker": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/spy": "3.2.4",
				"estree-walker": "^3.0.3",
				"magic-string": "^0.30.17"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"msw": "^2.4.9",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
			},
			"peerDependenciesMeta": {
				"msw": {
					"optional": true
				},
				"vite": {
					"optional": true
				}
			}
		},
		"node_modules/@vitest/pretty-format": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/runner": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/utils": "3.2.4",
				"pathe": "^2.0.3",
				"strip-literal": "^3.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/snapshot": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/pretty-format": "3.2.4",
				"magic-string": "^0.30.17",
				"pathe": "^2.0.3"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/spy": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"tinyspy": "^4.0.3"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/@vitest/utils": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@vitest/pretty-format": "3.2.4",
				"loupe": "^3.1.4",
				"tinyrainbow": "^2.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/acorn": {
			"version": "8.15.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"acorn": "bin/acorn"
			},
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/acorn-walk": {
			"version": "8.3.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/ansi-regex": {
			"version": "5.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/ansi-styles": {
			"version": "5.2.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10"
			},
			"funding": {
				"url": "https://github.com/chalk/ansi-styles?sponsor=1"
			}
		},
		"node_modules/aria-query": {
			"version": "5.3.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">= 0.4"
			}
		},
		"node_modules/assertion-error": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/axobject-query": {
			"version": "4.1.0",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">= 0.4"
			}
		},
		"node_modules/blake3-wasm": {
			"version": "2.1.5",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/buffer-from": {
			"version": "1.1.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/cac": {
			"version": "6.7.14",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/chai": {
			"version": "5.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"assertion-error": "^2.0.1",
				"check-error": "^2.1.1",
				"deep-eql": "^5.0.1",
				"loupe": "^3.1.0",
				"pathval": "^2.0.0"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/check-error": {
			"version": "2.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 16"
			}
		},
		"node_modules/chokidar": {
			"version": "4.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"readdirp": "^4.0.1"
			},
			"engines": {
				"node": ">= 14.16.0"
			},
			"funding": {
				"url": "https://paulmillr.com/funding/"
			}
		},
		"node_modules/clsx": {
			"version": "2.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/color": {
			"version": "4.2.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-convert": "^2.0.1",
				"color-string": "^1.9.0"
			},
			"engines": {
				"node": ">=12.5.0"
			}
		},
		"node_modules/color-convert": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-name": "~1.1.4"
			},
			"engines": {
				"node": ">=7.0.0"
			}
		},
		"node_modules/color-name": {
			"version": "1.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/color-string": {
			"version": "1.9.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"color-name": "^1.0.0",
				"simple-swizzle": "^0.2.2"
			}
		},
		"node_modules/cookie": {
			"version": "0.6.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 0.6"
			}
		},
		"node_modules/cssesc": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"cssesc": "bin/cssesc"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/debug": {
			"version": "4.4.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"ms": "^2.1.3"
			},
			"engines": {
				"node": ">=6.0"
			},
			"peerDependenciesMeta": {
				"supports-color": {
					"optional": true
				}
			}
		},
		"node_modules/deep-eql": {
			"version": "5.0.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/deepmerge": {
			"version": "4.3.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/defu": {
			"version": "6.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/dequal": {
			"version": "2.0.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/detect-libc": {
			"version": "2.1.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/devalue": {
			"version": "5.4.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/dom-accessibility-api": {
			"version": "0.5.16",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/drizzle-kit": {
			"version": "0.31.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@drizzle-team/brocli": "^0.10.2",
				"@esbuild-kit/esm-loader": "^2.5.5",
				"esbuild": "^0.25.4",
				"esbuild-register": "^3.5.0"
			},
			"bin": {
				"drizzle-kit": "bin.cjs"
			}
		},
		"node_modules/drizzle-orm": {
			"version": "0.44.6",
			"dev": true,
			"license": "Apache-2.0",
			"peerDependencies": {
				"@aws-sdk/client-rds-data": ">=3",
				"@cloudflare/workers-types": ">=4",
				"@electric-sql/pglite": ">=0.2.0",
				"@libsql/client": ">=0.10.0",
				"@libsql/client-wasm": ">=0.10.0",
				"@op-engineering/op-sqlite": ">=2",
				"@opentelemetry/api": "^1.4.1",
				"@planetscale/database": ">=1.13",
				"@prisma/client": "*",
				"@tidbcloud/serverless": "*",
				"@types/better-sqlite3": "*",
				"@types/pg": "*",
				"@types/sql.js": "*",
				"@upstash/redis": ">=1.34.7",
				"@vercel/postgres": ">=0.8.0",
				"@xata.io/client": "*",
				"better-sqlite3": ">=7",
				"bun-types": "*",
				"expo-sqlite": ">=14.0.0",
				"gel": ">=2",
				"knex": "*",
				"kysely": "*",
				"mysql2": ">=2",
				"pg": ">=8",
				"postgres": ">=3",
				"sql.js": ">=1",
				"sqlite3": ">=5"
			},
			"peerDependenciesMeta": {
				"@aws-sdk/client-rds-data": {
					"optional": true
				},
				"@cloudflare/workers-types": {
					"optional": true
				},
				"@electric-sql/pglite": {
					"optional": true
				},
				"@libsql/client": {
					"optional": true
				},
				"@libsql/client-wasm": {
					"optional": true
				},
				"@op-engineering/op-sqlite": {
					"optional": true
				},
				"@opentelemetry/api": {
					"optional": true
				},
				"@planetscale/database": {
					"optional": true
				},
				"@prisma/client": {
					"optional": true
				},
				"@tidbcloud/serverless": {
					"optional": true
				},
				"@types/better-sqlite3": {
					"optional": true
				},
				"@types/pg": {
					"optional": true
				},
				"@types/sql.js": {
					"optional": true
				},
				"@upstash/redis": {
					"optional": true
				},
				"@vercel/postgres": {
					"optional": true
				},
				"@xata.io/client": {
					"optional": true
				},
				"better-sqlite3": {
					"optional": true
				},
				"bun-types": {
					"optional": true
				},
				"expo-sqlite": {
					"optional": true
				},
				"gel": {
					"optional": true
				},
				"knex": {
					"optional": true
				},
				"kysely": {
					"optional": true
				},
				"mysql2": {
					"optional": true
				},
				"pg": {
					"optional": true
				},
				"postgres": {
					"optional": true
				},
				"prisma": {
					"optional": true
				},
				"sql.js": {
					"optional": true
				},
				"sqlite3": {
					"optional": true
				}
			}
		},
		"node_modules/enhanced-resolve": {
			"version": "5.18.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"graceful-fs": "^4.2.4",
				"tapable": "^2.2.0"
			},
			"engines": {
				"node": ">=10.13.0"
			}
		},
		"node_modules/error-stack-parser-es": {
			"version": "1.0.5",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/sponsors/antfu"
			}
		},
		"node_modules/es-module-lexer": {
			"version": "1.7.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/esbuild": {
			"version": "0.25.11",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"@esbuild/aix-ppc64": "0.25.11",
				"@esbuild/android-arm": "0.25.11",
				"@esbuild/android-arm64": "0.25.11",
				"@esbuild/android-x64": "0.25.11",
				"@esbuild/darwin-arm64": "0.25.11",
				"@esbuild/darwin-x64": "0.25.11",
				"@esbuild/freebsd-arm64": "0.25.11",
				"@esbuild/freebsd-x64": "0.25.11",
				"@esbuild/linux-arm": "0.25.11",
				"@esbuild/linux-arm64": "0.25.11",
				"@esbuild/linux-ia32": "0.25.11",
				"@esbuild/linux-loong64": "0.25.11",
				"@esbuild/linux-mips64el": "0.25.11",
				"@esbuild/linux-ppc64": "0.25.11",
				"@esbuild/linux-riscv64": "0.25.11",
				"@esbuild/linux-s390x": "0.25.11",
				"@esbuild/linux-x64": "0.25.11",
				"@esbuild/netbsd-arm64": "0.25.11",
				"@esbuild/netbsd-x64": "0.25.11",
				"@esbuild/openbsd-arm64": "0.25.11",
				"@esbuild/openbsd-x64": "0.25.11",
				"@esbuild/openharmony-arm64": "0.25.11",
				"@esbuild/sunos-x64": "0.25.11",
				"@esbuild/win32-arm64": "0.25.11",
				"@esbuild/win32-ia32": "0.25.11",
				"@esbuild/win32-x64": "0.25.11"
			}
		},
		"node_modules/esbuild-register": {
			"version": "3.6.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"debug": "^4.3.4"
			},
			"peerDependencies": {
				"esbuild": ">=0.12 <1"
			}
		},
		"node_modules/esm-env": {
			"version": "1.2.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/esrap": {
			"version": "2.1.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.4.15"
			}
		},
		"node_modules/estree-walker": {
			"version": "3.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "^1.0.0"
			}
		},
		"node_modules/exit-hook": {
			"version": "2.2.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"url": "https://github.com/sponsors/sindresorhus"
			}
		},
		"node_modules/expect-type": {
			"version": "1.2.2",
			"dev": true,
			"license": "Apache-2.0",
			"engines": {
				"node": ">=12.0.0"
			}
		},
		"node_modules/exsolve": {
			"version": "1.0.7",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/fdir": {
			"version": "6.5.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12.0.0"
			},
			"peerDependencies": {
				"picomatch": "^3 || ^4"
			},
			"peerDependenciesMeta": {
				"picomatch": {
					"optional": true
				}
			}
		},
		"node_modules/fsevents": {
			"version": "2.3.2",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/get-tsconfig": {
			"version": "4.13.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"resolve-pkg-maps": "^1.0.0"
			},
			"funding": {
				"url": "https://github.com/privatenumber/get-tsconfig?sponsor=1"
			}
		},
		"node_modules/glob-to-regexp": {
			"version": "0.4.1",
			"dev": true,
			"license": "BSD-2-Clause"
		},
		"node_modules/graceful-fs": {
			"version": "4.2.11",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/is-arrayish": {
			"version": "0.3.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/is-reference": {
			"version": "3.0.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "^1.0.6"
			}
		},
		"node_modules/jiti": {
			"version": "2.6.1",
			"dev": true,
			"license": "MIT",
			"bin": {
				"jiti": "lib/jiti-cli.mjs"
			}
		},
		"node_modules/js-tokens": {
			"version": "4.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/kleur": {
			"version": "4.1.5",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/lightningcss": {
			"version": "1.30.2",
			"dev": true,
			"license": "MPL-2.0",
			"dependencies": {
				"detect-libc": "^2.0.3"
			},
			"engines": {
				"node": ">= 12.0.0"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/parcel"
			},
			"optionalDependencies": {
				"lightningcss-android-arm64": "1.30.2",
				"lightningcss-darwin-arm64": "1.30.2",
				"lightningcss-darwin-x64": "1.30.2",
				"lightningcss-freebsd-x64": "1.30.2",
				"lightningcss-linux-arm-gnueabihf": "1.30.2",
				"lightningcss-linux-arm64-gnu": "1.30.2",
				"lightningcss-linux-arm64-musl": "1.30.2",
				"lightningcss-linux-x64-gnu": "1.30.2",
				"lightningcss-linux-x64-musl": "1.30.2",
				"lightningcss-win32-arm64-msvc": "1.30.2",
				"lightningcss-win32-x64-msvc": "1.30.2"
			}
		},
		"node_modules/lightningcss-darwin-arm64": {
			"version": "1.30.2",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MPL-2.0",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">= 12.0.0"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/parcel"
			}
		},
		"node_modules/locate-character": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/loupe": {
			"version": "3.2.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/lz-string": {
			"version": "1.5.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"lz-string": "bin/bin.js"
			}
		},
		"node_modules/magic-string": {
			"version": "0.30.19",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/sourcemap-codec": "^1.5.5"
			}
		},
		"node_modules/mime": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"mime": "cli.js"
			},
			"engines": {
				"node": ">=10.0.0"
			}
		},
		"node_modules/mini-svg-data-uri": {
			"version": "1.4.4",
			"dev": true,
			"license": "MIT",
			"bin": {
				"mini-svg-data-uri": "cli.js"
			}
		},
		"node_modules/miniflare": {
			"version": "4.20251011.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@cspotcode/source-map-support": "0.8.1",
				"acorn": "8.14.0",
				"acorn-walk": "8.3.2",
				"exit-hook": "2.2.1",
				"glob-to-regexp": "0.4.1",
				"sharp": "^0.33.5",
				"stoppable": "1.1.0",
				"undici": "7.14.0",
				"workerd": "1.20251011.0",
				"ws": "8.18.0",
				"youch": "4.1.0-beta.10",
				"zod": "3.22.3"
			},
			"bin": {
				"miniflare": "bootstrap.js"
			},
			"engines": {
				"node": ">=18.0.0"
			}
		},
		"node_modules/miniflare/node_modules/acorn": {
			"version": "8.14.0",
			"dev": true,
			"license": "MIT",
			"bin": {
				"acorn": "bin/acorn"
			},
			"engines": {
				"node": ">=0.4.0"
			}
		},
		"node_modules/miniflare/node_modules/ws": {
			"version": "8.18.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10.0.0"
			},
			"peerDependencies": {
				"bufferutil": "^4.0.1",
				"utf-8-validate": ">=5.0.2"
			},
			"peerDependenciesMeta": {
				"bufferutil": {
					"optional": true
				},
				"utf-8-validate": {
					"optional": true
				}
			}
		},
		"node_modules/mri": {
			"version": "1.2.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/mrmime": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/ms": {
			"version": "2.1.3",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/nanoid": {
			"version": "3.3.11",
			"dev": true,
			"funding": [
				{
					"type": "github",
					"url": "https://github.com/sponsors/ai"
				}
			],
			"license": "MIT",
			"bin": {
				"nanoid": "bin/nanoid.cjs"
			},
			"engines": {
				"node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
			}
		},
		"node_modules/ohash": {
			"version": "2.0.11",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/path-to-regexp": {
			"version": "6.3.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/pathe": {
			"version": "2.0.3",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/pathval": {
			"version": "2.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 14.16"
			}
		},
		"node_modules/picocolors": {
			"version": "1.1.1",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/picomatch": {
			"version": "4.0.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=12"
			},
			"funding": {
				"url": "https://github.com/sponsors/jonschlinkert"
			}
		},
		"node_modules/playwright": {
			"version": "1.56.1",
			"dev": true,
			"license": "Apache-2.0",
			"dependencies": {
				"playwright-core": "1.56.1"
			},
			"bin": {
				"playwright": "cli.js"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"fsevents": "2.3.2"
			}
		},
		"node_modules/playwright-core": {
			"version": "1.56.1",
			"dev": true,
			"license": "Apache-2.0",
			"bin": {
				"playwright-core": "cli.js"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/postcss": {
			"version": "8.5.6",
			"dev": true,
			"funding": [
				{
					"type": "opencollective",
					"url": "https://opencollective.com/postcss/"
				},
				{
					"type": "tidelift",
					"url": "https://tidelift.com/funding/github/npm/postcss"
				},
				{
					"type": "github",
					"url": "https://github.com/sponsors/ai"
				}
			],
			"license": "MIT",
			"dependencies": {
				"nanoid": "^3.3.11",
				"picocolors": "^1.1.1",
				"source-map-js": "^1.2.1"
			},
			"engines": {
				"node": "^10 || ^12 || >=14"
			}
		},
		"node_modules/postcss-selector-parser": {
			"version": "6.0.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"cssesc": "^3.0.0",
				"util-deprecate": "^1.0.2"
			},
			"engines": {
				"node": ">=4"
			}
		},
		"node_modules/postgres": {
			"version": "3.4.7",
			"license": "Unlicense",
			"engines": {
				"node": ">=12"
			},
			"funding": {
				"type": "individual",
				"url": "https://github.com/sponsors/porsager"
			}
		},
		"node_modules/prettier": {
			"version": "3.6.2",
			"dev": true,
			"license": "MIT",
			"bin": {
				"prettier": "bin/prettier.cjs"
			},
			"engines": {
				"node": ">=14"
			},
			"funding": {
				"url": "https://github.com/prettier/prettier?sponsor=1"
			}
		},
		"node_modules/prettier-plugin-svelte": {
			"version": "3.4.0",
			"dev": true,
			"license": "MIT",
			"peerDependencies": {
				"prettier": "^3.0.0",
				"svelte": "^3.2.0 || ^4.0.0-next.0 || ^5.0.0-next.0"
			}
		},
		"node_modules/prettier-plugin-tailwindcss": {
			"version": "0.6.14",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.21.3"
			},
			"peerDependencies": {
				"@ianvs/prettier-plugin-sort-imports": "*",
				"@prettier/plugin-hermes": "*",
				"@prettier/plugin-oxc": "*",
				"@prettier/plugin-pug": "*",
				"@shopify/prettier-plugin-liquid": "*",
				"@trivago/prettier-plugin-sort-imports": "*",
				"@zackad/prettier-plugin-twig": "*",
				"prettier": "^3.0",
				"prettier-plugin-astro": "*",
				"prettier-plugin-css-order": "*",
				"prettier-plugin-import-sort": "*",
				"prettier-plugin-jsdoc": "*",
				"prettier-plugin-marko": "*",
				"prettier-plugin-multiline-arrays": "*",
				"prettier-plugin-organize-attributes": "*",
				"prettier-plugin-organize-imports": "*",
				"prettier-plugin-sort-imports": "*",
				"prettier-plugin-style-order": "*",
				"prettier-plugin-svelte": "*"
			},
			"peerDependenciesMeta": {
				"@ianvs/prettier-plugin-sort-imports": {
					"optional": true
				},
				"@prettier/plugin-hermes": {
					"optional": true
				},
				"@prettier/plugin-oxc": {
					"optional": true
				},
				"@prettier/plugin-pug": {
					"optional": true
				},
				"@shopify/prettier-plugin-liquid": {
					"optional": true
				},
				"@trivago/prettier-plugin-sort-imports": {
					"optional": true
				},
				"@zackad/prettier-plugin-twig": {
					"optional": true
				},
				"prettier-plugin-astro": {
					"optional": true
				},
				"prettier-plugin-css-order": {
					"optional": true
				},
				"prettier-plugin-import-sort": {
					"optional": true
				},
				"prettier-plugin-jsdoc": {
					"optional": true
				},
				"prettier-plugin-marko": {
					"optional": true
				},
				"prettier-plugin-multiline-arrays": {
					"optional": true
				},
				"prettier-plugin-organize-attributes": {
					"optional": true
				},
				"prettier-plugin-organize-imports": {
					"optional": true
				},
				"prettier-plugin-sort-imports": {
					"optional": true
				},
				"prettier-plugin-style-order": {
					"optional": true
				},
				"prettier-plugin-svelte": {
					"optional": true
				}
			}
		},
		"node_modules/pretty-format": {
			"version": "27.5.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"ansi-regex": "^5.0.1",
				"ansi-styles": "^5.0.0",
				"react-is": "^17.0.1"
			},
			"engines": {
				"node": "^10.13.0 || ^12.13.0 || ^14.15.0 || >=15.0.0"
			}
		},
		"node_modules/react-is": {
			"version": "17.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/readdirp": {
			"version": "4.1.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">= 14.18.0"
			},
			"funding": {
				"type": "individual",
				"url": "https://paulmillr.com/funding/"
			}
		},
		"node_modules/regexparam": {
			"version": "3.0.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/resolve-pkg-maps": {
			"version": "1.0.0",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/privatenumber/resolve-pkg-maps?sponsor=1"
			}
		},
		"node_modules/rollup": {
			"version": "4.52.5",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/estree": "1.0.8"
			},
			"bin": {
				"rollup": "dist/bin/rollup"
			},
			"engines": {
				"node": ">=18.0.0",
				"npm": ">=8.0.0"
			},
			"optionalDependencies": {
				"@rollup/rollup-android-arm-eabi": "4.52.5",
				"@rollup/rollup-android-arm64": "4.52.5",
				"@rollup/rollup-darwin-arm64": "4.52.5",
				"@rollup/rollup-darwin-x64": "4.52.5",
				"@rollup/rollup-freebsd-arm64": "4.52.5",
				"@rollup/rollup-freebsd-x64": "4.52.5",
				"@rollup/rollup-linux-arm-gnueabihf": "4.52.5",
				"@rollup/rollup-linux-arm-musleabihf": "4.52.5",
				"@rollup/rollup-linux-arm64-gnu": "4.52.5",
				"@rollup/rollup-linux-arm64-musl": "4.52.5",
				"@rollup/rollup-linux-loong64-gnu": "4.52.5",
				"@rollup/rollup-linux-ppc64-gnu": "4.52.5",
				"@rollup/rollup-linux-riscv64-gnu": "4.52.5",
				"@rollup/rollup-linux-riscv64-musl": "4.52.5",
				"@rollup/rollup-linux-s390x-gnu": "4.52.5",
				"@rollup/rollup-linux-x64-gnu": "4.52.5",
				"@rollup/rollup-linux-x64-musl": "4.52.5",
				"@rollup/rollup-openharmony-arm64": "4.52.5",
				"@rollup/rollup-win32-arm64-msvc": "4.52.5",
				"@rollup/rollup-win32-ia32-msvc": "4.52.5",
				"@rollup/rollup-win32-x64-gnu": "4.52.5",
				"@rollup/rollup-win32-x64-msvc": "4.52.5",
				"fsevents": "~2.3.2"
			}
		},
		"node_modules/rollup/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/sade": {
			"version": "1.8.1",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mri": "^1.1.0"
			},
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/semver": {
			"version": "7.7.3",
			"dev": true,
			"license": "ISC",
			"bin": {
				"semver": "bin/semver.js"
			},
			"engines": {
				"node": ">=10"
			}
		},
		"node_modules/set-cookie-parser": {
			"version": "2.7.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/sharp": {
			"version": "0.33.5",
			"dev": true,
			"hasInstallScript": true,
			"license": "Apache-2.0",
			"dependencies": {
				"color": "^4.2.3",
				"detect-libc": "^2.0.3",
				"semver": "^7.6.3"
			},
			"engines": {
				"node": "^18.17.0 || ^20.3.0 || >=21.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/libvips"
			},
			"optionalDependencies": {
				"@img/sharp-darwin-arm64": "0.33.5",
				"@img/sharp-darwin-x64": "0.33.5",
				"@img/sharp-libvips-darwin-arm64": "1.0.4",
				"@img/sharp-libvips-darwin-x64": "1.0.4",
				"@img/sharp-libvips-linux-arm": "1.0.5",
				"@img/sharp-libvips-linux-arm64": "1.0.4",
				"@img/sharp-libvips-linux-s390x": "1.0.4",
				"@img/sharp-libvips-linux-x64": "1.0.4",
				"@img/sharp-libvips-linuxmusl-arm64": "1.0.4",
				"@img/sharp-libvips-linuxmusl-x64": "1.0.4",
				"@img/sharp-linux-arm": "0.33.5",
				"@img/sharp-linux-arm64": "0.33.5",
				"@img/sharp-linux-s390x": "0.33.5",
				"@img/sharp-linux-x64": "0.33.5",
				"@img/sharp-linuxmusl-arm64": "0.33.5",
				"@img/sharp-linuxmusl-x64": "0.33.5",
				"@img/sharp-wasm32": "0.33.5",
				"@img/sharp-win32-ia32": "0.33.5",
				"@img/sharp-win32-x64": "0.33.5"
			}
		},
		"node_modules/siginfo": {
			"version": "2.0.0",
			"dev": true,
			"license": "ISC"
		},
		"node_modules/simple-swizzle": {
			"version": "0.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"is-arrayish": "^0.3.1"
			}
		},
		"node_modules/sirv": {
			"version": "3.0.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@polka/url": "^1.0.0-next.24",
				"mrmime": "^2.0.0",
				"totalist": "^3.0.0"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/source-map": {
			"version": "0.6.1",
			"dev": true,
			"license": "BSD-3-Clause",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/source-map-js": {
			"version": "1.2.1",
			"dev": true,
			"license": "BSD-3-Clause",
			"engines": {
				"node": ">=0.10.0"
			}
		},
		"node_modules/source-map-support": {
			"version": "0.5.21",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"buffer-from": "^1.0.0",
				"source-map": "^0.6.0"
			}
		},
		"node_modules/stackback": {
			"version": "0.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/std-env": {
			"version": "3.10.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/stoppable": {
			"version": "1.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=4",
				"npm": ">=6"
			}
		},
		"node_modules/strip-literal": {
			"version": "3.1.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"js-tokens": "^9.0.1"
			},
			"funding": {
				"url": "https://github.com/sponsors/antfu"
			}
		},
		"node_modules/strip-literal/node_modules/js-tokens": {
			"version": "9.0.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/supports-color": {
			"version": "10.2.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			},
			"funding": {
				"url": "https://github.com/chalk/supports-color?sponsor=1"
			}
		},
		"node_modules/svelte": {
			"version": "5.41.2",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/remapping": "^2.3.4",
				"@jridgewell/sourcemap-codec": "^1.5.0",
				"@sveltejs/acorn-typescript": "^1.0.5",
				"@types/estree": "^1.0.5",
				"acorn": "^8.12.1",
				"aria-query": "^5.3.1",
				"axobject-query": "^4.1.0",
				"clsx": "^2.1.1",
				"esm-env": "^1.2.1",
				"esrap": "^2.1.0",
				"is-reference": "^3.0.3",
				"locate-character": "^3.0.0",
				"magic-string": "^0.30.11",
				"zimmerframe": "^1.1.2"
			},
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/svelte-check": {
			"version": "4.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@jridgewell/trace-mapping": "^0.3.25",
				"chokidar": "^4.0.1",
				"fdir": "^6.2.0",
				"picocolors": "^1.0.0",
				"sade": "^1.7.4"
			},
			"bin": {
				"svelte-check": "bin/svelte-check"
			},
			"engines": {
				"node": ">= 18.0.0"
			},
			"peerDependencies": {
				"svelte": "^4.0.0 || ^5.0.0-next.0",
				"typescript": ">=5.0.0"
			}
		},
		"node_modules/tailwindcss": {
			"version": "4.1.15",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tapable": {
			"version": "2.3.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			},
			"funding": {
				"type": "opencollective",
				"url": "https://opencollective.com/webpack"
			}
		},
		"node_modules/tinybench": {
			"version": "2.9.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tinyexec": {
			"version": "0.3.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/tinyglobby": {
			"version": "0.2.15",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"fdir": "^6.5.0",
				"picomatch": "^4.0.3"
			},
			"engines": {
				"node": ">=12.0.0"
			},
			"funding": {
				"url": "https://github.com/sponsors/SuperchupuDev"
			}
		},
		"node_modules/tinypool": {
			"version": "1.1.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": "^18.0.0 || >=20.0.0"
			}
		},
		"node_modules/tinyrainbow": {
			"version": "2.0.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.0.0"
			}
		},
		"node_modules/tinyspy": {
			"version": "4.0.4",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=14.0.0"
			}
		},
		"node_modules/totalist": {
			"version": "3.0.1",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=6"
			}
		},
		"node_modules/typescript": {
			"version": "5.9.3",
			"dev": true,
			"license": "Apache-2.0",
			"bin": {
				"tsc": "bin/tsc",
				"tsserver": "bin/tsserver"
			},
			"engines": {
				"node": ">=14.17"
			}
		},
		"node_modules/ufo": {
			"version": "1.6.1",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/undici": {
			"version": "7.14.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=20.18.1"
			}
		},
		"node_modules/undici-types": {
			"version": "6.21.0",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/unenv": {
			"version": "2.0.0-rc.21",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"defu": "^6.1.4",
				"exsolve": "^1.0.7",
				"ohash": "^2.0.11",
				"pathe": "^2.0.3",
				"ufo": "^1.6.1"
			}
		},
		"node_modules/util-deprecate": {
			"version": "1.0.2",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/vite": {
			"version": "7.1.11",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"esbuild": "^0.25.0",
				"fdir": "^6.5.0",
				"picomatch": "^4.0.3",
				"postcss": "^8.5.6",
				"rollup": "^4.43.0",
				"tinyglobby": "^0.2.15"
			},
			"bin": {
				"vite": "bin/vite.js"
			},
			"engines": {
				"node": "^20.19.0 || >=22.12.0"
			},
			"funding": {
				"url": "https://github.com/vitejs/vite?sponsor=1"
			},
			"optionalDependencies": {
				"fsevents": "~2.3.3"
			},
			"peerDependencies": {
				"@types/node": "^20.19.0 || >=22.12.0",
				"jiti": ">=1.21.0",
				"less": "^4.0.0",
				"lightningcss": "^1.21.0",
				"sass": "^1.70.0",
				"sass-embedded": "^1.70.0",
				"stylus": ">=0.54.8",
				"sugarss": "^5.0.0",
				"terser": "^5.16.0",
				"tsx": "^4.8.1",
				"yaml": "^2.4.2"
			},
			"peerDependenciesMeta": {
				"@types/node": {
					"optional": true
				},
				"jiti": {
					"optional": true
				},
				"less": {
					"optional": true
				},
				"lightningcss": {
					"optional": true
				},
				"sass": {
					"optional": true
				},
				"sass-embedded": {
					"optional": true
				},
				"stylus": {
					"optional": true
				},
				"sugarss": {
					"optional": true
				},
				"terser": {
					"optional": true
				},
				"tsx": {
					"optional": true
				},
				"yaml": {
					"optional": true
				}
			}
		},
		"node_modules/vite-node": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"cac": "^6.7.14",
				"debug": "^4.4.1",
				"es-module-lexer": "^1.7.0",
				"pathe": "^2.0.3",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0"
			},
			"bin": {
				"vite-node": "vite-node.mjs"
			},
			"engines": {
				"node": "^18.0.0 || ^20.0.0 || >=22.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			}
		},
		"node_modules/vite/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/vitefu": {
			"version": "1.1.1",
			"dev": true,
			"license": "MIT",
			"workspaces": [
				"tests/deps/*",
				"tests/projects/*",
				"tests/projects/workspace/packages/*"
			],
			"peerDependencies": {
				"vite": "^3.0.0 || ^4.0.0 || ^5.0.0 || ^6.0.0 || ^7.0.0-beta.0"
			},
			"peerDependenciesMeta": {
				"vite": {
					"optional": true
				}
			}
		},
		"node_modules/vitest": {
			"version": "3.2.4",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@types/chai": "^5.2.2",
				"@vitest/expect": "3.2.4",
				"@vitest/mocker": "3.2.4",
				"@vitest/pretty-format": "^3.2.4",
				"@vitest/runner": "3.2.4",
				"@vitest/snapshot": "3.2.4",
				"@vitest/spy": "3.2.4",
				"@vitest/utils": "3.2.4",
				"chai": "^5.2.0",
				"debug": "^4.4.1",
				"expect-type": "^1.2.1",
				"magic-string": "^0.30.17",
				"pathe": "^2.0.3",
				"picomatch": "^4.0.2",
				"std-env": "^3.9.0",
				"tinybench": "^2.9.0",
				"tinyexec": "^0.3.2",
				"tinyglobby": "^0.2.14",
				"tinypool": "^1.1.1",
				"tinyrainbow": "^2.0.0",
				"vite": "^5.0.0 || ^6.0.0 || ^7.0.0-0",
				"vite-node": "3.2.4",
				"why-is-node-running": "^2.3.0"
			},
			"bin": {
				"vitest": "vitest.mjs"
			},
			"engines": {
				"node": "^18.0.0 || ^20.0.0 || >=22.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"@edge-runtime/vm": "*",
				"@types/debug": "^4.1.12",
				"@types/node": "^18.0.0 || ^20.0.0 || >=22.0.0",
				"@vitest/browser": "3.2.4",
				"@vitest/ui": "3.2.4",
				"happy-dom": "*",
				"jsdom": "*"
			},
			"peerDependenciesMeta": {
				"@edge-runtime/vm": {
					"optional": true
				},
				"@types/debug": {
					"optional": true
				},
				"@types/node": {
					"optional": true
				},
				"@vitest/browser": {
					"optional": true
				},
				"@vitest/ui": {
					"optional": true
				},
				"happy-dom": {
					"optional": true
				},
				"jsdom": {
					"optional": true
				}
			}
		},
		"node_modules/vitest-browser-svelte": {
			"version": "1.1.0",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": "^18.0.0 || >=20.0.0"
			},
			"funding": {
				"url": "https://opencollective.com/vitest"
			},
			"peerDependencies": {
				"@vitest/browser": "^2.1.0 || ^3.0.0 || ^4.0.0-0",
				"svelte": "^3 || ^4 || ^5 || ^5.0.0-next.0",
				"vitest": "^2.1.0 || ^3.0.0 || ^4.0.0-0"
			}
		},
		"node_modules/why-is-node-running": {
			"version": "2.3.0",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"siginfo": "^2.0.0",
				"stackback": "0.0.2"
			},
			"bin": {
				"why-is-node-running": "cli.js"
			},
			"engines": {
				"node": ">=8"
			}
		},
		"node_modules/workerd": {
			"version": "1.20251011.0",
			"dev": true,
			"hasInstallScript": true,
			"license": "Apache-2.0",
			"bin": {
				"workerd": "bin/workerd"
			},
			"engines": {
				"node": ">=16"
			},
			"optionalDependencies": {
				"@cloudflare/workerd-darwin-64": "1.20251011.0",
				"@cloudflare/workerd-darwin-arm64": "1.20251011.0",
				"@cloudflare/workerd-linux-64": "1.20251011.0",
				"@cloudflare/workerd-linux-arm64": "1.20251011.0",
				"@cloudflare/workerd-windows-64": "1.20251011.0"
			}
		},
		"node_modules/worktop": {
			"version": "0.8.0-next.18",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"mrmime": "^2.0.0",
				"regexparam": "^3.0.0"
			},
			"engines": {
				"node": ">=12"
			}
		},
		"node_modules/wrangler": {
			"version": "4.44.0",
			"resolved": "https://registry.npmjs.org/wrangler/-/wrangler-4.44.0.tgz",
			"integrity": "sha512-BLOUigckcWZ0r4rm7b5PuaTpb9KP9as0XeCRSJ8kqcNgXcKoUD3Ij8FlPvN25KybLnFnetaO0ZdfRYUPWle4qw==",
			"dev": true,
			"license": "MIT OR Apache-2.0",
			"dependencies": {
				"@cloudflare/kv-asset-handler": "0.4.0",
				"@cloudflare/unenv-preset": "2.7.8",
				"blake3-wasm": "2.1.5",
				"esbuild": "0.25.4",
				"miniflare": "4.20251011.0",
				"path-to-regexp": "6.3.0",
				"unenv": "2.0.0-rc.21",
				"workerd": "1.20251011.0"
			},
			"bin": {
				"wrangler": "bin/wrangler.js",
				"wrangler2": "bin/wrangler.js"
			},
			"engines": {
				"node": ">=18.0.0"
			},
			"optionalDependencies": {
				"fsevents": "~2.3.2"
			},
			"peerDependencies": {
				"@cloudflare/workers-types": "^4.20251011.0"
			},
			"peerDependenciesMeta": {
				"@cloudflare/workers-types": {
					"optional": true
				}
			}
		},
		"node_modules/wrangler/node_modules/esbuild": {
			"version": "0.25.4",
			"dev": true,
			"hasInstallScript": true,
			"license": "MIT",
			"bin": {
				"esbuild": "bin/esbuild"
			},
			"engines": {
				"node": ">=18"
			},
			"optionalDependencies": {
				"@esbuild/aix-ppc64": "0.25.4",
				"@esbuild/android-arm": "0.25.4",
				"@esbuild/android-arm64": "0.25.4",
				"@esbuild/android-x64": "0.25.4",
				"@esbuild/darwin-arm64": "0.25.4",
				"@esbuild/darwin-x64": "0.25.4",
				"@esbuild/freebsd-arm64": "0.25.4",
				"@esbuild/freebsd-x64": "0.25.4",
				"@esbuild/linux-arm": "0.25.4",
				"@esbuild/linux-arm64": "0.25.4",
				"@esbuild/linux-ia32": "0.25.4",
				"@esbuild/linux-loong64": "0.25.4",
				"@esbuild/linux-mips64el": "0.25.4",
				"@esbuild/linux-ppc64": "0.25.4",
				"@esbuild/linux-riscv64": "0.25.4",
				"@esbuild/linux-s390x": "0.25.4",
				"@esbuild/linux-x64": "0.25.4",
				"@esbuild/netbsd-arm64": "0.25.4",
				"@esbuild/netbsd-x64": "0.25.4",
				"@esbuild/openbsd-arm64": "0.25.4",
				"@esbuild/openbsd-x64": "0.25.4",
				"@esbuild/sunos-x64": "0.25.4",
				"@esbuild/win32-arm64": "0.25.4",
				"@esbuild/win32-ia32": "0.25.4",
				"@esbuild/win32-x64": "0.25.4"
			}
		},
		"node_modules/wrangler/node_modules/esbuild/node_modules/@esbuild/darwin-arm64": {
			"version": "0.25.4",
			"cpu": [
				"arm64"
			],
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/wrangler/node_modules/fsevents": {
			"version": "2.3.3",
			"dev": true,
			"license": "MIT",
			"optional": true,
			"os": [
				"darwin"
			],
			"engines": {
				"node": "^8.16.0 || ^10.6.0 || >=11.0.0"
			}
		},
		"node_modules/ws": {
			"version": "8.18.3",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=10.0.0"
			},
			"peerDependencies": {
				"bufferutil": "^4.0.1",
				"utf-8-validate": ">=5.0.2"
			},
			"peerDependenciesMeta": {
				"bufferutil": {
					"optional": true
				},
				"utf-8-validate": {
					"optional": true
				}
			}
		},
		"node_modules/youch": {
			"version": "4.1.0-beta.10",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/colors": "^4.1.5",
				"@poppinss/dumper": "^0.6.4",
				"@speed-highlight/core": "^1.2.7",
				"cookie": "^1.0.2",
				"youch-core": "^0.3.3"
			}
		},
		"node_modules/youch-core": {
			"version": "0.3.3",
			"dev": true,
			"license": "MIT",
			"dependencies": {
				"@poppinss/exception": "^1.2.2",
				"error-stack-parser-es": "^1.0.5"
			}
		},
		"node_modules/youch/node_modules/cookie": {
			"version": "1.0.2",
			"dev": true,
			"license": "MIT",
			"engines": {
				"node": ">=18"
			}
		},
		"node_modules/zimmerframe": {
			"version": "1.1.4",
			"dev": true,
			"license": "MIT"
		},
		"node_modules/zod": {
			"version": "3.22.3",
			"dev": true,
			"license": "MIT",
			"funding": {
				"url": "https://github.com/sponsors/colinhacks"
			}
		}
	}
}
</file>

<file path="hyperdrive-tutorial/.vscode/settings.json">
{
	"files.associations": {
		"wrangler.json": "jsonc"
	}
}
</file>

<file path="hyperdrive-tutorial/src/index.ts">
import { Client } from "pg";

const CORS_HEADERS = {
	"Access-Control-Allow-Origin": "*",
	"Access-Control-Allow-Headers": "content-type",
	"Access-Control-Allow-Methods": "GET,POST,OPTIONS"
} as const;

const DEFAULT_AVATAR = "https://i.pravatar.cc/150?img=15";
const DEFAULT_THUMBNAIL = "https://placehold.co/400x225?text=Video";

interface HyperdriveBinding {
	connectionString: string;
}

export interface Env {
	HYPERDRIVE: HyperdriveBinding;
}

type VideoRow = {
	id: string;
	title: string;
	description: string;
	user_id: number;
	video_url: string | null;
	thumbnail_url: string | null;
	duration: number | null;
	uploaded_at: string | Date | null;
	created_at: string | Date | null;
	views: number | null;
	likes: number | null;
	latitude: string | number | null;
	longitude: string | number | null;
	transcript: string | null;
	user_name: string;
	user_slug: string;
	user_avatar: string | null;
};

type VideoTagRow = {
	video_id: string;
	tag: string | null;
};

type VideoListResponse = Video[];

type UserRow = {
	id: number;
	slug: string;
	name: string;
	avatar: string | null;
	bio: string | null;
	created_at: string | Date | null;
};

type FollowRow = {
	follower_id: number;
	following_id: number;
};

type UserVideoRow = {
	id: string;
	title: string;
	thumbnail_url: string | null;
	duration: number | null;
	user_id: number;
};

export interface Location {
	setting?: string;
	environment?: string;
	startTime?: number;
	endTime?: number;
	isExterior?: number;
	isDay?: number;
	longitude?: number;
	latitude?: number;
	mapLat?: number;
	mapLon?: number;
	isGuess?: boolean;
	id?: number;
	name?: string;
	coordinates?: [number, number];
}

export interface Video {
	id: string;
	title: string;
	description: string;
	author: string;
	authorId: string;
	duration: number;
	uploadedAt?: string;
	uploadDate?: string;
	url?: string;
	videoUrl?: string;
	thumbnailUrl?: string;
	locations: Location[];
	keywords: string[];
	transcript?: string;
	views: number;
	likes: number;
	timestamp?: string;
}

export interface UserVideoSummary {
	id: string;
	title: string;
	thumbnail: string;
	duration: number;
}

export interface UserStats {
	videos: number;
	followers: number;
	following: number;
}

export interface User {
	id: string;
	name: string;
	avatar: string;
	bio: string;
	stats: UserStats;
	videos: UserVideoSummary[];
	email?: string;
	subscribers: number;
	joinedAt?: string;
	verified?: boolean;
	recentVideos: UserVideoSummary[];
}

interface CreateVideoPayload {
	id?: string;
	title: string;
	description: string;
	userId: number | string;
	videoUrl?: string;
	thumbnailUrl?: string;
	duration?: number;
	uploadedAt?: string;
	latitude?: number;
	longitude?: number;
	transcript?: string | null;
	views?: number;
	likes?: number;
	tags?: string[];
}

function toIsoString(value: unknown): string | undefined {
	if (!value) return undefined;
	if (value instanceof Date) {
		return value.toISOString();
	}
	if (typeof value === "string" && value.length > 0) {
		const date = new Date(value);
		if (!Number.isNaN(date.getTime())) {
			return date.toISOString();
		}
	}
	return undefined;
}

function toNumber(value: unknown): number | null {
	if (value === null || value === undefined) return null;
	if (typeof value === "number") {
		return Number.isFinite(value) ? value : null;
	}
	if (typeof value === "string" && value.trim().length) {
		const parsed = Number(value);
		return Number.isFinite(parsed) ? parsed : null;
	}
	return null;
}

function createVideoFromRow(row: VideoRow, tags: string[]): Video {
	const latitude = toNumber(row.latitude);
	const longitude = toNumber(row.longitude);
	const uploadedAt = toIsoString(row.uploaded_at);
	const createdAt = toIsoString(row.created_at);
	const locations =
		latitude !== null && longitude !== null
			? [
					{
						name: row.title,
						coordinates: [longitude, latitude] as [number, number],
						latitude,
						longitude,
						mapLat: latitude,
						mapLon: longitude,
						isExterior: 1,
						isDay: 1,
						isGuess: false,
						startTime: 0,
						endTime: 0
					}
				]
			: [];

	return {
		id: row.id,
		title: row.title,
		description: row.description,
		author: row.user_name,
		authorId: row.user_slug,
		duration: toNumber(row.duration) ?? 0,
		uploadedAt,
		uploadDate: uploadedAt,
		url: row.video_url ?? undefined,
		videoUrl: row.video_url ?? undefined,
		thumbnailUrl: row.thumbnail_url ?? undefined,
		locations,
		keywords: tags,
		transcript: row.transcript ?? "Transcript not available.",
		views: toNumber(row.views) ?? 0,
		likes: toNumber(row.likes) ?? 0,
		timestamp: uploadedAt ?? createdAt
	};
}

function createUserSummaryRows(rows: UserVideoRow[]): Map<number, UserVideoSummary[]> {
	const summaries = new Map<number, UserVideoSummary[]>();
	for (const row of rows) {
		const list = summaries.get(row.user_id) ?? [];
		list.push({
			id: row.id,
			title: row.title,
			thumbnail: row.thumbnail_url ?? DEFAULT_THUMBNAIL,
			duration: toNumber(row.duration) ?? 0
		});
		summaries.set(row.user_id, list);
	}
	return summaries;
}

function createFollowMaps(rows: FollowRow[]) {
	const followers = new Map<number, Set<number>>();
	const following = new Map<number, Set<number>>();

	for (const row of rows) {
		const followersSet = followers.get(row.following_id) ?? new Set<number>();
		followersSet.add(row.follower_id);
		followers.set(row.following_id, followersSet);

		const followingSet = following.get(row.follower_id) ?? new Set<number>();
		followingSet.add(row.following_id);
		following.set(row.follower_id, followingSet);
	}

	return { followers, following };
}

function mapUserRow(
	row: UserRow,
	options: { videos: UserVideoSummary[]; followers: number; following: number }
): User {
	const joinedAt = toIsoString(row.created_at);
	const { videos, followers, following } = options;

	return {
		id: row.slug,
		name: row.name,
		avatar: row.avatar ?? DEFAULT_AVATAR,
		bio: row.bio ?? "",
		stats: {
			videos: videos.length,
			followers,
			following
		},
		videos,
		recentVideos: videos.slice(0, 3),
		subscribers: followers,
		joinedAt
	};
}

async function getPgClient(env: Env) {
	const client = new Client({ connectionString: env.HYPERDRIVE.connectionString });
	await client.connect();
	return client;
}

async function listVideos(client: Client): Promise<VideoListResponse> {
	const { rows } = await client.query<VideoRow>(
		`SELECT
			v.id,
			v.title,
			v.description,
			v.user_id,
			v.video_url,
			v.thumbnail_url,
			v.duration,
			v.uploaded_at,
			v.created_at,
			v.views,
			v.likes,
			v.latitude,
			v.longitude,
			v.transcript,
			u.name AS user_name,
			u.slug AS user_slug,
			u.avatar AS user_avatar
		FROM videos v
		INNER JOIN users u ON u.id = v.user_id
		ORDER BY v.created_at DESC`
	);

	if (rows.length === 0) {
		return [];
	}

	const ids = rows.map((row) => row.id);
	const tagRows = await client.query<VideoTagRow>(
		`SELECT vt.video_id, t.name AS tag
		 FROM video_tags vt
		 INNER JOIN tags t ON t.id = vt.tag_id
		 WHERE vt.video_id = ANY($1::text[])`,
		[ids]
	);

	const tagsByVideo = new Map<string, string[]>();
	for (const tag of tagRows.rows) {
		const list = tagsByVideo.get(tag.video_id) ?? [];
		if (typeof tag.tag === "string" && tag.tag.length) {
			list.push(tag.tag);
			tagsByVideo.set(tag.video_id, list);
		}
	}

	return rows.map((row) => createVideoFromRow(row, tagsByVideo.get(row.id) ?? []));
}

async function getVideo(client: Client, id: string): Promise<Video | null> {
	const { rows } = await client.query<VideoRow>(
		`SELECT
			v.id,
			v.title,
			v.description,
			v.user_id,
			v.video_url,
			v.thumbnail_url,
			v.duration,
			v.uploaded_at,
			v.created_at,
			v.views,
			v.likes,
			v.latitude,
			v.longitude,
			v.transcript,
			u.name AS user_name,
			u.slug AS user_slug,
			u.avatar AS user_avatar
		FROM videos v
		INNER JOIN users u ON u.id = v.user_id
		WHERE v.id = $1
		LIMIT 1`,
		[id]
	);

	if (!rows.length) return null;

	const tagRows = await client.query<VideoTagRow>(
		`SELECT vt.video_id, t.name AS tag
		 FROM video_tags vt
		 INNER JOIN tags t ON t.id = vt.tag_id
		 WHERE vt.video_id = $1`,
		[id]
	);

	const tags = tagRows.rows
		.map((row) => (typeof row.tag === "string" ? row.tag : null))
		.filter((tag): tag is string => Boolean(tag));

	return createVideoFromRow(rows[0]!, tags);
}

async function listUsers(client: Client): Promise<User[]> {
	const [userResult, videoResult, followResult] = await Promise.all([
		client.query<UserRow>(`SELECT id, slug, name, avatar, bio, created_at FROM users`),
		client.query<UserVideoRow>(
			`SELECT id, title, thumbnail_url, duration, user_id
			 FROM videos
			 ORDER BY created_at DESC`
		),
		client.query<FollowRow>(`SELECT follower_id, following_id FROM user_follows`)
	]);

	const videosByUser = createUserSummaryRows(videoResult.rows);
	const { followers, following } = createFollowMaps(followResult.rows);

	return userResult.rows.map((row) => {
		const videoSummaries = videosByUser.get(row.id) ?? [];
		const followerCount = followers.get(row.id)?.size ?? 0;
		const followingCount = following.get(row.id)?.size ?? 0;

		return mapUserRow(row, {
			videos: videoSummaries,
			followers: followerCount,
			following: followingCount
		});
	});
}

async function getUserBySlug(client: Client, slug: string): Promise<User | null> {
	const { rows } = await client.query<UserRow>(
		`SELECT id, slug, name, avatar, bio, created_at
		 FROM users
		 WHERE slug = $1
		 LIMIT 1`,
		[slug]
	);

	if (!rows.length) {
		return null;
	}

	const userId = rows[0]!.id;

	const [videoResult, followerResult, followingResult] = await Promise.all([
		client.query<UserVideoRow>(
			`SELECT id, title, thumbnail_url, duration, user_id
			 FROM videos
			 WHERE user_id = $1
			 ORDER BY created_at DESC`,
			[userId]
		),
		client.query<FollowRow>(
			`SELECT follower_id, following_id
			 FROM user_follows
			 WHERE following_id = $1`,
			[userId]
		),
		client.query<FollowRow>(
			`SELECT follower_id, following_id
			 FROM user_follows
			 WHERE follower_id = $1`,
			[userId]
		)
	]);

	const videos = createUserSummaryRows(videoResult.rows).get(userId) ?? [];
	const followerCount = new Set(followerResult.rows.map((row) => row.follower_id)).size;
	const followingCount = new Set(followingResult.rows.map((row) => row.following_id)).size;

	return mapUserRow(rows[0]!, {
		videos,
		followers: followerCount,
		following: followingCount
	});
}

async function ensureTagIds(client: Client, tags: string[]): Promise<number[]> {
	const ids: number[] = [];

	for (const tag of tags) {
		const normalized = tag.trim();
		if (!normalized.length) continue;

		const result = await client.query<{ id: number }>(
			`INSERT INTO tags (name)
			 VALUES ($1)
			 ON CONFLICT (name) DO UPDATE SET name = EXCLUDED.name
			 RETURNING id`,
			[normalized]
		);

		if (result.rows[0]?.id) {
			ids.push(result.rows[0].id);
		}
	}

	return ids;
}

async function createVideo(client: Client, payload: CreateVideoPayload): Promise<Video> {
	const userId = Number(payload.userId);
	if (!Number.isInteger(userId)) {
		throw new Error("Invalid userId. Expecting a numeric identifier.");
	}

	const id =
		(typeof payload.id === "string" && payload.id.length > 0
			? payload.id
			: crypto.randomUUID().replace(/-/g, "").slice(0, 12));

	const uploadedAt = payload.uploadedAt ? new Date(payload.uploadedAt) : new Date();
	if (Number.isNaN(uploadedAt.getTime())) {
		throw new Error("uploadedAt is not a valid date.");
	}

	const latitude = payload.latitude ?? null;
	const longitude = payload.longitude ?? null;
	const duration = payload.duration ?? 0;
	const transcript = payload.transcript ?? null;
	const views = payload.views ?? 0;
	const likes = payload.likes ?? 0;

	await client.query("BEGIN");
	try {
		await client.query(
			`INSERT INTO videos (
				id,
				title,
				description,
				user_id,
				video_url,
				thumbnail_url,
				duration,
				uploaded_at,
				latitude,
				longitude,
				transcript,
				views,
				likes
			) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
			ON CONFLICT (id) DO UPDATE SET
				title = EXCLUDED.title,
				description = EXCLUDED.description,
				user_id = EXCLUDED.user_id,
				video_url = EXCLUDED.video_url,
				thumbnail_url = EXCLUDED.thumbnail_url,
				duration = EXCLUDED.duration,
				uploaded_at = EXCLUDED.uploaded_at,
				latitude = EXCLUDED.latitude,
				longitude = EXCLUDED.longitude,
				transcript = EXCLUDED.transcript,
				views = EXCLUDED.views,
				likes = EXCLUDED.likes`,
			[
				id,
				payload.title,
				payload.description,
				userId,
				payload.videoUrl ?? null,
				payload.thumbnailUrl ?? null,
				duration,
				uploadedAt.toISOString(),
				latitude,
				longitude,
				transcript,
				views,
				likes
			]
		);

		const tags = payload.tags ?? [];
		if (tags.length) {
			const tagIds = await ensureTagIds(client, tags);
			for (const tagId of tagIds) {
				await client.query(
					`INSERT INTO video_tags (video_id, tag_id)
					 VALUES ($1, $2)
					 ON CONFLICT DO NOTHING`,
					[id, tagId]
				);
			}
		}

		await client.query("COMMIT");
	} catch (error) {
		await client.query("ROLLBACK");
		throw error;
	}

	const video = await getVideo(client, id);
	if (!video) {
		throw new Error("Video insert succeeded but the record could not be fetched.");
	}
	return video;
}

function json<T>(data: T, init?: ResponseInit): Response {
	return Response.json(data, {
		...init,
		headers: {
			"content-type": "application/json",
			...CORS_HEADERS,
			...(init?.headers ?? {})
		}
	});
}

function errorResponse(message: string, status = 500): Response {
	return json({ error: message }, { status });
}

export default {
	async fetch(request, env): Promise<Response> {
		const url = new URL(request.url);
		const pathname = url.pathname.replace(/\/+$/, "") || "/";

		if (request.method === "OPTIONS") {
			return new Response(null, { status: 204, headers: CORS_HEADERS });
		}

		if (request.method === "GET" && pathname === "/health") {
			try {
				const client = await getPgClient(env);
				const result = await client.query<{ now: string }>("SELECT NOW()");
				await client.end();
				return json({ ok: true, time: result.rows[0]?.now ?? null });
			} catch (error) {
				console.error("Health check failed", error);
				return errorResponse("Database unreachable", 503);
			}
		}

		if (request.method === "GET" && pathname === "/") {
			return json({
				service: "rushes-hyperdrive",
				endpoints: ["/videos", "/videos/:id", "/users", "/users/:slug"],
				ok: true
			});
		}

		let client: Client | null = null;
		try {
			client = await getPgClient(env);

			if (request.method === "GET" && pathname === "/videos") {
				const videos = await listVideos(client);
				return json({ videos });
			}

			if (request.method === "GET" && pathname.startsWith("/videos/")) {
				const id = pathname.split("/")[2];
				if (!id) {
					return errorResponse("Video id is required.", 400);
				}
				const video = await getVideo(client, id);
				if (!video) {
					return errorResponse("Video not found.", 404);
				}
				return json({ video });
			}

			if (request.method === "GET" && pathname === "/users") {
				const users = await listUsers(client);
				return json({ users });
			}

			if (request.method === "GET" && pathname.startsWith("/users/")) {
				const slug = pathname.split("/")[2];
				if (!slug) {
					return errorResponse("User slug is required.", 400);
				}
				const user = await getUserBySlug(client, slug);
				if (!user) {
					return errorResponse("User not found.", 404);
				}
				return json({ user });
			}

			if (request.method === "POST" && pathname === "/videos") {
				const contentType = request.headers.get("content-type") ?? "";
				let payload: CreateVideoPayload;

				if (contentType.includes("application/json")) {
					payload = (await request.json()) as CreateVideoPayload;
				} else {
					return errorResponse("Unsupported content type. Use application/json.", 415);
				}

				if (!payload.title || !payload.description || payload.userId === undefined) {
					return errorResponse(
						"Missing required fields: title, description and userId are required.",
						400
					);
				}

				const video = await createVideo(client, payload);
				return json({ video }, { status: 201 });
			}

			return errorResponse("Not found.", 404);
		} catch (error) {
			console.error("Worker error:", error);
			const message = error instanceof Error ? error.message : "Internal error";
			return errorResponse(message, 500);
		} finally {
			if (client) {
				try {
					await client.end();
				} catch (endError) {
					console.error("Failed to close database connection:", endError);
				}
			}
		}
	}
} satisfies ExportedHandler<Env>;
</file>

<file path="hyperdrive-tutorial/test/env.d.ts">
declare module 'cloudflare:test' {
	interface ProvidedEnv extends Env {}
}
</file>

<file path="hyperdrive-tutorial/test/index.spec.ts">
import { env, createExecutionContext, waitOnExecutionContext, SELF } from 'cloudflare:test';
import { describe, it, expect } from 'vitest';
import worker, { type Env as WorkerEnv } from '../src/index';

// For now, you'll need to do something like this to get a correctly-typed
// `Request` to pass to `worker.fetch()`.
const IncomingRequest = Request<unknown, IncomingRequestCfProperties>;

const testEnv: WorkerEnv = {
	...(env as unknown as WorkerEnv),
	HYPERDRIVE: { connectionString: 'postgresql://example.com/test' }
};

describe('rushes hyperdrive worker', () => {
	it('describes available endpoints', async () => {
		const request = new IncomingRequest('http://example.com');
		const ctx = createExecutionContext();
		const response = await worker.fetch(request, testEnv, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.headers.get('content-type')).toContain('application/json');
		const payload = (await response.json()) as { service: string; endpoints: string[] };
		expect(payload.service).toBe('rushes-hyperdrive');
		expect(payload.endpoints).toContain('/videos');
	});

	it('handles CORS preflight without touching the database', async () => {
		const request = new IncomingRequest('http://example.com/videos', {
			method: 'OPTIONS'
		});
		const ctx = createExecutionContext();
		const response = await worker.fetch(request, testEnv, ctx);
		await waitOnExecutionContext(ctx);

		expect(response.status).toBe(204);
		expect(response.headers.get('access-control-allow-origin')).toBe('*');
	});

	it('exposes the worker entry via SELF.fetch()', async () => {
		const response = await SELF.fetch('https://example.com');
		expect(response.headers.get('content-type')).toContain('application/json');
	});
});
</file>

<file path="hyperdrive-tutorial/test/tsconfig.json">
{
	"extends": "../tsconfig.json",
	"compilerOptions": {
		"types": ["@cloudflare/vitest-pool-workers"]
	},
	"include": ["./**/*.ts", "../worker-configuration.d.ts"],
	"exclude": []
}
</file>

<file path="hyperdrive-tutorial/.editorconfig">
# http://editorconfig.org
root = true

[*]
indent_style = tab
end_of_line = lf
charset = utf-8
trim_trailing_whitespace = true
insert_final_newline = true

[*.yml]
indent_style = space
</file>

<file path="hyperdrive-tutorial/.gitignore">
# Logs

logs
_.log
npm-debug.log_
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)

report.[0-9]_.[0-9]_.[0-9]_.[0-9]_.json

# Runtime data

pids
_.pid
_.seed
\*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover

lib-cov

# Coverage directory used by tools like istanbul

coverage
\*.lcov

# nyc test coverage

.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)

.grunt

# Bower dependency directory (https://bower.io/)

bower_components

# node-waf configuration

.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)

build/Release

# Dependency directories

node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)

web_modules/

# TypeScript cache

\*.tsbuildinfo

# Optional npm cache directory

.npm

# Optional eslint cache

.eslintcache

# Optional stylelint cache

.stylelintcache

# Microbundle cache

.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history

.node_repl_history

# Output of 'npm pack'

\*.tgz

# Yarn Integrity file

.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)

.cache
.parcel-cache

# Next.js build output

.next
out

# Nuxt.js build / generate output

.nuxt
dist

# Gatsby files

.cache/

# Comment in the public line in if your project uses Gatsby and not Next.js

# https://nextjs.org/blog/next-9-1#public-directory-support

# public

# vuepress build output

.vuepress/dist

# vuepress v2.x temp and cache directory

.temp
.cache

# Docusaurus cache and generated files

.docusaurus

# Serverless directories

.serverless/

# FuseBox cache

.fusebox/

# DynamoDB Local files

.dynamodb/

# TernJS port file

.tern-port

# Stores VSCode versions used for testing VSCode extensions

.vscode-test

# yarn v2

.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.\*

# wrangler project

.dev.vars*
!.dev.vars.example
.env*
!.env.example
.wrangler/
</file>

<file path="hyperdrive-tutorial/.prettierrc">
{
	"printWidth": 140,
	"singleQuote": true,
	"semi": true,
	"useTabs": true
}
</file>

<file path="hyperdrive-tutorial/package.json">
{
	"name": "hyperdrive-tutorial",
	"version": "0.0.0",
	"private": true,
	"scripts": {
		"deploy": "wrangler deploy",
		"dev": "wrangler dev",
		"start": "wrangler dev",
		"test": "vitest",
		"cf-typegen": "wrangler types"
	},
	"dependencies": {
		"pg": "^8.16.3"
	},
	"devDependencies": {
		"@cloudflare/vitest-pool-workers": "^0.8.19",
		"@types/pg": "^8.15.5",
		"typescript": "^5.5.2",
		"vitest": "~3.2.0",
		"wrangler": "^4.44.0"
	}
}
</file>

<file path="hyperdrive-tutorial/tsconfig.json">
{
	"compilerOptions": {
		/* Visit https://aka.ms/tsconfig.json to read more about this file */

		/* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
		"target": "es2021",
		/* Specify a set of bundled library declaration files that describe the target runtime environment. */
		"lib": ["es2021"],
		/* Specify what JSX code is generated. */
		"jsx": "react-jsx",

		/* Specify what module code is generated. */
		"module": "es2022",
		/* Specify how TypeScript looks up a file from a given module specifier. */
		"moduleResolution": "Bundler",
		/* Enable importing .json files */
		"resolveJsonModule": true,

		/* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */
		"allowJs": true,
		/* Enable error reporting in type-checked JavaScript files. */
		"checkJs": false,

		/* Disable emitting files from a compilation. */
		"noEmit": true,

		/* Ensure that each file can be safely transpiled without relying on other imports. */
		"isolatedModules": true,
		/* Allow 'import x from y' when a module doesn't have a default export. */
		"allowSyntheticDefaultImports": true,
		/* Ensure that casing is correct in imports. */
		"forceConsistentCasingInFileNames": true,

		/* Enable all strict type-checking options. */
		"strict": true,

		/* Skip type checking all .d.ts files. */
		"skipLibCheck": true,
		"types": [
			"./worker-configuration.d.ts"
		]
	},
	"exclude": ["test"],
	"include": ["worker-configuration.d.ts", "src/**/*.ts"]
}
</file>

<file path="hyperdrive-tutorial/vitest.config.mts">
import { defineWorkersConfig } from '@cloudflare/vitest-pool-workers/config';

export default defineWorkersConfig({
	test: {
		poolOptions: {
			workers: {
				wrangler: { configPath: './wrangler.jsonc' },
			},
		},
	},
});
</file>

<file path="hyperdrive-tutorial/worker-configuration.d.ts">
/* eslint-disable */
// Generated by Wrangler by running `wrangler types` (hash: b739a9c19cff1463949c4db47674ed86)
// Runtime types generated with workerd@1.20251011.0 2025-10-23 
declare namespace Cloudflare {
	interface GlobalProps {
		mainModule: typeof import("./src/index");
	}
	interface Env {
	}
}
interface Env extends Cloudflare.Env {}

// Begin runtime types
/*! *****************************************************************************
Copyright (c) Cloudflare. All rights reserved.
Copyright (c) Microsoft Corporation. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* eslint-disable */
// noinspection JSUnusedGlobalSymbols
declare var onmessage: never;
/**
 * An abnormal event (called an exception) which occurs as a result of calling a method or accessing a property of a web API.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException)
 */
declare class DOMException extends Error {
    constructor(message?: string, name?: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/message) */
    readonly message: string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/name) */
    readonly name: string;
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/DOMException/code)
     */
    readonly code: number;
    static readonly INDEX_SIZE_ERR: number;
    static readonly DOMSTRING_SIZE_ERR: number;
    static readonly HIERARCHY_REQUEST_ERR: number;
    static readonly WRONG_DOCUMENT_ERR: number;
    static readonly INVALID_CHARACTER_ERR: number;
    static readonly NO_DATA_ALLOWED_ERR: number;
    static readonly NO_MODIFICATION_ALLOWED_ERR: number;
    static readonly NOT_FOUND_ERR: number;
    static readonly NOT_SUPPORTED_ERR: number;
    static readonly INUSE_ATTRIBUTE_ERR: number;
    static readonly INVALID_STATE_ERR: number;
    static readonly SYNTAX_ERR: number;
    static readonly INVALID_MODIFICATION_ERR: number;
    static readonly NAMESPACE_ERR: number;
    static readonly INVALID_ACCESS_ERR: number;
    static readonly VALIDATION_ERR: number;
    static readonly TYPE_MISMATCH_ERR: number;
    static readonly SECURITY_ERR: number;
    static readonly NETWORK_ERR: number;
    static readonly ABORT_ERR: number;
    static readonly URL_MISMATCH_ERR: number;
    static readonly QUOTA_EXCEEDED_ERR: number;
    static readonly TIMEOUT_ERR: number;
    static readonly INVALID_NODE_TYPE_ERR: number;
    static readonly DATA_CLONE_ERR: number;
    get stack(): any;
    set stack(value: any);
}
type WorkerGlobalScopeEventMap = {
    fetch: FetchEvent;
    scheduled: ScheduledEvent;
    queue: QueueEvent;
    unhandledrejection: PromiseRejectionEvent;
    rejectionhandled: PromiseRejectionEvent;
};
declare abstract class WorkerGlobalScope extends EventTarget<WorkerGlobalScopeEventMap> {
    EventTarget: typeof EventTarget;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console) */
interface Console {
    "assert"(condition?: boolean, ...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/clear_static) */
    clear(): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/count_static) */
    count(label?: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/countReset_static) */
    countReset(label?: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/debug_static) */
    debug(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/dir_static) */
    dir(item?: any, options?: any): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/dirxml_static) */
    dirxml(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/error_static) */
    error(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/group_static) */
    group(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/groupCollapsed_static) */
    groupCollapsed(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/groupEnd_static) */
    groupEnd(): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/info_static) */
    info(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static) */
    log(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/table_static) */
    table(tabularData?: any, properties?: string[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/time_static) */
    time(label?: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/timeEnd_static) */
    timeEnd(label?: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/timeLog_static) */
    timeLog(label?: string, ...data: any[]): void;
    timeStamp(label?: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/trace_static) */
    trace(...data: any[]): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/console/warn_static) */
    warn(...data: any[]): void;
}
declare const console: Console;
type BufferSource = ArrayBufferView | ArrayBuffer;
type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | BigInt64Array | BigUint64Array;
declare namespace WebAssembly {
    class CompileError extends Error {
        constructor(message?: string);
    }
    class RuntimeError extends Error {
        constructor(message?: string);
    }
    type ValueType = "anyfunc" | "externref" | "f32" | "f64" | "i32" | "i64" | "v128";
    interface GlobalDescriptor {
        value: ValueType;
        mutable?: boolean;
    }
    class Global {
        constructor(descriptor: GlobalDescriptor, value?: any);
        value: any;
        valueOf(): any;
    }
    type ImportValue = ExportValue | number;
    type ModuleImports = Record<string, ImportValue>;
    type Imports = Record<string, ModuleImports>;
    type ExportValue = Function | Global | Memory | Table;
    type Exports = Record<string, ExportValue>;
    class Instance {
        constructor(module: Module, imports?: Imports);
        readonly exports: Exports;
    }
    interface MemoryDescriptor {
        initial: number;
        maximum?: number;
        shared?: boolean;
    }
    class Memory {
        constructor(descriptor: MemoryDescriptor);
        readonly buffer: ArrayBuffer;
        grow(delta: number): number;
    }
    type ImportExportKind = "function" | "global" | "memory" | "table";
    interface ModuleExportDescriptor {
        kind: ImportExportKind;
        name: string;
    }
    interface ModuleImportDescriptor {
        kind: ImportExportKind;
        module: string;
        name: string;
    }
    abstract class Module {
        static customSections(module: Module, sectionName: string): ArrayBuffer[];
        static exports(module: Module): ModuleExportDescriptor[];
        static imports(module: Module): ModuleImportDescriptor[];
    }
    type TableKind = "anyfunc" | "externref";
    interface TableDescriptor {
        element: TableKind;
        initial: number;
        maximum?: number;
    }
    class Table {
        constructor(descriptor: TableDescriptor, value?: any);
        readonly length: number;
        get(index: number): any;
        grow(delta: number, value?: any): number;
        set(index: number, value?: any): void;
    }
    function instantiate(module: Module, imports?: Imports): Promise<Instance>;
    function validate(bytes: BufferSource): boolean;
}
/**
 * This ServiceWorker API interface represents the global execution context of a service worker.
 * Available only in secure contexts.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ServiceWorkerGlobalScope)
 */
interface ServiceWorkerGlobalScope extends WorkerGlobalScope {
    DOMException: typeof DOMException;
    WorkerGlobalScope: typeof WorkerGlobalScope;
    btoa(data: string): string;
    atob(data: string): string;
    setTimeout(callback: (...args: any[]) => void, msDelay?: number): number;
    setTimeout<Args extends any[]>(callback: (...args: Args) => void, msDelay?: number, ...args: Args): number;
    clearTimeout(timeoutId: number | null): void;
    setInterval(callback: (...args: any[]) => void, msDelay?: number): number;
    setInterval<Args extends any[]>(callback: (...args: Args) => void, msDelay?: number, ...args: Args): number;
    clearInterval(timeoutId: number | null): void;
    queueMicrotask(task: Function): void;
    structuredClone<T>(value: T, options?: StructuredSerializeOptions): T;
    reportError(error: any): void;
    fetch(input: RequestInfo | URL, init?: RequestInit<RequestInitCfProperties>): Promise<Response>;
    self: ServiceWorkerGlobalScope;
    crypto: Crypto;
    caches: CacheStorage;
    scheduler: Scheduler;
    performance: Performance;
    Cloudflare: Cloudflare;
    readonly origin: string;
    Event: typeof Event;
    ExtendableEvent: typeof ExtendableEvent;
    CustomEvent: typeof CustomEvent;
    PromiseRejectionEvent: typeof PromiseRejectionEvent;
    FetchEvent: typeof FetchEvent;
    TailEvent: typeof TailEvent;
    TraceEvent: typeof TailEvent;
    ScheduledEvent: typeof ScheduledEvent;
    MessageEvent: typeof MessageEvent;
    CloseEvent: typeof CloseEvent;
    ReadableStreamDefaultReader: typeof ReadableStreamDefaultReader;
    ReadableStreamBYOBReader: typeof ReadableStreamBYOBReader;
    ReadableStream: typeof ReadableStream;
    WritableStream: typeof WritableStream;
    WritableStreamDefaultWriter: typeof WritableStreamDefaultWriter;
    TransformStream: typeof TransformStream;
    ByteLengthQueuingStrategy: typeof ByteLengthQueuingStrategy;
    CountQueuingStrategy: typeof CountQueuingStrategy;
    ErrorEvent: typeof ErrorEvent;
    MessageChannel: typeof MessageChannel;
    MessagePort: typeof MessagePort;
    EventSource: typeof EventSource;
    ReadableStreamBYOBRequest: typeof ReadableStreamBYOBRequest;
    ReadableStreamDefaultController: typeof ReadableStreamDefaultController;
    ReadableByteStreamController: typeof ReadableByteStreamController;
    WritableStreamDefaultController: typeof WritableStreamDefaultController;
    TransformStreamDefaultController: typeof TransformStreamDefaultController;
    CompressionStream: typeof CompressionStream;
    DecompressionStream: typeof DecompressionStream;
    TextEncoderStream: typeof TextEncoderStream;
    TextDecoderStream: typeof TextDecoderStream;
    Headers: typeof Headers;
    Body: typeof Body;
    Request: typeof Request;
    Response: typeof Response;
    WebSocket: typeof WebSocket;
    WebSocketPair: typeof WebSocketPair;
    WebSocketRequestResponsePair: typeof WebSocketRequestResponsePair;
    AbortController: typeof AbortController;
    AbortSignal: typeof AbortSignal;
    TextDecoder: typeof TextDecoder;
    TextEncoder: typeof TextEncoder;
    navigator: Navigator;
    Navigator: typeof Navigator;
    URL: typeof URL;
    URLSearchParams: typeof URLSearchParams;
    URLPattern: typeof URLPattern;
    Blob: typeof Blob;
    File: typeof File;
    FormData: typeof FormData;
    Crypto: typeof Crypto;
    SubtleCrypto: typeof SubtleCrypto;
    CryptoKey: typeof CryptoKey;
    CacheStorage: typeof CacheStorage;
    Cache: typeof Cache;
    FixedLengthStream: typeof FixedLengthStream;
    IdentityTransformStream: typeof IdentityTransformStream;
    HTMLRewriter: typeof HTMLRewriter;
}
declare function addEventListener<Type extends keyof WorkerGlobalScopeEventMap>(type: Type, handler: EventListenerOrEventListenerObject<WorkerGlobalScopeEventMap[Type]>, options?: EventTargetAddEventListenerOptions | boolean): void;
declare function removeEventListener<Type extends keyof WorkerGlobalScopeEventMap>(type: Type, handler: EventListenerOrEventListenerObject<WorkerGlobalScopeEventMap[Type]>, options?: EventTargetEventListenerOptions | boolean): void;
/**
 * Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)
 */
declare function dispatchEvent(event: WorkerGlobalScopeEventMap[keyof WorkerGlobalScopeEventMap]): boolean;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/btoa) */
declare function btoa(data: string): string;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/atob) */
declare function atob(data: string): string;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setTimeout) */
declare function setTimeout(callback: (...args: any[]) => void, msDelay?: number): number;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setTimeout) */
declare function setTimeout<Args extends any[]>(callback: (...args: Args) => void, msDelay?: number, ...args: Args): number;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/clearTimeout) */
declare function clearTimeout(timeoutId: number | null): void;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setInterval) */
declare function setInterval(callback: (...args: any[]) => void, msDelay?: number): number;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/setInterval) */
declare function setInterval<Args extends any[]>(callback: (...args: Args) => void, msDelay?: number, ...args: Args): number;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/clearInterval) */
declare function clearInterval(timeoutId: number | null): void;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/queueMicrotask) */
declare function queueMicrotask(task: Function): void;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/structuredClone) */
declare function structuredClone<T>(value: T, options?: StructuredSerializeOptions): T;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/reportError) */
declare function reportError(error: any): void;
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Window/fetch) */
declare function fetch(input: RequestInfo | URL, init?: RequestInit<RequestInitCfProperties>): Promise<Response>;
declare const self: ServiceWorkerGlobalScope;
/**
* The Web Crypto API provides a set of low-level functions for common cryptographic tasks.
* The Workers runtime implements the full surface of this API, but with some differences in
* the [supported algorithms](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#supported-algorithms)
* compared to those implemented in most browsers.
*
* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)
*/
declare const crypto: Crypto;
/**
* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.
*
* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)
*/
declare const caches: CacheStorage;
declare const scheduler: Scheduler;
/**
* The Workers runtime supports a subset of the Performance API, used to measure timing and performance,
* as well as timing of subrequests and other operations.
*
* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/)
*/
declare const performance: Performance;
declare const Cloudflare: Cloudflare;
declare const origin: string;
declare const navigator: Navigator;
interface TestController {
}
interface ExecutionContext<Props = unknown> {
    waitUntil(promise: Promise<any>): void;
    passThroughOnException(): void;
    readonly props: Props;
}
type ExportedHandlerFetchHandler<Env = unknown, CfHostMetadata = unknown> = (request: Request<CfHostMetadata, IncomingRequestCfProperties<CfHostMetadata>>, env: Env, ctx: ExecutionContext) => Response | Promise<Response>;
type ExportedHandlerTailHandler<Env = unknown> = (events: TraceItem[], env: Env, ctx: ExecutionContext) => void | Promise<void>;
type ExportedHandlerTraceHandler<Env = unknown> = (traces: TraceItem[], env: Env, ctx: ExecutionContext) => void | Promise<void>;
type ExportedHandlerTailStreamHandler<Env = unknown> = (event: TailStream.TailEvent<TailStream.Onset>, env: Env, ctx: ExecutionContext) => TailStream.TailEventHandlerType | Promise<TailStream.TailEventHandlerType>;
type ExportedHandlerScheduledHandler<Env = unknown> = (controller: ScheduledController, env: Env, ctx: ExecutionContext) => void | Promise<void>;
type ExportedHandlerQueueHandler<Env = unknown, Message = unknown> = (batch: MessageBatch<Message>, env: Env, ctx: ExecutionContext) => void | Promise<void>;
type ExportedHandlerTestHandler<Env = unknown> = (controller: TestController, env: Env, ctx: ExecutionContext) => void | Promise<void>;
interface ExportedHandler<Env = unknown, QueueHandlerMessage = unknown, CfHostMetadata = unknown> {
    fetch?: ExportedHandlerFetchHandler<Env, CfHostMetadata>;
    tail?: ExportedHandlerTailHandler<Env>;
    trace?: ExportedHandlerTraceHandler<Env>;
    tailStream?: ExportedHandlerTailStreamHandler<Env>;
    scheduled?: ExportedHandlerScheduledHandler<Env>;
    test?: ExportedHandlerTestHandler<Env>;
    email?: EmailExportedHandler<Env>;
    queue?: ExportedHandlerQueueHandler<Env, QueueHandlerMessage>;
}
interface StructuredSerializeOptions {
    transfer?: any[];
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent) */
declare abstract class PromiseRejectionEvent extends Event {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/promise) */
    readonly promise: Promise<any>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/PromiseRejectionEvent/reason) */
    readonly reason: any;
}
declare abstract class Navigator {
    sendBeacon(url: string, body?: (ReadableStream | string | (ArrayBuffer | ArrayBufferView) | Blob | FormData | URLSearchParams | URLSearchParams)): boolean;
    readonly userAgent: string;
    readonly hardwareConcurrency: number;
    readonly language: string;
    readonly languages: string[];
}
interface AlarmInvocationInfo {
    readonly isRetry: boolean;
    readonly retryCount: number;
}
interface Cloudflare {
    readonly compatibilityFlags: Record<string, boolean>;
}
interface DurableObject {
    fetch(request: Request): Response | Promise<Response>;
    alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise<void>;
    webSocketMessage?(ws: WebSocket, message: string | ArrayBuffer): void | Promise<void>;
    webSocketClose?(ws: WebSocket, code: number, reason: string, wasClean: boolean): void | Promise<void>;
    webSocketError?(ws: WebSocket, error: unknown): void | Promise<void>;
}
type DurableObjectStub<T extends Rpc.DurableObjectBranded | undefined = undefined> = Fetcher<T, "alarm" | "webSocketMessage" | "webSocketClose" | "webSocketError"> & {
    readonly id: DurableObjectId;
    readonly name?: string;
};
interface DurableObjectId {
    toString(): string;
    equals(other: DurableObjectId): boolean;
    readonly name?: string;
}
declare abstract class DurableObjectNamespace<T extends Rpc.DurableObjectBranded | undefined = undefined> {
    newUniqueId(options?: DurableObjectNamespaceNewUniqueIdOptions): DurableObjectId;
    idFromName(name: string): DurableObjectId;
    idFromString(id: string): DurableObjectId;
    get(id: DurableObjectId, options?: DurableObjectNamespaceGetDurableObjectOptions): DurableObjectStub<T>;
    getByName(name: string, options?: DurableObjectNamespaceGetDurableObjectOptions): DurableObjectStub<T>;
    jurisdiction(jurisdiction: DurableObjectJurisdiction): DurableObjectNamespace<T>;
}
type DurableObjectJurisdiction = "eu" | "fedramp" | "fedramp-high";
interface DurableObjectNamespaceNewUniqueIdOptions {
    jurisdiction?: DurableObjectJurisdiction;
}
type DurableObjectLocationHint = "wnam" | "enam" | "sam" | "weur" | "eeur" | "apac" | "oc" | "afr" | "me";
interface DurableObjectNamespaceGetDurableObjectOptions {
    locationHint?: DurableObjectLocationHint;
}
interface DurableObjectClass<_T extends Rpc.DurableObjectBranded | undefined = undefined> {
}
interface DurableObjectState<Props = unknown> {
    waitUntil(promise: Promise<any>): void;
    readonly props: Props;
    readonly id: DurableObjectId;
    readonly storage: DurableObjectStorage;
    container?: Container;
    blockConcurrencyWhile<T>(callback: () => Promise<T>): Promise<T>;
    acceptWebSocket(ws: WebSocket, tags?: string[]): void;
    getWebSockets(tag?: string): WebSocket[];
    setWebSocketAutoResponse(maybeReqResp?: WebSocketRequestResponsePair): void;
    getWebSocketAutoResponse(): WebSocketRequestResponsePair | null;
    getWebSocketAutoResponseTimestamp(ws: WebSocket): Date | null;
    setHibernatableWebSocketEventTimeout(timeoutMs?: number): void;
    getHibernatableWebSocketEventTimeout(): number | null;
    getTags(ws: WebSocket): string[];
    abort(reason?: string): void;
}
interface DurableObjectTransaction {
    get<T = unknown>(key: string, options?: DurableObjectGetOptions): Promise<T | undefined>;
    get<T = unknown>(keys: string[], options?: DurableObjectGetOptions): Promise<Map<string, T>>;
    list<T = unknown>(options?: DurableObjectListOptions): Promise<Map<string, T>>;
    put<T>(key: string, value: T, options?: DurableObjectPutOptions): Promise<void>;
    put<T>(entries: Record<string, T>, options?: DurableObjectPutOptions): Promise<void>;
    delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;
    delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;
    rollback(): void;
    getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;
    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise<void>;
    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;
}
interface DurableObjectStorage {
    get<T = unknown>(key: string, options?: DurableObjectGetOptions): Promise<T | undefined>;
    get<T = unknown>(keys: string[], options?: DurableObjectGetOptions): Promise<Map<string, T>>;
    list<T = unknown>(options?: DurableObjectListOptions): Promise<Map<string, T>>;
    put<T>(key: string, value: T, options?: DurableObjectPutOptions): Promise<void>;
    put<T>(entries: Record<string, T>, options?: DurableObjectPutOptions): Promise<void>;
    delete(key: string, options?: DurableObjectPutOptions): Promise<boolean>;
    delete(keys: string[], options?: DurableObjectPutOptions): Promise<number>;
    deleteAll(options?: DurableObjectPutOptions): Promise<void>;
    transaction<T>(closure: (txn: DurableObjectTransaction) => Promise<T>): Promise<T>;
    getAlarm(options?: DurableObjectGetAlarmOptions): Promise<number | null>;
    setAlarm(scheduledTime: number | Date, options?: DurableObjectSetAlarmOptions): Promise<void>;
    deleteAlarm(options?: DurableObjectSetAlarmOptions): Promise<void>;
    sync(): Promise<void>;
    sql: SqlStorage;
    kv: SyncKvStorage;
    transactionSync<T>(closure: () => T): T;
    getCurrentBookmark(): Promise<string>;
    getBookmarkForTime(timestamp: number | Date): Promise<string>;
    onNextSessionRestoreBookmark(bookmark: string): Promise<string>;
}
interface DurableObjectListOptions {
    start?: string;
    startAfter?: string;
    end?: string;
    prefix?: string;
    reverse?: boolean;
    limit?: number;
    allowConcurrency?: boolean;
    noCache?: boolean;
}
interface DurableObjectGetOptions {
    allowConcurrency?: boolean;
    noCache?: boolean;
}
interface DurableObjectGetAlarmOptions {
    allowConcurrency?: boolean;
}
interface DurableObjectPutOptions {
    allowConcurrency?: boolean;
    allowUnconfirmed?: boolean;
    noCache?: boolean;
}
interface DurableObjectSetAlarmOptions {
    allowConcurrency?: boolean;
    allowUnconfirmed?: boolean;
}
declare class WebSocketRequestResponsePair {
    constructor(request: string, response: string);
    get request(): string;
    get response(): string;
}
interface AnalyticsEngineDataset {
    writeDataPoint(event?: AnalyticsEngineDataPoint): void;
}
interface AnalyticsEngineDataPoint {
    indexes?: ((ArrayBuffer | string) | null)[];
    doubles?: number[];
    blobs?: ((ArrayBuffer | string) | null)[];
}
/**
 * An event which takes place in the DOM.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event)
 */
declare class Event {
    constructor(type: string, init?: EventInit);
    /**
     * Returns the type of event, e.g. "click", "hashchange", or "submit".
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/type)
     */
    get type(): string;
    /**
     * Returns the event's phase, which is one of NONE, CAPTURING_PHASE, AT_TARGET, and BUBBLING_PHASE.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/eventPhase)
     */
    get eventPhase(): number;
    /**
     * Returns true or false depending on how event was initialized. True if event invokes listeners past a ShadowRoot node that is the root of its target, and false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/composed)
     */
    get composed(): boolean;
    /**
     * Returns true or false depending on how event was initialized. True if event goes through its target's ancestors in reverse tree order, and false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/bubbles)
     */
    get bubbles(): boolean;
    /**
     * Returns true or false depending on how event was initialized. Its return value does not always carry meaning, but true can indicate that part of the operation during which event was dispatched, can be canceled by invoking the preventDefault() method.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelable)
     */
    get cancelable(): boolean;
    /**
     * Returns true if preventDefault() was invoked successfully to indicate cancelation, and false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/defaultPrevented)
     */
    get defaultPrevented(): boolean;
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/returnValue)
     */
    get returnValue(): boolean;
    /**
     * Returns the object whose event listener's callback is currently being invoked.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/currentTarget)
     */
    get currentTarget(): EventTarget | undefined;
    /**
     * Returns the object to which event is dispatched (its target).
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/target)
     */
    get target(): EventTarget | undefined;
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/srcElement)
     */
    get srcElement(): EventTarget | undefined;
    /**
     * Returns the event's timestamp as the number of milliseconds measured relative to the time origin.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/timeStamp)
     */
    get timeStamp(): number;
    /**
     * Returns true if event was dispatched by the user agent, and false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/isTrusted)
     */
    get isTrusted(): boolean;
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelBubble)
     */
    get cancelBubble(): boolean;
    /**
     * @deprecated
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/cancelBubble)
     */
    set cancelBubble(value: boolean);
    /**
     * Invoking this method prevents event from reaching any registered event listeners after the current one finishes running and, when dispatched in a tree, also prevents event from reaching any other objects.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/stopImmediatePropagation)
     */
    stopImmediatePropagation(): void;
    /**
     * If invoked when the cancelable attribute value is true, and while executing a listener for the event with passive set to false, signals to the operation that caused event to be dispatched that it needs to be canceled.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/preventDefault)
     */
    preventDefault(): void;
    /**
     * When dispatched in a tree, invoking this method prevents event from reaching any objects other than the current object.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/stopPropagation)
     */
    stopPropagation(): void;
    /**
     * Returns the invocation target objects of event's path (objects on which listeners will be invoked), except for any nodes in shadow trees of which the shadow root's mode is "closed" that are not reachable from event's currentTarget.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Event/composedPath)
     */
    composedPath(): EventTarget[];
    static readonly NONE: number;
    static readonly CAPTURING_PHASE: number;
    static readonly AT_TARGET: number;
    static readonly BUBBLING_PHASE: number;
}
interface EventInit {
    bubbles?: boolean;
    cancelable?: boolean;
    composed?: boolean;
}
type EventListener<EventType extends Event = Event> = (event: EventType) => void;
interface EventListenerObject<EventType extends Event = Event> {
    handleEvent(event: EventType): void;
}
type EventListenerOrEventListenerObject<EventType extends Event = Event> = EventListener<EventType> | EventListenerObject<EventType>;
/**
 * EventTarget is a DOM interface implemented by objects that can receive events and may have listeners for them.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget)
 */
declare class EventTarget<EventMap extends Record<string, Event> = Record<string, Event>> {
    constructor();
    /**
     * Appends an event listener for events whose type attribute value is type. The callback argument sets the callback that will be invoked when the event is dispatched.
     *
     * The options argument sets listener-specific options. For compatibility this can be a boolean, in which case the method behaves exactly as if the value was specified as options's capture.
     *
     * When set to true, options's capture prevents callback from being invoked when the event's eventPhase attribute value is BUBBLING_PHASE. When false (or not present), callback will not be invoked when event's eventPhase attribute value is CAPTURING_PHASE. Either way, callback will be invoked if event's eventPhase attribute value is AT_TARGET.
     *
     * When set to true, options's passive indicates that the callback will not cancel the event by invoking preventDefault(). This is used to enable performance optimizations described in § 2.8 Observing event listeners.
     *
     * When set to true, options's once indicates that the callback will only be invoked once after which the event listener will be removed.
     *
     * If an AbortSignal is passed for options's signal, then the event listener will be removed when signal is aborted.
     *
     * The event listener is appended to target's event listener list and is not appended if it has the same type, callback, and capture.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/addEventListener)
     */
    addEventListener<Type extends keyof EventMap>(type: Type, handler: EventListenerOrEventListenerObject<EventMap[Type]>, options?: EventTargetAddEventListenerOptions | boolean): void;
    /**
     * Removes the event listener in target's event listener list with the same type, callback, and options.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/removeEventListener)
     */
    removeEventListener<Type extends keyof EventMap>(type: Type, handler: EventListenerOrEventListenerObject<EventMap[Type]>, options?: EventTargetEventListenerOptions | boolean): void;
    /**
     * Dispatches a synthetic event event to target and returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventTarget/dispatchEvent)
     */
    dispatchEvent(event: EventMap[keyof EventMap]): boolean;
}
interface EventTargetEventListenerOptions {
    capture?: boolean;
}
interface EventTargetAddEventListenerOptions {
    capture?: boolean;
    passive?: boolean;
    once?: boolean;
    signal?: AbortSignal;
}
interface EventTargetHandlerObject {
    handleEvent: (event: Event) => any | undefined;
}
/**
 * A controller object that allows you to abort one or more DOM requests as and when desired.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController)
 */
declare class AbortController {
    constructor();
    /**
     * Returns the AbortSignal object associated with this object.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController/signal)
     */
    get signal(): AbortSignal;
    /**
     * Invoking this method will set this object's AbortSignal's aborted flag and signal to any observers that the associated activity is to be aborted.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortController/abort)
     */
    abort(reason?: any): void;
}
/**
 * A signal object that allows you to communicate with a DOM request (such as a Fetch) and abort it if required via an AbortController object.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal)
 */
declare abstract class AbortSignal extends EventTarget {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_static) */
    static abort(reason?: any): AbortSignal;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/timeout_static) */
    static timeout(delay: number): AbortSignal;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/any_static) */
    static any(signals: AbortSignal[]): AbortSignal;
    /**
     * Returns true if this AbortSignal's AbortController has signaled to abort, and false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/aborted)
     */
    get aborted(): boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/reason) */
    get reason(): any;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_event) */
    get onabort(): any | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/abort_event) */
    set onabort(value: any | null);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/AbortSignal/throwIfAborted) */
    throwIfAborted(): void;
}
interface Scheduler {
    wait(delay: number, maybeOptions?: SchedulerWaitOptions): Promise<void>;
}
interface SchedulerWaitOptions {
    signal?: AbortSignal;
}
/**
 * Extends the lifetime of the install and activate events dispatched on the global scope as part of the service worker lifecycle. This ensures that any functional events (like FetchEvent) are not dispatched until it upgrades database schemas and deletes the outdated cache entries.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableEvent)
 */
declare abstract class ExtendableEvent extends Event {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ExtendableEvent/waitUntil) */
    waitUntil(promise: Promise<any>): void;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent) */
declare class CustomEvent<T = any> extends Event {
    constructor(type: string, init?: CustomEventCustomEventInit);
    /**
     * Returns any custom data event was created with. Typically used for synthetic events.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CustomEvent/detail)
     */
    get detail(): T;
}
interface CustomEventCustomEventInit {
    bubbles?: boolean;
    cancelable?: boolean;
    composed?: boolean;
    detail?: any;
}
/**
 * A file-like object of immutable, raw data. Blobs represent data that isn't necessarily in a JavaScript-native format. The File interface is based on Blob, inheriting blob functionality and expanding it to support files on the user's system.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob)
 */
declare class Blob {
    constructor(type?: ((ArrayBuffer | ArrayBufferView) | string | Blob)[], options?: BlobOptions);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/size) */
    get size(): number;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/type) */
    get type(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/slice) */
    slice(start?: number, end?: number, type?: string): Blob;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/arrayBuffer) */
    arrayBuffer(): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/bytes) */
    bytes(): Promise<Uint8Array>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/text) */
    text(): Promise<string>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Blob/stream) */
    stream(): ReadableStream;
}
interface BlobOptions {
    type?: string;
}
/**
 * Provides information about files and allows JavaScript in a web page to access their content.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/File)
 */
declare class File extends Blob {
    constructor(bits: ((ArrayBuffer | ArrayBufferView) | string | Blob)[] | undefined, name: string, options?: FileOptions);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/name) */
    get name(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/File/lastModified) */
    get lastModified(): number;
}
interface FileOptions {
    type?: string;
    lastModified?: number;
}
/**
* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.
*
* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)
*/
declare abstract class CacheStorage {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CacheStorage/open) */
    open(cacheName: string): Promise<Cache>;
    readonly default: Cache;
}
/**
* The Cache API allows fine grained control of reading and writing from the Cloudflare global network cache.
*
* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/)
*/
declare abstract class Cache {
    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#delete) */
    delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;
    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#match) */
    match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;
    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/cache/#put) */
    put(request: RequestInfo | URL, response: Response): Promise<void>;
}
interface CacheQueryOptions {
    ignoreMethod?: boolean;
}
/**
* The Web Crypto API provides a set of low-level functions for common cryptographic tasks.
* The Workers runtime implements the full surface of this API, but with some differences in
* the [supported algorithms](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/#supported-algorithms)
* compared to those implemented in most browsers.
*
* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/web-crypto/)
*/
declare abstract class Crypto {
    /**
     * Available only in secure contexts.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/subtle)
     */
    get subtle(): SubtleCrypto;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/getRandomValues) */
    getRandomValues<T extends Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | BigInt64Array | BigUint64Array>(buffer: T): T;
    /**
     * Available only in secure contexts.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Crypto/randomUUID)
     */
    randomUUID(): string;
    DigestStream: typeof DigestStream;
}
/**
 * This Web Crypto API interface provides a number of low-level cryptographic functions. It is accessed via the Crypto.subtle properties available in a window context (via Window.crypto).
 * Available only in secure contexts.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto)
 */
declare abstract class SubtleCrypto {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/encrypt) */
    encrypt(algorithm: string | SubtleCryptoEncryptAlgorithm, key: CryptoKey, plainText: ArrayBuffer | ArrayBufferView): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/decrypt) */
    decrypt(algorithm: string | SubtleCryptoEncryptAlgorithm, key: CryptoKey, cipherText: ArrayBuffer | ArrayBufferView): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/sign) */
    sign(algorithm: string | SubtleCryptoSignAlgorithm, key: CryptoKey, data: ArrayBuffer | ArrayBufferView): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/verify) */
    verify(algorithm: string | SubtleCryptoSignAlgorithm, key: CryptoKey, signature: ArrayBuffer | ArrayBufferView, data: ArrayBuffer | ArrayBufferView): Promise<boolean>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/digest) */
    digest(algorithm: string | SubtleCryptoHashAlgorithm, data: ArrayBuffer | ArrayBufferView): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/generateKey) */
    generateKey(algorithm: string | SubtleCryptoGenerateKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise<CryptoKey | CryptoKeyPair>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveKey) */
    deriveKey(algorithm: string | SubtleCryptoDeriveKeyAlgorithm, baseKey: CryptoKey, derivedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise<CryptoKey>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/deriveBits) */
    deriveBits(algorithm: string | SubtleCryptoDeriveKeyAlgorithm, baseKey: CryptoKey, length?: number | null): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/importKey) */
    importKey(format: string, keyData: (ArrayBuffer | ArrayBufferView) | JsonWebKey, algorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise<CryptoKey>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/exportKey) */
    exportKey(format: string, key: CryptoKey): Promise<ArrayBuffer | JsonWebKey>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/wrapKey) */
    wrapKey(format: string, key: CryptoKey, wrappingKey: CryptoKey, wrapAlgorithm: string | SubtleCryptoEncryptAlgorithm): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/SubtleCrypto/unwrapKey) */
    unwrapKey(format: string, wrappedKey: ArrayBuffer | ArrayBufferView, unwrappingKey: CryptoKey, unwrapAlgorithm: string | SubtleCryptoEncryptAlgorithm, unwrappedKeyAlgorithm: string | SubtleCryptoImportKeyAlgorithm, extractable: boolean, keyUsages: string[]): Promise<CryptoKey>;
    timingSafeEqual(a: ArrayBuffer | ArrayBufferView, b: ArrayBuffer | ArrayBufferView): boolean;
}
/**
 * The CryptoKey dictionary of the Web Crypto API represents a cryptographic key.
 * Available only in secure contexts.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey)
 */
declare abstract class CryptoKey {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/type) */
    readonly type: string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/extractable) */
    readonly extractable: boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/algorithm) */
    readonly algorithm: CryptoKeyKeyAlgorithm | CryptoKeyAesKeyAlgorithm | CryptoKeyHmacKeyAlgorithm | CryptoKeyRsaKeyAlgorithm | CryptoKeyEllipticKeyAlgorithm | CryptoKeyArbitraryKeyAlgorithm;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CryptoKey/usages) */
    readonly usages: string[];
}
interface CryptoKeyPair {
    publicKey: CryptoKey;
    privateKey: CryptoKey;
}
interface JsonWebKey {
    kty: string;
    use?: string;
    key_ops?: string[];
    alg?: string;
    ext?: boolean;
    crv?: string;
    x?: string;
    y?: string;
    d?: string;
    n?: string;
    e?: string;
    p?: string;
    q?: string;
    dp?: string;
    dq?: string;
    qi?: string;
    oth?: RsaOtherPrimesInfo[];
    k?: string;
}
interface RsaOtherPrimesInfo {
    r?: string;
    d?: string;
    t?: string;
}
interface SubtleCryptoDeriveKeyAlgorithm {
    name: string;
    salt?: (ArrayBuffer | ArrayBufferView);
    iterations?: number;
    hash?: (string | SubtleCryptoHashAlgorithm);
    $public?: CryptoKey;
    info?: (ArrayBuffer | ArrayBufferView);
}
interface SubtleCryptoEncryptAlgorithm {
    name: string;
    iv?: (ArrayBuffer | ArrayBufferView);
    additionalData?: (ArrayBuffer | ArrayBufferView);
    tagLength?: number;
    counter?: (ArrayBuffer | ArrayBufferView);
    length?: number;
    label?: (ArrayBuffer | ArrayBufferView);
}
interface SubtleCryptoGenerateKeyAlgorithm {
    name: string;
    hash?: (string | SubtleCryptoHashAlgorithm);
    modulusLength?: number;
    publicExponent?: (ArrayBuffer | ArrayBufferView);
    length?: number;
    namedCurve?: string;
}
interface SubtleCryptoHashAlgorithm {
    name: string;
}
interface SubtleCryptoImportKeyAlgorithm {
    name: string;
    hash?: (string | SubtleCryptoHashAlgorithm);
    length?: number;
    namedCurve?: string;
    compressed?: boolean;
}
interface SubtleCryptoSignAlgorithm {
    name: string;
    hash?: (string | SubtleCryptoHashAlgorithm);
    dataLength?: number;
    saltLength?: number;
}
interface CryptoKeyKeyAlgorithm {
    name: string;
}
interface CryptoKeyAesKeyAlgorithm {
    name: string;
    length: number;
}
interface CryptoKeyHmacKeyAlgorithm {
    name: string;
    hash: CryptoKeyKeyAlgorithm;
    length: number;
}
interface CryptoKeyRsaKeyAlgorithm {
    name: string;
    modulusLength: number;
    publicExponent: ArrayBuffer | ArrayBufferView;
    hash?: CryptoKeyKeyAlgorithm;
}
interface CryptoKeyEllipticKeyAlgorithm {
    name: string;
    namedCurve: string;
}
interface CryptoKeyArbitraryKeyAlgorithm {
    name: string;
    hash?: CryptoKeyKeyAlgorithm;
    namedCurve?: string;
    length?: number;
}
declare class DigestStream extends WritableStream<ArrayBuffer | ArrayBufferView> {
    constructor(algorithm: string | SubtleCryptoHashAlgorithm);
    readonly digest: Promise<ArrayBuffer>;
    get bytesWritten(): number | bigint;
}
/**
 * A decoder for a specific method, that is a specific character encoding, like utf-8, iso-8859-2, koi8, cp1261, gbk, etc. A decoder takes a stream of bytes as input and emits a stream of code points. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder)
 */
declare class TextDecoder {
    constructor(label?: string, options?: TextDecoderConstructorOptions);
    /**
     * Returns the result of running encoding's decoder. The method can be invoked zero or more times with options's stream set to true, and then once without options's stream (or set to false), to process a fragmented input. If the invocation without options's stream (or set to false) has no input, it's clearest to omit both arguments.
     *
     * ```
     * var string = "", decoder = new TextDecoder(encoding), buffer;
     * while(buffer = next_chunk()) {
     *   string += decoder.decode(buffer, {stream:true});
     * }
     * string += decoder.decode(); // end-of-queue
     * ```
     *
     * If the error mode is "fatal" and encoding's decoder returns error, throws a TypeError.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoder/decode)
     */
    decode(input?: (ArrayBuffer | ArrayBufferView), options?: TextDecoderDecodeOptions): string;
    get encoding(): string;
    get fatal(): boolean;
    get ignoreBOM(): boolean;
}
/**
 * TextEncoder takes a stream of code points as input and emits a stream of bytes. For a more scalable, non-native library, see StringView – a C-like representation of strings based on typed arrays.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder)
 */
declare class TextEncoder {
    constructor();
    /**
     * Returns the result of running UTF-8's encoder.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder/encode)
     */
    encode(input?: string): Uint8Array;
    /**
     * Runs the UTF-8 encoder on source, stores the result of that operation into destination, and returns the progress made as an object wherein read is the number of converted code units of source and written is the number of bytes modified in destination.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoder/encodeInto)
     */
    encodeInto(input: string, buffer: ArrayBuffer | ArrayBufferView): TextEncoderEncodeIntoResult;
    get encoding(): string;
}
interface TextDecoderConstructorOptions {
    fatal: boolean;
    ignoreBOM: boolean;
}
interface TextDecoderDecodeOptions {
    stream: boolean;
}
interface TextEncoderEncodeIntoResult {
    read: number;
    written: number;
}
/**
 * Events providing information related to errors in scripts or in files.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent)
 */
declare class ErrorEvent extends Event {
    constructor(type: string, init?: ErrorEventErrorEventInit);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/filename) */
    get filename(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/message) */
    get message(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/lineno) */
    get lineno(): number;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/colno) */
    get colno(): number;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ErrorEvent/error) */
    get error(): any;
}
interface ErrorEventErrorEventInit {
    message?: string;
    filename?: string;
    lineno?: number;
    colno?: number;
    error?: any;
}
/**
 * A message received by a target object.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent)
 */
declare class MessageEvent extends Event {
    constructor(type: string, initializer: MessageEventInit);
    /**
     * Returns the data of the message.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/data)
     */
    readonly data: any;
    /**
     * Returns the origin of the message, for server-sent events and cross-document messaging.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/origin)
     */
    readonly origin: string | null;
    /**
     * Returns the last event ID string, for server-sent events.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/lastEventId)
     */
    readonly lastEventId: string;
    /**
     * Returns the WindowProxy of the source window, for cross-document messaging, and the MessagePort being attached, in the connect event fired at SharedWorkerGlobalScope objects.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/source)
     */
    readonly source: MessagePort | null;
    /**
     * Returns the MessagePort array sent with the message, for cross-document messaging and channel messaging.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageEvent/ports)
     */
    readonly ports: MessagePort[];
}
interface MessageEventInit {
    data: ArrayBuffer | string;
}
/**
 * Provides a way to easily construct a set of key/value pairs representing form fields and their values, which can then be easily sent using the XMLHttpRequest.send() method. It uses the same format a form would use if the encoding type were set to "multipart/form-data".
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData)
 */
declare class FormData {
    constructor();
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/append) */
    append(name: string, value: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/append) */
    append(name: string, value: Blob, filename?: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/delete) */
    delete(name: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/get) */
    get(name: string): (File | string) | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/getAll) */
    getAll(name: string): (File | string)[];
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/has) */
    has(name: string): boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/set) */
    set(name: string, value: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FormData/set) */
    set(name: string, value: Blob, filename?: string): void;
    /* Returns an array of key, value pairs for every entry in the list. */
    entries(): IterableIterator<[
        key: string,
        value: File | string
    ]>;
    /* Returns a list of keys in the list. */
    keys(): IterableIterator<string>;
    /* Returns a list of values in the list. */
    values(): IterableIterator<(File | string)>;
    forEach<This = unknown>(callback: (this: This, value: File | string, key: string, parent: FormData) => void, thisArg?: This): void;
    [Symbol.iterator](): IterableIterator<[
        key: string,
        value: File | string
    ]>;
}
interface ContentOptions {
    html?: boolean;
}
declare class HTMLRewriter {
    constructor();
    on(selector: string, handlers: HTMLRewriterElementContentHandlers): HTMLRewriter;
    onDocument(handlers: HTMLRewriterDocumentContentHandlers): HTMLRewriter;
    transform(response: Response): Response;
}
interface HTMLRewriterElementContentHandlers {
    element?(element: Element): void | Promise<void>;
    comments?(comment: Comment): void | Promise<void>;
    text?(element: Text): void | Promise<void>;
}
interface HTMLRewriterDocumentContentHandlers {
    doctype?(doctype: Doctype): void | Promise<void>;
    comments?(comment: Comment): void | Promise<void>;
    text?(text: Text): void | Promise<void>;
    end?(end: DocumentEnd): void | Promise<void>;
}
interface Doctype {
    readonly name: string | null;
    readonly publicId: string | null;
    readonly systemId: string | null;
}
interface Element {
    tagName: string;
    readonly attributes: IterableIterator<string[]>;
    readonly removed: boolean;
    readonly namespaceURI: string;
    getAttribute(name: string): string | null;
    hasAttribute(name: string): boolean;
    setAttribute(name: string, value: string): Element;
    removeAttribute(name: string): Element;
    before(content: string | ReadableStream | Response, options?: ContentOptions): Element;
    after(content: string | ReadableStream | Response, options?: ContentOptions): Element;
    prepend(content: string | ReadableStream | Response, options?: ContentOptions): Element;
    append(content: string | ReadableStream | Response, options?: ContentOptions): Element;
    replace(content: string | ReadableStream | Response, options?: ContentOptions): Element;
    remove(): Element;
    removeAndKeepContent(): Element;
    setInnerContent(content: string | ReadableStream | Response, options?: ContentOptions): Element;
    onEndTag(handler: (tag: EndTag) => void | Promise<void>): void;
}
interface EndTag {
    name: string;
    before(content: string | ReadableStream | Response, options?: ContentOptions): EndTag;
    after(content: string | ReadableStream | Response, options?: ContentOptions): EndTag;
    remove(): EndTag;
}
interface Comment {
    text: string;
    readonly removed: boolean;
    before(content: string, options?: ContentOptions): Comment;
    after(content: string, options?: ContentOptions): Comment;
    replace(content: string, options?: ContentOptions): Comment;
    remove(): Comment;
}
interface Text {
    readonly text: string;
    readonly lastInTextNode: boolean;
    readonly removed: boolean;
    before(content: string | ReadableStream | Response, options?: ContentOptions): Text;
    after(content: string | ReadableStream | Response, options?: ContentOptions): Text;
    replace(content: string | ReadableStream | Response, options?: ContentOptions): Text;
    remove(): Text;
}
interface DocumentEnd {
    append(content: string, options?: ContentOptions): DocumentEnd;
}
/**
 * This is the event type for fetch events dispatched on the service worker global scope. It contains information about the fetch, including the request and how the receiver will treat the response. It provides the event.respondWith() method, which allows us to provide a response to this fetch.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent)
 */
declare abstract class FetchEvent extends ExtendableEvent {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent/request) */
    readonly request: Request;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/FetchEvent/respondWith) */
    respondWith(promise: Response | Promise<Response>): void;
    passThroughOnException(): void;
}
type HeadersInit = Headers | Iterable<Iterable<string>> | Record<string, string>;
/**
 * This Fetch API interface allows you to perform various actions on HTTP request and response headers. These actions include retrieving, setting, adding to, and removing. A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.  You can add to this using methods like append() (see Examples.) In all methods of this interface, header names are matched by case-insensitive byte sequence.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers)
 */
declare class Headers {
    constructor(init?: HeadersInit);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/get) */
    get(name: string): string | null;
    getAll(name: string): string[];
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/getSetCookie) */
    getSetCookie(): string[];
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/has) */
    has(name: string): boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/set) */
    set(name: string, value: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/append) */
    append(name: string, value: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Headers/delete) */
    delete(name: string): void;
    forEach<This = unknown>(callback: (this: This, value: string, key: string, parent: Headers) => void, thisArg?: This): void;
    /* Returns an iterator allowing to go through all key/value pairs contained in this object. */
    entries(): IterableIterator<[
        key: string,
        value: string
    ]>;
    /* Returns an iterator allowing to go through all keys of the key/value pairs contained in this object. */
    keys(): IterableIterator<string>;
    /* Returns an iterator allowing to go through all values of the key/value pairs contained in this object. */
    values(): IterableIterator<string>;
    [Symbol.iterator](): IterableIterator<[
        key: string,
        value: string
    ]>;
}
type BodyInit = ReadableStream<Uint8Array> | string | ArrayBuffer | ArrayBufferView | Blob | URLSearchParams | FormData;
declare abstract class Body {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/body) */
    get body(): ReadableStream | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bodyUsed) */
    get bodyUsed(): boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/arrayBuffer) */
    arrayBuffer(): Promise<ArrayBuffer>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/bytes) */
    bytes(): Promise<Uint8Array>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/text) */
    text(): Promise<string>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/json) */
    json<T>(): Promise<T>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/formData) */
    formData(): Promise<FormData>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/blob) */
    blob(): Promise<Blob>;
}
/**
 * This Fetch API interface represents the response to a request.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)
 */
declare var Response: {
    prototype: Response;
    new (body?: BodyInit | null, init?: ResponseInit): Response;
    error(): Response;
    redirect(url: string, status?: number): Response;
    json(any: any, maybeInit?: (ResponseInit | Response)): Response;
};
/**
 * This Fetch API interface represents the response to a request.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response)
 */
interface Response extends Body {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/clone) */
    clone(): Response;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/status) */
    status: number;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/statusText) */
    statusText: string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/headers) */
    headers: Headers;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/ok) */
    ok: boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/redirected) */
    redirected: boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/url) */
    url: string;
    webSocket: WebSocket | null;
    cf: any | undefined;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Response/type) */
    type: "default" | "error";
}
interface ResponseInit {
    status?: number;
    statusText?: string;
    headers?: HeadersInit;
    cf?: any;
    webSocket?: (WebSocket | null);
    encodeBody?: "automatic" | "manual";
}
type RequestInfo<CfHostMetadata = unknown, Cf = CfProperties<CfHostMetadata>> = Request<CfHostMetadata, Cf> | string;
/**
 * This Fetch API interface represents a resource request.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)
 */
declare var Request: {
    prototype: Request;
    new <CfHostMetadata = unknown, Cf = CfProperties<CfHostMetadata>>(input: RequestInfo<CfProperties> | URL, init?: RequestInit<Cf>): Request<CfHostMetadata, Cf>;
};
/**
 * This Fetch API interface represents a resource request.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request)
 */
interface Request<CfHostMetadata = unknown, Cf = CfProperties<CfHostMetadata>> extends Body {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/clone) */
    clone(): Request<CfHostMetadata, Cf>;
    /**
     * Returns request's HTTP method, which is "GET" by default.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/method)
     */
    method: string;
    /**
     * Returns the URL of request as a string.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/url)
     */
    url: string;
    /**
     * Returns a Headers object consisting of the headers associated with request. Note that headers added in the network layer by the user agent will not be accounted for in this object, e.g., the "Host" header.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/headers)
     */
    headers: Headers;
    /**
     * Returns the redirect mode associated with request, which is a string indicating how redirects for the request will be handled during fetching. A request will follow redirects by default.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/redirect)
     */
    redirect: string;
    fetcher: Fetcher | null;
    /**
     * Returns the signal associated with request, which is an AbortSignal object indicating whether or not request has been aborted, and its abort event handler.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/signal)
     */
    signal: AbortSignal;
    cf: Cf | undefined;
    /**
     * Returns request's subresource integrity metadata, which is a cryptographic hash of the resource being fetched. Its value consists of multiple hashes separated by whitespace. [SRI]
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/integrity)
     */
    integrity: string;
    /**
     * Returns a boolean indicating whether or not request can outlive the global in which it was created.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/keepalive)
     */
    keepalive: boolean;
    /**
     * Returns the cache mode associated with request, which is a string indicating how the request will interact with the browser's cache when fetching.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/Request/cache)
     */
    cache?: "no-store" | "no-cache";
}
interface RequestInit<Cf = CfProperties> {
    /* A string to set request's method. */
    method?: string;
    /* A Headers object, an object literal, or an array of two-item arrays to set request's headers. */
    headers?: HeadersInit;
    /* A BodyInit object or null to set request's body. */
    body?: BodyInit | null;
    /* A string indicating whether request follows redirects, results in an error upon encountering a redirect, or returns the redirect (in an opaque fashion). Sets request's redirect. */
    redirect?: string;
    fetcher?: (Fetcher | null);
    cf?: Cf;
    /* A string indicating how the request will interact with the browser's cache to set request's cache. */
    cache?: "no-store" | "no-cache";
    /* A cryptographic hash of the resource to be fetched by request. Sets request's integrity. */
    integrity?: string;
    /* An AbortSignal to set request's signal. */
    signal?: (AbortSignal | null);
    encodeResponseBody?: "automatic" | "manual";
}
type Service<T extends (new (...args: any[]) => Rpc.WorkerEntrypointBranded) | Rpc.WorkerEntrypointBranded | ExportedHandler<any, any, any> | undefined = undefined> = T extends new (...args: any[]) => Rpc.WorkerEntrypointBranded ? Fetcher<InstanceType<T>> : T extends Rpc.WorkerEntrypointBranded ? Fetcher<T> : T extends Exclude<Rpc.EntrypointBranded, Rpc.WorkerEntrypointBranded> ? never : Fetcher<undefined>;
type Fetcher<T extends Rpc.EntrypointBranded | undefined = undefined, Reserved extends string = never> = (T extends Rpc.EntrypointBranded ? Rpc.Provider<T, Reserved | "fetch" | "connect"> : unknown) & {
    fetch(input: RequestInfo | URL, init?: RequestInit): Promise<Response>;
    connect(address: SocketAddress | string, options?: SocketOptions): Socket;
};
interface KVNamespaceListKey<Metadata, Key extends string = string> {
    name: Key;
    expiration?: number;
    metadata?: Metadata;
}
type KVNamespaceListResult<Metadata, Key extends string = string> = {
    list_complete: false;
    keys: KVNamespaceListKey<Metadata, Key>[];
    cursor: string;
    cacheStatus: string | null;
} | {
    list_complete: true;
    keys: KVNamespaceListKey<Metadata, Key>[];
    cacheStatus: string | null;
};
interface KVNamespace<Key extends string = string> {
    get(key: Key, options?: Partial<KVNamespaceGetOptions<undefined>>): Promise<string | null>;
    get(key: Key, type: "text"): Promise<string | null>;
    get<ExpectedValue = unknown>(key: Key, type: "json"): Promise<ExpectedValue | null>;
    get(key: Key, type: "arrayBuffer"): Promise<ArrayBuffer | null>;
    get(key: Key, type: "stream"): Promise<ReadableStream | null>;
    get(key: Key, options?: KVNamespaceGetOptions<"text">): Promise<string | null>;
    get<ExpectedValue = unknown>(key: Key, options?: KVNamespaceGetOptions<"json">): Promise<ExpectedValue | null>;
    get(key: Key, options?: KVNamespaceGetOptions<"arrayBuffer">): Promise<ArrayBuffer | null>;
    get(key: Key, options?: KVNamespaceGetOptions<"stream">): Promise<ReadableStream | null>;
    get(key: Array<Key>, type: "text"): Promise<Map<string, string | null>>;
    get<ExpectedValue = unknown>(key: Array<Key>, type: "json"): Promise<Map<string, ExpectedValue | null>>;
    get(key: Array<Key>, options?: Partial<KVNamespaceGetOptions<undefined>>): Promise<Map<string, string | null>>;
    get(key: Array<Key>, options?: KVNamespaceGetOptions<"text">): Promise<Map<string, string | null>>;
    get<ExpectedValue = unknown>(key: Array<Key>, options?: KVNamespaceGetOptions<"json">): Promise<Map<string, ExpectedValue | null>>;
    list<Metadata = unknown>(options?: KVNamespaceListOptions): Promise<KVNamespaceListResult<Metadata, Key>>;
    put(key: Key, value: string | ArrayBuffer | ArrayBufferView | ReadableStream, options?: KVNamespacePutOptions): Promise<void>;
    getWithMetadata<Metadata = unknown>(key: Key, options?: Partial<KVNamespaceGetOptions<undefined>>): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;
    getWithMetadata<Metadata = unknown>(key: Key, type: "text"): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;
    getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(key: Key, type: "json"): Promise<KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>;
    getWithMetadata<Metadata = unknown>(key: Key, type: "arrayBuffer"): Promise<KVNamespaceGetWithMetadataResult<ArrayBuffer, Metadata>>;
    getWithMetadata<Metadata = unknown>(key: Key, type: "stream"): Promise<KVNamespaceGetWithMetadataResult<ReadableStream, Metadata>>;
    getWithMetadata<Metadata = unknown>(key: Key, options: KVNamespaceGetOptions<"text">): Promise<KVNamespaceGetWithMetadataResult<string, Metadata>>;
    getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(key: Key, options: KVNamespaceGetOptions<"json">): Promise<KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>;
    getWithMetadata<Metadata = unknown>(key: Key, options: KVNamespaceGetOptions<"arrayBuffer">): Promise<KVNamespaceGetWithMetadataResult<ArrayBuffer, Metadata>>;
    getWithMetadata<Metadata = unknown>(key: Key, options: KVNamespaceGetOptions<"stream">): Promise<KVNamespaceGetWithMetadataResult<ReadableStream, Metadata>>;
    getWithMetadata<Metadata = unknown>(key: Array<Key>, type: "text"): Promise<Map<string, KVNamespaceGetWithMetadataResult<string, Metadata>>>;
    getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(key: Array<Key>, type: "json"): Promise<Map<string, KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>>;
    getWithMetadata<Metadata = unknown>(key: Array<Key>, options?: Partial<KVNamespaceGetOptions<undefined>>): Promise<Map<string, KVNamespaceGetWithMetadataResult<string, Metadata>>>;
    getWithMetadata<Metadata = unknown>(key: Array<Key>, options?: KVNamespaceGetOptions<"text">): Promise<Map<string, KVNamespaceGetWithMetadataResult<string, Metadata>>>;
    getWithMetadata<ExpectedValue = unknown, Metadata = unknown>(key: Array<Key>, options?: KVNamespaceGetOptions<"json">): Promise<Map<string, KVNamespaceGetWithMetadataResult<ExpectedValue, Metadata>>>;
    delete(key: Key): Promise<void>;
}
interface KVNamespaceListOptions {
    limit?: number;
    prefix?: (string | null);
    cursor?: (string | null);
}
interface KVNamespaceGetOptions<Type> {
    type: Type;
    cacheTtl?: number;
}
interface KVNamespacePutOptions {
    expiration?: number;
    expirationTtl?: number;
    metadata?: (any | null);
}
interface KVNamespaceGetWithMetadataResult<Value, Metadata> {
    value: Value | null;
    metadata: Metadata | null;
    cacheStatus: string | null;
}
type QueueContentType = "text" | "bytes" | "json" | "v8";
interface Queue<Body = unknown> {
    send(message: Body, options?: QueueSendOptions): Promise<void>;
    sendBatch(messages: Iterable<MessageSendRequest<Body>>, options?: QueueSendBatchOptions): Promise<void>;
}
interface QueueSendOptions {
    contentType?: QueueContentType;
    delaySeconds?: number;
}
interface QueueSendBatchOptions {
    delaySeconds?: number;
}
interface MessageSendRequest<Body = unknown> {
    body: Body;
    contentType?: QueueContentType;
    delaySeconds?: number;
}
interface QueueRetryOptions {
    delaySeconds?: number;
}
interface Message<Body = unknown> {
    readonly id: string;
    readonly timestamp: Date;
    readonly body: Body;
    readonly attempts: number;
    retry(options?: QueueRetryOptions): void;
    ack(): void;
}
interface QueueEvent<Body = unknown> extends ExtendableEvent {
    readonly messages: readonly Message<Body>[];
    readonly queue: string;
    retryAll(options?: QueueRetryOptions): void;
    ackAll(): void;
}
interface MessageBatch<Body = unknown> {
    readonly messages: readonly Message<Body>[];
    readonly queue: string;
    retryAll(options?: QueueRetryOptions): void;
    ackAll(): void;
}
interface R2Error extends Error {
    readonly name: string;
    readonly code: number;
    readonly message: string;
    readonly action: string;
    readonly stack: any;
}
interface R2ListOptions {
    limit?: number;
    prefix?: string;
    cursor?: string;
    delimiter?: string;
    startAfter?: string;
    include?: ("httpMetadata" | "customMetadata")[];
}
declare abstract class R2Bucket {
    head(key: string): Promise<R2Object | null>;
    get(key: string, options: R2GetOptions & {
        onlyIf: R2Conditional | Headers;
    }): Promise<R2ObjectBody | R2Object | null>;
    get(key: string, options?: R2GetOptions): Promise<R2ObjectBody | null>;
    put(key: string, value: ReadableStream | ArrayBuffer | ArrayBufferView | string | null | Blob, options?: R2PutOptions & {
        onlyIf: R2Conditional | Headers;
    }): Promise<R2Object | null>;
    put(key: string, value: ReadableStream | ArrayBuffer | ArrayBufferView | string | null | Blob, options?: R2PutOptions): Promise<R2Object>;
    createMultipartUpload(key: string, options?: R2MultipartOptions): Promise<R2MultipartUpload>;
    resumeMultipartUpload(key: string, uploadId: string): R2MultipartUpload;
    delete(keys: string | string[]): Promise<void>;
    list(options?: R2ListOptions): Promise<R2Objects>;
}
interface R2MultipartUpload {
    readonly key: string;
    readonly uploadId: string;
    uploadPart(partNumber: number, value: ReadableStream | (ArrayBuffer | ArrayBufferView) | string | Blob, options?: R2UploadPartOptions): Promise<R2UploadedPart>;
    abort(): Promise<void>;
    complete(uploadedParts: R2UploadedPart[]): Promise<R2Object>;
}
interface R2UploadedPart {
    partNumber: number;
    etag: string;
}
declare abstract class R2Object {
    readonly key: string;
    readonly version: string;
    readonly size: number;
    readonly etag: string;
    readonly httpEtag: string;
    readonly checksums: R2Checksums;
    readonly uploaded: Date;
    readonly httpMetadata?: R2HTTPMetadata;
    readonly customMetadata?: Record<string, string>;
    readonly range?: R2Range;
    readonly storageClass: string;
    readonly ssecKeyMd5?: string;
    writeHttpMetadata(headers: Headers): void;
}
interface R2ObjectBody extends R2Object {
    get body(): ReadableStream;
    get bodyUsed(): boolean;
    arrayBuffer(): Promise<ArrayBuffer>;
    bytes(): Promise<Uint8Array>;
    text(): Promise<string>;
    json<T>(): Promise<T>;
    blob(): Promise<Blob>;
}
type R2Range = {
    offset: number;
    length?: number;
} | {
    offset?: number;
    length: number;
} | {
    suffix: number;
};
interface R2Conditional {
    etagMatches?: string;
    etagDoesNotMatch?: string;
    uploadedBefore?: Date;
    uploadedAfter?: Date;
    secondsGranularity?: boolean;
}
interface R2GetOptions {
    onlyIf?: (R2Conditional | Headers);
    range?: (R2Range | Headers);
    ssecKey?: (ArrayBuffer | string);
}
interface R2PutOptions {
    onlyIf?: (R2Conditional | Headers);
    httpMetadata?: (R2HTTPMetadata | Headers);
    customMetadata?: Record<string, string>;
    md5?: ((ArrayBuffer | ArrayBufferView) | string);
    sha1?: ((ArrayBuffer | ArrayBufferView) | string);
    sha256?: ((ArrayBuffer | ArrayBufferView) | string);
    sha384?: ((ArrayBuffer | ArrayBufferView) | string);
    sha512?: ((ArrayBuffer | ArrayBufferView) | string);
    storageClass?: string;
    ssecKey?: (ArrayBuffer | string);
}
interface R2MultipartOptions {
    httpMetadata?: (R2HTTPMetadata | Headers);
    customMetadata?: Record<string, string>;
    storageClass?: string;
    ssecKey?: (ArrayBuffer | string);
}
interface R2Checksums {
    readonly md5?: ArrayBuffer;
    readonly sha1?: ArrayBuffer;
    readonly sha256?: ArrayBuffer;
    readonly sha384?: ArrayBuffer;
    readonly sha512?: ArrayBuffer;
    toJSON(): R2StringChecksums;
}
interface R2StringChecksums {
    md5?: string;
    sha1?: string;
    sha256?: string;
    sha384?: string;
    sha512?: string;
}
interface R2HTTPMetadata {
    contentType?: string;
    contentLanguage?: string;
    contentDisposition?: string;
    contentEncoding?: string;
    cacheControl?: string;
    cacheExpiry?: Date;
}
type R2Objects = {
    objects: R2Object[];
    delimitedPrefixes: string[];
} & ({
    truncated: true;
    cursor: string;
} | {
    truncated: false;
});
interface R2UploadPartOptions {
    ssecKey?: (ArrayBuffer | string);
}
declare abstract class ScheduledEvent extends ExtendableEvent {
    readonly scheduledTime: number;
    readonly cron: string;
    noRetry(): void;
}
interface ScheduledController {
    readonly scheduledTime: number;
    readonly cron: string;
    noRetry(): void;
}
interface QueuingStrategy<T = any> {
    highWaterMark?: (number | bigint);
    size?: (chunk: T) => number | bigint;
}
interface UnderlyingSink<W = any> {
    type?: string;
    start?: (controller: WritableStreamDefaultController) => void | Promise<void>;
    write?: (chunk: W, controller: WritableStreamDefaultController) => void | Promise<void>;
    abort?: (reason: any) => void | Promise<void>;
    close?: () => void | Promise<void>;
}
interface UnderlyingByteSource {
    type: "bytes";
    autoAllocateChunkSize?: number;
    start?: (controller: ReadableByteStreamController) => void | Promise<void>;
    pull?: (controller: ReadableByteStreamController) => void | Promise<void>;
    cancel?: (reason: any) => void | Promise<void>;
}
interface UnderlyingSource<R = any> {
    type?: "" | undefined;
    start?: (controller: ReadableStreamDefaultController<R>) => void | Promise<void>;
    pull?: (controller: ReadableStreamDefaultController<R>) => void | Promise<void>;
    cancel?: (reason: any) => void | Promise<void>;
    expectedLength?: (number | bigint);
}
interface Transformer<I = any, O = any> {
    readableType?: string;
    writableType?: string;
    start?: (controller: TransformStreamDefaultController<O>) => void | Promise<void>;
    transform?: (chunk: I, controller: TransformStreamDefaultController<O>) => void | Promise<void>;
    flush?: (controller: TransformStreamDefaultController<O>) => void | Promise<void>;
    cancel?: (reason: any) => void | Promise<void>;
    expectedLength?: number;
}
interface StreamPipeOptions {
    /**
     * Pipes this readable stream to a given writable stream destination. The way in which the piping process behaves under various error conditions can be customized with a number of passed options. It returns a promise that fulfills when the piping process completes successfully, or rejects if any errors were encountered.
     *
     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
     *
     * Errors and closures of the source and destination streams propagate as follows:
     *
     * An error in this source readable stream will abort destination, unless preventAbort is truthy. The returned promise will be rejected with the source's error, or with any error that occurs during aborting the destination.
     *
     * An error in destination will cancel this source readable stream, unless preventCancel is truthy. The returned promise will be rejected with the destination's error, or with any error that occurs during canceling the source.
     *
     * When this source readable stream closes, destination will be closed, unless preventClose is truthy. The returned promise will be fulfilled once this process completes, unless an error is encountered while closing the destination, in which case it will be rejected with that error.
     *
     * If destination starts out closed or closing, this source readable stream will be canceled, unless preventCancel is true. The returned promise will be rejected with an error indicating piping to a closed stream failed, or with any error that occurs during canceling the source.
     *
     * The signal option can be set to an AbortSignal to allow aborting an ongoing pipe operation via the corresponding AbortController. In this case, this source readable stream will be canceled, and destination aborted, unless the respective options preventCancel or preventAbort are set.
     */
    preventClose?: boolean;
    preventAbort?: boolean;
    preventCancel?: boolean;
    signal?: AbortSignal;
}
type ReadableStreamReadResult<R = any> = {
    done: false;
    value: R;
} | {
    done: true;
    value?: undefined;
};
/**
 * This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)
 */
interface ReadableStream<R = any> {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/locked) */
    get locked(): boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/cancel) */
    cancel(reason?: any): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/getReader) */
    getReader(): ReadableStreamDefaultReader<R>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/getReader) */
    getReader(options: ReadableStreamGetReaderOptions): ReadableStreamBYOBReader;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/pipeThrough) */
    pipeThrough<T>(transform: ReadableWritablePair<T, R>, options?: StreamPipeOptions): ReadableStream<T>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/pipeTo) */
    pipeTo(destination: WritableStream<R>, options?: StreamPipeOptions): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream/tee) */
    tee(): [
        ReadableStream<R>,
        ReadableStream<R>
    ];
    values(options?: ReadableStreamValuesOptions): AsyncIterableIterator<R>;
    [Symbol.asyncIterator](options?: ReadableStreamValuesOptions): AsyncIterableIterator<R>;
}
/**
 * This Streams API interface represents a readable stream of byte data. The Fetch API offers a concrete instance of a ReadableStream through the body property of a Response object.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStream)
 */
declare const ReadableStream: {
    prototype: ReadableStream;
    new (underlyingSource: UnderlyingByteSource, strategy?: QueuingStrategy<Uint8Array>): ReadableStream<Uint8Array>;
    new <R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>;
};
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader) */
declare class ReadableStreamDefaultReader<R = any> {
    constructor(stream: ReadableStream);
    get closed(): Promise<void>;
    cancel(reason?: any): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader/read) */
    read(): Promise<ReadableStreamReadResult<R>>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultReader/releaseLock) */
    releaseLock(): void;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader) */
declare class ReadableStreamBYOBReader {
    constructor(stream: ReadableStream);
    get closed(): Promise<void>;
    cancel(reason?: any): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/read) */
    read<T extends ArrayBufferView>(view: T): Promise<ReadableStreamReadResult<T>>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBReader/releaseLock) */
    releaseLock(): void;
    readAtLeast<T extends ArrayBufferView>(minElements: number, view: T): Promise<ReadableStreamReadResult<T>>;
}
interface ReadableStreamBYOBReaderReadableStreamBYOBReaderReadOptions {
    min?: number;
}
interface ReadableStreamGetReaderOptions {
    /**
     * Creates a ReadableStreamBYOBReader and locks the stream to the new reader.
     *
     * This call behaves the same way as the no-argument variant, except that it only works on readable byte streams, i.e. streams which were constructed specifically with the ability to handle "bring your own buffer" reading. The returned BYOB reader provides the ability to directly read individual chunks from the stream via its read() method, into developer-supplied buffers, allowing more precise control over allocation.
     */
    mode: "byob";
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest) */
declare abstract class ReadableStreamBYOBRequest {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/view) */
    get view(): Uint8Array | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respond) */
    respond(bytesWritten: number): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamBYOBRequest/respondWithNewView) */
    respondWithNewView(view: ArrayBuffer | ArrayBufferView): void;
    get atLeast(): number | null;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController) */
declare abstract class ReadableStreamDefaultController<R = any> {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/desiredSize) */
    get desiredSize(): number | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/close) */
    close(): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/enqueue) */
    enqueue(chunk?: R): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableStreamDefaultController/error) */
    error(reason: any): void;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController) */
declare abstract class ReadableByteStreamController {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/byobRequest) */
    get byobRequest(): ReadableStreamBYOBRequest | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/desiredSize) */
    get desiredSize(): number | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/close) */
    close(): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/enqueue) */
    enqueue(chunk: ArrayBuffer | ArrayBufferView): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ReadableByteStreamController/error) */
    error(reason: any): void;
}
/**
 * This Streams API interface represents a controller allowing control of a WritableStream's state. When constructing a WritableStream, the underlying sink is given a corresponding WritableStreamDefaultController instance to manipulate.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController)
 */
declare abstract class WritableStreamDefaultController {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController/signal) */
    get signal(): AbortSignal;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultController/error) */
    error(reason?: any): void;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController) */
declare abstract class TransformStreamDefaultController<O = any> {
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/desiredSize) */
    get desiredSize(): number | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/enqueue) */
    enqueue(chunk?: O): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/error) */
    error(reason: any): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStreamDefaultController/terminate) */
    terminate(): void;
}
interface ReadableWritablePair<R = any, W = any> {
    /**
     * Provides a convenient, chainable way of piping this readable stream through a transform stream (or any other { writable, readable } pair). It simply pipes the stream into the writable side of the supplied pair, and returns the readable side for further use.
     *
     * Piping a stream will lock it for the duration of the pipe, preventing any other consumer from acquiring a reader.
     */
    writable: WritableStream<W>;
    readable: ReadableStream<R>;
}
/**
 * This Streams API interface provides a standard abstraction for writing streaming data to a destination, known as a sink. This object comes with built-in backpressure and queuing.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream)
 */
declare class WritableStream<W = any> {
    constructor(underlyingSink?: UnderlyingSink, queuingStrategy?: QueuingStrategy);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/locked) */
    get locked(): boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/abort) */
    abort(reason?: any): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/close) */
    close(): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStream/getWriter) */
    getWriter(): WritableStreamDefaultWriter<W>;
}
/**
 * This Streams API interface is the object returned by WritableStream.getWriter() and once created locks the < writer to the WritableStream ensuring that no other streams can write to the underlying sink.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter)
 */
declare class WritableStreamDefaultWriter<W = any> {
    constructor(stream: WritableStream);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/closed) */
    get closed(): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/ready) */
    get ready(): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/desiredSize) */
    get desiredSize(): number | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/abort) */
    abort(reason?: any): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/close) */
    close(): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/write) */
    write(chunk?: W): Promise<void>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/WritableStreamDefaultWriter/releaseLock) */
    releaseLock(): void;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream) */
declare class TransformStream<I = any, O = any> {
    constructor(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream/readable) */
    get readable(): ReadableStream<O>;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TransformStream/writable) */
    get writable(): WritableStream<I>;
}
declare class FixedLengthStream extends IdentityTransformStream {
    constructor(expectedLength: number | bigint, queuingStrategy?: IdentityTransformStreamQueuingStrategy);
}
declare class IdentityTransformStream extends TransformStream<ArrayBuffer | ArrayBufferView, Uint8Array> {
    constructor(queuingStrategy?: IdentityTransformStreamQueuingStrategy);
}
interface IdentityTransformStreamQueuingStrategy {
    highWaterMark?: (number | bigint);
}
interface ReadableStreamValuesOptions {
    preventCancel?: boolean;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CompressionStream) */
declare class CompressionStream extends TransformStream<ArrayBuffer | ArrayBufferView, Uint8Array> {
    constructor(format: "gzip" | "deflate" | "deflate-raw");
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/DecompressionStream) */
declare class DecompressionStream extends TransformStream<ArrayBuffer | ArrayBufferView, Uint8Array> {
    constructor(format: "gzip" | "deflate" | "deflate-raw");
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextEncoderStream) */
declare class TextEncoderStream extends TransformStream<string, Uint8Array> {
    constructor();
    get encoding(): string;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/TextDecoderStream) */
declare class TextDecoderStream extends TransformStream<ArrayBuffer | ArrayBufferView, string> {
    constructor(label?: string, options?: TextDecoderStreamTextDecoderStreamInit);
    get encoding(): string;
    get fatal(): boolean;
    get ignoreBOM(): boolean;
}
interface TextDecoderStreamTextDecoderStreamInit {
    fatal?: boolean;
    ignoreBOM?: boolean;
}
/**
 * This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy)
 */
declare class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {
    constructor(init: QueuingStrategyInit);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy/highWaterMark) */
    get highWaterMark(): number;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/ByteLengthQueuingStrategy/size) */
    get size(): (chunk?: any) => number;
}
/**
 * This Streams API interface provides a built-in byte length queuing strategy that can be used when constructing streams.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy)
 */
declare class CountQueuingStrategy implements QueuingStrategy {
    constructor(init: QueuingStrategyInit);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy/highWaterMark) */
    get highWaterMark(): number;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/CountQueuingStrategy/size) */
    get size(): (chunk?: any) => number;
}
interface QueuingStrategyInit {
    /**
     * Creates a new ByteLengthQueuingStrategy with the provided high water mark.
     *
     * Note that the provided high water mark will not be validated ahead of time. Instead, if it is negative, NaN, or not a number, the resulting ByteLengthQueuingStrategy will cause the corresponding stream constructor to throw.
     */
    highWaterMark: number;
}
interface ScriptVersion {
    id?: string;
    tag?: string;
    message?: string;
}
declare abstract class TailEvent extends ExtendableEvent {
    readonly events: TraceItem[];
    readonly traces: TraceItem[];
}
interface TraceItem {
    readonly event: (TraceItemFetchEventInfo | TraceItemJsRpcEventInfo | TraceItemScheduledEventInfo | TraceItemAlarmEventInfo | TraceItemQueueEventInfo | TraceItemEmailEventInfo | TraceItemTailEventInfo | TraceItemCustomEventInfo | TraceItemHibernatableWebSocketEventInfo) | null;
    readonly eventTimestamp: number | null;
    readonly logs: TraceLog[];
    readonly exceptions: TraceException[];
    readonly diagnosticsChannelEvents: TraceDiagnosticChannelEvent[];
    readonly scriptName: string | null;
    readonly entrypoint?: string;
    readonly scriptVersion?: ScriptVersion;
    readonly dispatchNamespace?: string;
    readonly scriptTags?: string[];
    readonly durableObjectId?: string;
    readonly outcome: string;
    readonly executionModel: string;
    readonly truncated: boolean;
    readonly cpuTime: number;
    readonly wallTime: number;
}
interface TraceItemAlarmEventInfo {
    readonly scheduledTime: Date;
}
interface TraceItemCustomEventInfo {
}
interface TraceItemScheduledEventInfo {
    readonly scheduledTime: number;
    readonly cron: string;
}
interface TraceItemQueueEventInfo {
    readonly queue: string;
    readonly batchSize: number;
}
interface TraceItemEmailEventInfo {
    readonly mailFrom: string;
    readonly rcptTo: string;
    readonly rawSize: number;
}
interface TraceItemTailEventInfo {
    readonly consumedEvents: TraceItemTailEventInfoTailItem[];
}
interface TraceItemTailEventInfoTailItem {
    readonly scriptName: string | null;
}
interface TraceItemFetchEventInfo {
    readonly response?: TraceItemFetchEventInfoResponse;
    readonly request: TraceItemFetchEventInfoRequest;
}
interface TraceItemFetchEventInfoRequest {
    readonly cf?: any;
    readonly headers: Record<string, string>;
    readonly method: string;
    readonly url: string;
    getUnredacted(): TraceItemFetchEventInfoRequest;
}
interface TraceItemFetchEventInfoResponse {
    readonly status: number;
}
interface TraceItemJsRpcEventInfo {
    readonly rpcMethod: string;
}
interface TraceItemHibernatableWebSocketEventInfo {
    readonly getWebSocketEvent: TraceItemHibernatableWebSocketEventInfoMessage | TraceItemHibernatableWebSocketEventInfoClose | TraceItemHibernatableWebSocketEventInfoError;
}
interface TraceItemHibernatableWebSocketEventInfoMessage {
    readonly webSocketEventType: string;
}
interface TraceItemHibernatableWebSocketEventInfoClose {
    readonly webSocketEventType: string;
    readonly code: number;
    readonly wasClean: boolean;
}
interface TraceItemHibernatableWebSocketEventInfoError {
    readonly webSocketEventType: string;
}
interface TraceLog {
    readonly timestamp: number;
    readonly level: string;
    readonly message: any;
}
interface TraceException {
    readonly timestamp: number;
    readonly message: string;
    readonly name: string;
    readonly stack?: string;
}
interface TraceDiagnosticChannelEvent {
    readonly timestamp: number;
    readonly channel: string;
    readonly message: any;
}
interface TraceMetrics {
    readonly cpuTime: number;
    readonly wallTime: number;
}
interface UnsafeTraceMetrics {
    fromTrace(item: TraceItem): TraceMetrics;
}
/**
 * The URL interface represents an object providing static methods used for creating object URLs.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL)
 */
declare class URL {
    constructor(url: string | URL, base?: string | URL);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/origin) */
    get origin(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/href) */
    get href(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/href) */
    set href(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/protocol) */
    get protocol(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/protocol) */
    set protocol(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/username) */
    get username(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/username) */
    set username(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/password) */
    get password(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/password) */
    set password(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/host) */
    get host(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/host) */
    set host(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hostname) */
    get hostname(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hostname) */
    set hostname(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/port) */
    get port(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/port) */
    set port(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/pathname) */
    get pathname(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/pathname) */
    set pathname(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/search) */
    get search(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/search) */
    set search(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hash) */
    get hash(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/hash) */
    set hash(value: string);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/searchParams) */
    get searchParams(): URLSearchParams;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/toJSON) */
    toJSON(): string;
    /*function toString() { [native code] }*/
    toString(): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/canParse_static) */
    static canParse(url: string, base?: string): boolean;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/parse_static) */
    static parse(url: string, base?: string): URL | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/createObjectURL_static) */
    static createObjectURL(object: File | Blob): string;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URL/revokeObjectURL_static) */
    static revokeObjectURL(object_url: string): void;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams) */
declare class URLSearchParams {
    constructor(init?: (Iterable<Iterable<string>> | Record<string, string> | string));
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/size) */
    get size(): number;
    /**
     * Appends a specified key/value pair as a new search parameter.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/append)
     */
    append(name: string, value: string): void;
    /**
     * Deletes the given search parameter, and its associated value, from the list of all search parameters.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/delete)
     */
    delete(name: string, value?: string): void;
    /**
     * Returns the first value associated to the given search parameter.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/get)
     */
    get(name: string): string | null;
    /**
     * Returns all the values association with a given search parameter.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/getAll)
     */
    getAll(name: string): string[];
    /**
     * Returns a Boolean indicating if such a search parameter exists.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/has)
     */
    has(name: string, value?: string): boolean;
    /**
     * Sets the value associated to a given search parameter to the given value. If there were several values, delete the others.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/set)
     */
    set(name: string, value: string): void;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/URLSearchParams/sort) */
    sort(): void;
    /* Returns an array of key, value pairs for every entry in the search params. */
    entries(): IterableIterator<[
        key: string,
        value: string
    ]>;
    /* Returns a list of keys in the search params. */
    keys(): IterableIterator<string>;
    /* Returns a list of values in the search params. */
    values(): IterableIterator<string>;
    forEach<This = unknown>(callback: (this: This, value: string, key: string, parent: URLSearchParams) => void, thisArg?: This): void;
    /*function toString() { [native code] } Returns a string containing a query string suitable for use in a URL. Does not include the question mark. */
    toString(): string;
    [Symbol.iterator](): IterableIterator<[
        key: string,
        value: string
    ]>;
}
declare class URLPattern {
    constructor(input?: (string | URLPatternInit), baseURL?: (string | URLPatternOptions), patternOptions?: URLPatternOptions);
    get protocol(): string;
    get username(): string;
    get password(): string;
    get hostname(): string;
    get port(): string;
    get pathname(): string;
    get search(): string;
    get hash(): string;
    get hasRegExpGroups(): boolean;
    test(input?: (string | URLPatternInit), baseURL?: string): boolean;
    exec(input?: (string | URLPatternInit), baseURL?: string): URLPatternResult | null;
}
interface URLPatternInit {
    protocol?: string;
    username?: string;
    password?: string;
    hostname?: string;
    port?: string;
    pathname?: string;
    search?: string;
    hash?: string;
    baseURL?: string;
}
interface URLPatternComponentResult {
    input: string;
    groups: Record<string, string>;
}
interface URLPatternResult {
    inputs: (string | URLPatternInit)[];
    protocol: URLPatternComponentResult;
    username: URLPatternComponentResult;
    password: URLPatternComponentResult;
    hostname: URLPatternComponentResult;
    port: URLPatternComponentResult;
    pathname: URLPatternComponentResult;
    search: URLPatternComponentResult;
    hash: URLPatternComponentResult;
}
interface URLPatternOptions {
    ignoreCase?: boolean;
}
/**
 * A CloseEvent is sent to clients using WebSockets when the connection is closed. This is delivered to the listener indicated by the WebSocket object's onclose attribute.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent)
 */
declare class CloseEvent extends Event {
    constructor(type: string, initializer?: CloseEventInit);
    /**
     * Returns the WebSocket connection close code provided by the server.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/code)
     */
    readonly code: number;
    /**
     * Returns the WebSocket connection close reason provided by the server.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/reason)
     */
    readonly reason: string;
    /**
     * Returns true if the connection closed cleanly; false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/CloseEvent/wasClean)
     */
    readonly wasClean: boolean;
}
interface CloseEventInit {
    code?: number;
    reason?: string;
    wasClean?: boolean;
}
type WebSocketEventMap = {
    close: CloseEvent;
    message: MessageEvent;
    open: Event;
    error: ErrorEvent;
};
/**
 * Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)
 */
declare var WebSocket: {
    prototype: WebSocket;
    new (url: string, protocols?: (string[] | string)): WebSocket;
    readonly READY_STATE_CONNECTING: number;
    readonly CONNECTING: number;
    readonly READY_STATE_OPEN: number;
    readonly OPEN: number;
    readonly READY_STATE_CLOSING: number;
    readonly CLOSING: number;
    readonly READY_STATE_CLOSED: number;
    readonly CLOSED: number;
};
/**
 * Provides the API for creating and managing a WebSocket connection to a server, as well as for sending and receiving data on the connection.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket)
 */
interface WebSocket extends EventTarget<WebSocketEventMap> {
    accept(): void;
    /**
     * Transmits data using the WebSocket connection. data can be a string, a Blob, an ArrayBuffer, or an ArrayBufferView.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/send)
     */
    send(message: (ArrayBuffer | ArrayBufferView) | string): void;
    /**
     * Closes the WebSocket connection, optionally using code as the the WebSocket connection close code and reason as the the WebSocket connection close reason.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/close)
     */
    close(code?: number, reason?: string): void;
    serializeAttachment(attachment: any): void;
    deserializeAttachment(): any | null;
    /**
     * Returns the state of the WebSocket object's connection. It can have the values described below.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/readyState)
     */
    readyState: number;
    /**
     * Returns the URL that was used to establish the WebSocket connection.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/url)
     */
    url: string | null;
    /**
     * Returns the subprotocol selected by the server, if any. It can be used in conjunction with the array form of the constructor's second argument to perform subprotocol negotiation.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/protocol)
     */
    protocol: string | null;
    /**
     * Returns the extensions selected by the server, if any.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/WebSocket/extensions)
     */
    extensions: string | null;
}
declare const WebSocketPair: {
    new (): {
        0: WebSocket;
        1: WebSocket;
    };
};
interface SqlStorage {
    exec<T extends Record<string, SqlStorageValue>>(query: string, ...bindings: any[]): SqlStorageCursor<T>;
    get databaseSize(): number;
    Cursor: typeof SqlStorageCursor;
    Statement: typeof SqlStorageStatement;
}
declare abstract class SqlStorageStatement {
}
type SqlStorageValue = ArrayBuffer | string | number | null;
declare abstract class SqlStorageCursor<T extends Record<string, SqlStorageValue>> {
    next(): {
        done?: false;
        value: T;
    } | {
        done: true;
        value?: never;
    };
    toArray(): T[];
    one(): T;
    raw<U extends SqlStorageValue[]>(): IterableIterator<U>;
    columnNames: string[];
    get rowsRead(): number;
    get rowsWritten(): number;
    [Symbol.iterator](): IterableIterator<T>;
}
interface Socket {
    get readable(): ReadableStream;
    get writable(): WritableStream;
    get closed(): Promise<void>;
    get opened(): Promise<SocketInfo>;
    get upgraded(): boolean;
    get secureTransport(): "on" | "off" | "starttls";
    close(): Promise<void>;
    startTls(options?: TlsOptions): Socket;
}
interface SocketOptions {
    secureTransport?: string;
    allowHalfOpen: boolean;
    highWaterMark?: (number | bigint);
}
interface SocketAddress {
    hostname: string;
    port: number;
}
interface TlsOptions {
    expectedServerHostname?: string;
}
interface SocketInfo {
    remoteAddress?: string;
    localAddress?: string;
}
/* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource) */
declare class EventSource extends EventTarget {
    constructor(url: string, init?: EventSourceEventSourceInit);
    /**
     * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
     */
    close(): void;
    /**
     * Returns the URL providing the event stream.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
     */
    get url(): string;
    /**
     * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
     */
    get withCredentials(): boolean;
    /**
     * Returns the state of this EventSource object's connection. It can have the values described below.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
     */
    get readyState(): number;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
    get onopen(): any | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
    set onopen(value: any | null);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
    get onmessage(): any | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
    set onmessage(value: any | null);
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
    get onerror(): any | null;
    /* [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
    set onerror(value: any | null);
    static readonly CONNECTING: number;
    static readonly OPEN: number;
    static readonly CLOSED: number;
    static from(stream: ReadableStream): EventSource;
}
interface EventSourceEventSourceInit {
    withCredentials?: boolean;
    fetcher?: Fetcher;
}
interface Container {
    get running(): boolean;
    start(options?: ContainerStartupOptions): void;
    monitor(): Promise<void>;
    destroy(error?: any): Promise<void>;
    signal(signo: number): void;
    getTcpPort(port: number): Fetcher;
}
interface ContainerStartupOptions {
    entrypoint?: string[];
    enableInternet: boolean;
    env?: Record<string, string>;
}
/**
 * This Channel Messaging API interface represents one of the two ports of a MessageChannel, allowing messages to be sent from one port and listening out for them arriving at the other.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessagePort)
 */
declare abstract class MessagePort extends EventTarget {
    /**
     * Posts a message through the channel. Objects listed in transfer are transferred, not just cloned, meaning that they are no longer usable on the sending side.
     *
     * Throws a "DataCloneError" DOMException if transfer contains duplicate objects or port, or if message could not be cloned.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessagePort/postMessage)
     */
    postMessage(data?: any, options?: (any[] | MessagePortPostMessageOptions)): void;
    /**
     * Disconnects the port, so that it is no longer active.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessagePort/close)
     */
    close(): void;
    /**
     * Begins dispatching messages received on the port.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessagePort/start)
     */
    start(): void;
    get onmessage(): any | null;
    set onmessage(value: any | null);
}
/**
 * This Channel Messaging API interface allows us to create a new message channel and send data through it via its two MessagePort properties.
 *
 * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageChannel)
 */
declare class MessageChannel {
    constructor();
    /**
     * Returns the first MessagePort object.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageChannel/port1)
     */
    readonly port1: MessagePort;
    /**
     * Returns the second MessagePort object.
     *
     * [MDN Reference](https://developer.mozilla.org/docs/Web/API/MessageChannel/port2)
     */
    readonly port2: MessagePort;
}
interface MessagePortPostMessageOptions {
    transfer?: any[];
}
type LoopbackForExport<T extends (new (...args: any[]) => Rpc.EntrypointBranded) | ExportedHandler<any, any, any> | undefined = undefined> = T extends new (...args: any[]) => Rpc.WorkerEntrypointBranded ? LoopbackServiceStub<InstanceType<T>> : T extends new (...args: any[]) => Rpc.DurableObjectBranded ? LoopbackDurableObjectClass<InstanceType<T>> : T extends ExportedHandler<any, any, any> ? LoopbackServiceStub<undefined> : undefined;
type LoopbackServiceStub<T extends Rpc.WorkerEntrypointBranded | undefined = undefined> = Fetcher<T> & (T extends CloudflareWorkersModule.WorkerEntrypoint<any, infer Props> ? (opts: {
    props?: Props;
}) => Fetcher<T> : (opts: {
    props?: any;
}) => Fetcher<T>);
type LoopbackDurableObjectClass<T extends Rpc.DurableObjectBranded | undefined = undefined> = DurableObjectClass<T> & (T extends CloudflareWorkersModule.DurableObject<any, infer Props> ? (opts: {
    props?: Props;
}) => DurableObjectClass<T> : (opts: {
    props?: any;
}) => DurableObjectClass<T>);
interface SyncKvStorage {
    get<T = unknown>(key: string): T | undefined;
    list<T = unknown>(options?: SyncKvListOptions): Iterable<[
        string,
        T
    ]>;
    put<T>(key: string, value: T): void;
    delete(key: string): boolean;
}
interface SyncKvListOptions {
    start?: string;
    startAfter?: string;
    end?: string;
    prefix?: string;
    reverse?: boolean;
    limit?: number;
}
interface WorkerStub {
    getEntrypoint<T extends Rpc.WorkerEntrypointBranded | undefined>(name?: string, options?: WorkerStubEntrypointOptions): Fetcher<T>;
}
interface WorkerStubEntrypointOptions {
    props?: any;
}
interface WorkerLoader {
    get(name: string, getCode: () => WorkerLoaderWorkerCode | Promise<WorkerLoaderWorkerCode>): WorkerStub;
}
interface WorkerLoaderModule {
    js?: string;
    cjs?: string;
    text?: string;
    data?: ArrayBuffer;
    json?: any;
    py?: string;
}
interface WorkerLoaderWorkerCode {
    compatibilityDate: string;
    compatibilityFlags?: string[];
    allowExperimental?: boolean;
    mainModule: string;
    modules: Record<string, WorkerLoaderModule | string>;
    env?: any;
    globalOutbound?: (Fetcher | null);
    tails?: Fetcher[];
    streamingTails?: Fetcher[];
}
/**
* The Workers runtime supports a subset of the Performance API, used to measure timing and performance,
* as well as timing of subrequests and other operations.
*
* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/)
*/
declare abstract class Performance {
    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/#performancetimeorigin) */
    get timeOrigin(): number;
    /* [Cloudflare Docs Reference](https://developers.cloudflare.com/workers/runtime-apis/performance/#performancenow) */
    now(): number;
}
type AiImageClassificationInput = {
    image: number[];
};
type AiImageClassificationOutput = {
    score?: number;
    label?: string;
}[];
declare abstract class BaseAiImageClassification {
    inputs: AiImageClassificationInput;
    postProcessedOutputs: AiImageClassificationOutput;
}
type AiImageToTextInput = {
    image: number[];
    prompt?: string;
    max_tokens?: number;
    temperature?: number;
    top_p?: number;
    top_k?: number;
    seed?: number;
    repetition_penalty?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    raw?: boolean;
    messages?: RoleScopedChatInput[];
};
type AiImageToTextOutput = {
    description: string;
};
declare abstract class BaseAiImageToText {
    inputs: AiImageToTextInput;
    postProcessedOutputs: AiImageToTextOutput;
}
type AiImageTextToTextInput = {
    image: string;
    prompt?: string;
    max_tokens?: number;
    temperature?: number;
    ignore_eos?: boolean;
    top_p?: number;
    top_k?: number;
    seed?: number;
    repetition_penalty?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    raw?: boolean;
    messages?: RoleScopedChatInput[];
};
type AiImageTextToTextOutput = {
    description: string;
};
declare abstract class BaseAiImageTextToText {
    inputs: AiImageTextToTextInput;
    postProcessedOutputs: AiImageTextToTextOutput;
}
type AiMultimodalEmbeddingsInput = {
    image: string;
    text: string[];
};
type AiIMultimodalEmbeddingsOutput = {
    data: number[][];
    shape: number[];
};
declare abstract class BaseAiMultimodalEmbeddings {
    inputs: AiImageTextToTextInput;
    postProcessedOutputs: AiImageTextToTextOutput;
}
type AiObjectDetectionInput = {
    image: number[];
};
type AiObjectDetectionOutput = {
    score?: number;
    label?: string;
}[];
declare abstract class BaseAiObjectDetection {
    inputs: AiObjectDetectionInput;
    postProcessedOutputs: AiObjectDetectionOutput;
}
type AiSentenceSimilarityInput = {
    source: string;
    sentences: string[];
};
type AiSentenceSimilarityOutput = number[];
declare abstract class BaseAiSentenceSimilarity {
    inputs: AiSentenceSimilarityInput;
    postProcessedOutputs: AiSentenceSimilarityOutput;
}
type AiAutomaticSpeechRecognitionInput = {
    audio: number[];
};
type AiAutomaticSpeechRecognitionOutput = {
    text?: string;
    words?: {
        word: string;
        start: number;
        end: number;
    }[];
    vtt?: string;
};
declare abstract class BaseAiAutomaticSpeechRecognition {
    inputs: AiAutomaticSpeechRecognitionInput;
    postProcessedOutputs: AiAutomaticSpeechRecognitionOutput;
}
type AiSummarizationInput = {
    input_text: string;
    max_length?: number;
};
type AiSummarizationOutput = {
    summary: string;
};
declare abstract class BaseAiSummarization {
    inputs: AiSummarizationInput;
    postProcessedOutputs: AiSummarizationOutput;
}
type AiTextClassificationInput = {
    text: string;
};
type AiTextClassificationOutput = {
    score?: number;
    label?: string;
}[];
declare abstract class BaseAiTextClassification {
    inputs: AiTextClassificationInput;
    postProcessedOutputs: AiTextClassificationOutput;
}
type AiTextEmbeddingsInput = {
    text: string | string[];
};
type AiTextEmbeddingsOutput = {
    shape: number[];
    data: number[][];
};
declare abstract class BaseAiTextEmbeddings {
    inputs: AiTextEmbeddingsInput;
    postProcessedOutputs: AiTextEmbeddingsOutput;
}
type RoleScopedChatInput = {
    role: "user" | "assistant" | "system" | "tool" | (string & NonNullable<unknown>);
    content: string;
    name?: string;
};
type AiTextGenerationToolLegacyInput = {
    name: string;
    description: string;
    parameters?: {
        type: "object" | (string & NonNullable<unknown>);
        properties: {
            [key: string]: {
                type: string;
                description?: string;
            };
        };
        required: string[];
    };
};
type AiTextGenerationToolInput = {
    type: "function" | (string & NonNullable<unknown>);
    function: {
        name: string;
        description: string;
        parameters?: {
            type: "object" | (string & NonNullable<unknown>);
            properties: {
                [key: string]: {
                    type: string;
                    description?: string;
                };
            };
            required: string[];
        };
    };
};
type AiTextGenerationFunctionsInput = {
    name: string;
    code: string;
};
type AiTextGenerationResponseFormat = {
    type: string;
    json_schema?: any;
};
type AiTextGenerationInput = {
    prompt?: string;
    raw?: boolean;
    stream?: boolean;
    max_tokens?: number;
    temperature?: number;
    top_p?: number;
    top_k?: number;
    seed?: number;
    repetition_penalty?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    messages?: RoleScopedChatInput[];
    response_format?: AiTextGenerationResponseFormat;
    tools?: AiTextGenerationToolInput[] | AiTextGenerationToolLegacyInput[] | (object & NonNullable<unknown>);
    functions?: AiTextGenerationFunctionsInput[];
};
type AiTextGenerationToolLegacyOutput = {
    name: string;
    arguments: unknown;
};
type AiTextGenerationToolOutput = {
    id: string;
    type: "function";
    function: {
        name: string;
        arguments: string;
    };
};
type UsageTags = {
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
};
type AiTextGenerationOutput = {
    response?: string;
    tool_calls?: AiTextGenerationToolLegacyOutput[] & AiTextGenerationToolOutput[];
    usage?: UsageTags;
};
declare abstract class BaseAiTextGeneration {
    inputs: AiTextGenerationInput;
    postProcessedOutputs: AiTextGenerationOutput;
}
type AiTextToSpeechInput = {
    prompt: string;
    lang?: string;
};
type AiTextToSpeechOutput = Uint8Array | {
    audio: string;
};
declare abstract class BaseAiTextToSpeech {
    inputs: AiTextToSpeechInput;
    postProcessedOutputs: AiTextToSpeechOutput;
}
type AiTextToImageInput = {
    prompt: string;
    negative_prompt?: string;
    height?: number;
    width?: number;
    image?: number[];
    image_b64?: string;
    mask?: number[];
    num_steps?: number;
    strength?: number;
    guidance?: number;
    seed?: number;
};
type AiTextToImageOutput = ReadableStream<Uint8Array>;
declare abstract class BaseAiTextToImage {
    inputs: AiTextToImageInput;
    postProcessedOutputs: AiTextToImageOutput;
}
type AiTranslationInput = {
    text: string;
    target_lang: string;
    source_lang?: string;
};
type AiTranslationOutput = {
    translated_text?: string;
};
declare abstract class BaseAiTranslation {
    inputs: AiTranslationInput;
    postProcessedOutputs: AiTranslationOutput;
}
type Ai_Cf_Baai_Bge_Base_En_V1_5_Input = {
    text: string | string[];
    /**
     * The pooling method used in the embedding process. `cls` pooling will generate more accurate embeddings on larger inputs - however, embeddings created with cls pooling are not compatible with embeddings generated with mean pooling. The default pooling method is `mean` in order for this to not be a breaking change, but we highly suggest using the new `cls` pooling for better accuracy.
     */
    pooling?: "mean" | "cls";
} | {
    /**
     * Batch of the embeddings requests to run using async-queue
     */
    requests: {
        text: string | string[];
        /**
         * The pooling method used in the embedding process. `cls` pooling will generate more accurate embeddings on larger inputs - however, embeddings created with cls pooling are not compatible with embeddings generated with mean pooling. The default pooling method is `mean` in order for this to not be a breaking change, but we highly suggest using the new `cls` pooling for better accuracy.
         */
        pooling?: "mean" | "cls";
    }[];
};
type Ai_Cf_Baai_Bge_Base_En_V1_5_Output = {
    shape?: number[];
    /**
     * Embeddings of the requested text values
     */
    data?: number[][];
    /**
     * The pooling method used in the embedding process.
     */
    pooling?: "mean" | "cls";
} | AsyncResponse;
interface AsyncResponse {
    /**
     * The async request id that can be used to obtain the results.
     */
    request_id?: string;
}
declare abstract class Base_Ai_Cf_Baai_Bge_Base_En_V1_5 {
    inputs: Ai_Cf_Baai_Bge_Base_En_V1_5_Input;
    postProcessedOutputs: Ai_Cf_Baai_Bge_Base_En_V1_5_Output;
}
type Ai_Cf_Openai_Whisper_Input = string | {
    /**
     * An array of integers that represent the audio data constrained to 8-bit unsigned integer values
     */
    audio: number[];
};
interface Ai_Cf_Openai_Whisper_Output {
    /**
     * The transcription
     */
    text: string;
    word_count?: number;
    words?: {
        word?: string;
        /**
         * The second this word begins in the recording
         */
        start?: number;
        /**
         * The ending second when the word completes
         */
        end?: number;
    }[];
    vtt?: string;
}
declare abstract class Base_Ai_Cf_Openai_Whisper {
    inputs: Ai_Cf_Openai_Whisper_Input;
    postProcessedOutputs: Ai_Cf_Openai_Whisper_Output;
}
type Ai_Cf_Meta_M2M100_1_2B_Input = {
    /**
     * The text to be translated
     */
    text: string;
    /**
     * The language code of the source text (e.g., 'en' for English). Defaults to 'en' if not specified
     */
    source_lang?: string;
    /**
     * The language code to translate the text into (e.g., 'es' for Spanish)
     */
    target_lang: string;
} | {
    /**
     * Batch of the embeddings requests to run using async-queue
     */
    requests: {
        /**
         * The text to be translated
         */
        text: string;
        /**
         * The language code of the source text (e.g., 'en' for English). Defaults to 'en' if not specified
         */
        source_lang?: string;
        /**
         * The language code to translate the text into (e.g., 'es' for Spanish)
         */
        target_lang: string;
    }[];
};
type Ai_Cf_Meta_M2M100_1_2B_Output = {
    /**
     * The translated text in the target language
     */
    translated_text?: string;
} | AsyncResponse;
declare abstract class Base_Ai_Cf_Meta_M2M100_1_2B {
    inputs: Ai_Cf_Meta_M2M100_1_2B_Input;
    postProcessedOutputs: Ai_Cf_Meta_M2M100_1_2B_Output;
}
type Ai_Cf_Baai_Bge_Small_En_V1_5_Input = {
    text: string | string[];
    /**
     * The pooling method used in the embedding process. `cls` pooling will generate more accurate embeddings on larger inputs - however, embeddings created with cls pooling are not compatible with embeddings generated with mean pooling. The default pooling method is `mean` in order for this to not be a breaking change, but we highly suggest using the new `cls` pooling for better accuracy.
     */
    pooling?: "mean" | "cls";
} | {
    /**
     * Batch of the embeddings requests to run using async-queue
     */
    requests: {
        text: string | string[];
        /**
         * The pooling method used in the embedding process. `cls` pooling will generate more accurate embeddings on larger inputs - however, embeddings created with cls pooling are not compatible with embeddings generated with mean pooling. The default pooling method is `mean` in order for this to not be a breaking change, but we highly suggest using the new `cls` pooling for better accuracy.
         */
        pooling?: "mean" | "cls";
    }[];
};
type Ai_Cf_Baai_Bge_Small_En_V1_5_Output = {
    shape?: number[];
    /**
     * Embeddings of the requested text values
     */
    data?: number[][];
    /**
     * The pooling method used in the embedding process.
     */
    pooling?: "mean" | "cls";
} | AsyncResponse;
declare abstract class Base_Ai_Cf_Baai_Bge_Small_En_V1_5 {
    inputs: Ai_Cf_Baai_Bge_Small_En_V1_5_Input;
    postProcessedOutputs: Ai_Cf_Baai_Bge_Small_En_V1_5_Output;
}
type Ai_Cf_Baai_Bge_Large_En_V1_5_Input = {
    text: string | string[];
    /**
     * The pooling method used in the embedding process. `cls` pooling will generate more accurate embeddings on larger inputs - however, embeddings created with cls pooling are not compatible with embeddings generated with mean pooling. The default pooling method is `mean` in order for this to not be a breaking change, but we highly suggest using the new `cls` pooling for better accuracy.
     */
    pooling?: "mean" | "cls";
} | {
    /**
     * Batch of the embeddings requests to run using async-queue
     */
    requests: {
        text: string | string[];
        /**
         * The pooling method used in the embedding process. `cls` pooling will generate more accurate embeddings on larger inputs - however, embeddings created with cls pooling are not compatible with embeddings generated with mean pooling. The default pooling method is `mean` in order for this to not be a breaking change, but we highly suggest using the new `cls` pooling for better accuracy.
         */
        pooling?: "mean" | "cls";
    }[];
};
type Ai_Cf_Baai_Bge_Large_En_V1_5_Output = {
    shape?: number[];
    /**
     * Embeddings of the requested text values
     */
    data?: number[][];
    /**
     * The pooling method used in the embedding process.
     */
    pooling?: "mean" | "cls";
} | AsyncResponse;
declare abstract class Base_Ai_Cf_Baai_Bge_Large_En_V1_5 {
    inputs: Ai_Cf_Baai_Bge_Large_En_V1_5_Input;
    postProcessedOutputs: Ai_Cf_Baai_Bge_Large_En_V1_5_Output;
}
type Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Input = string | {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt?: string;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
    image: number[] | (string & NonNullable<unknown>);
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
};
interface Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Output {
    description?: string;
}
declare abstract class Base_Ai_Cf_Unum_Uform_Gen2_Qwen_500M {
    inputs: Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Input;
    postProcessedOutputs: Ai_Cf_Unum_Uform_Gen2_Qwen_500M_Output;
}
type Ai_Cf_Openai_Whisper_Tiny_En_Input = string | {
    /**
     * An array of integers that represent the audio data constrained to 8-bit unsigned integer values
     */
    audio: number[];
};
interface Ai_Cf_Openai_Whisper_Tiny_En_Output {
    /**
     * The transcription
     */
    text: string;
    word_count?: number;
    words?: {
        word?: string;
        /**
         * The second this word begins in the recording
         */
        start?: number;
        /**
         * The ending second when the word completes
         */
        end?: number;
    }[];
    vtt?: string;
}
declare abstract class Base_Ai_Cf_Openai_Whisper_Tiny_En {
    inputs: Ai_Cf_Openai_Whisper_Tiny_En_Input;
    postProcessedOutputs: Ai_Cf_Openai_Whisper_Tiny_En_Output;
}
interface Ai_Cf_Openai_Whisper_Large_V3_Turbo_Input {
    /**
     * Base64 encoded value of the audio data.
     */
    audio: string;
    /**
     * Supported tasks are 'translate' or 'transcribe'.
     */
    task?: string;
    /**
     * The language of the audio being transcribed or translated.
     */
    language?: string;
    /**
     * Preprocess the audio with a voice activity detection model.
     */
    vad_filter?: boolean;
    /**
     * A text prompt to help provide context to the model on the contents of the audio.
     */
    initial_prompt?: string;
    /**
     * The prefix it appended the the beginning of the output of the transcription and can guide the transcription result.
     */
    prefix?: string;
}
interface Ai_Cf_Openai_Whisper_Large_V3_Turbo_Output {
    transcription_info?: {
        /**
         * The language of the audio being transcribed or translated.
         */
        language?: string;
        /**
         * The confidence level or probability of the detected language being accurate, represented as a decimal between 0 and 1.
         */
        language_probability?: number;
        /**
         * The total duration of the original audio file, in seconds.
         */
        duration?: number;
        /**
         * The duration of the audio after applying Voice Activity Detection (VAD) to remove silent or irrelevant sections, in seconds.
         */
        duration_after_vad?: number;
    };
    /**
     * The complete transcription of the audio.
     */
    text: string;
    /**
     * The total number of words in the transcription.
     */
    word_count?: number;
    segments?: {
        /**
         * The starting time of the segment within the audio, in seconds.
         */
        start?: number;
        /**
         * The ending time of the segment within the audio, in seconds.
         */
        end?: number;
        /**
         * The transcription of the segment.
         */
        text?: string;
        /**
         * The temperature used in the decoding process, controlling randomness in predictions. Lower values result in more deterministic outputs.
         */
        temperature?: number;
        /**
         * The average log probability of the predictions for the words in this segment, indicating overall confidence.
         */
        avg_logprob?: number;
        /**
         * The compression ratio of the input to the output, measuring how much the text was compressed during the transcription process.
         */
        compression_ratio?: number;
        /**
         * The probability that the segment contains no speech, represented as a decimal between 0 and 1.
         */
        no_speech_prob?: number;
        words?: {
            /**
             * The individual word transcribed from the audio.
             */
            word?: string;
            /**
             * The starting time of the word within the audio, in seconds.
             */
            start?: number;
            /**
             * The ending time of the word within the audio, in seconds.
             */
            end?: number;
        }[];
    }[];
    /**
     * The transcription in WebVTT format, which includes timing and text information for use in subtitles.
     */
    vtt?: string;
}
declare abstract class Base_Ai_Cf_Openai_Whisper_Large_V3_Turbo {
    inputs: Ai_Cf_Openai_Whisper_Large_V3_Turbo_Input;
    postProcessedOutputs: Ai_Cf_Openai_Whisper_Large_V3_Turbo_Output;
}
type Ai_Cf_Baai_Bge_M3_Input = BGEM3InputQueryAndContexts | BGEM3InputEmbedding | {
    /**
     * Batch of the embeddings requests to run using async-queue
     */
    requests: (BGEM3InputQueryAndContexts1 | BGEM3InputEmbedding1)[];
};
interface BGEM3InputQueryAndContexts {
    /**
     * A query you wish to perform against the provided contexts. If no query is provided the model with respond with embeddings for contexts
     */
    query?: string;
    /**
     * List of provided contexts. Note that the index in this array is important, as the response will refer to it.
     */
    contexts: {
        /**
         * One of the provided context content
         */
        text?: string;
    }[];
    /**
     * When provided with too long context should the model error out or truncate the context to fit?
     */
    truncate_inputs?: boolean;
}
interface BGEM3InputEmbedding {
    text: string | string[];
    /**
     * When provided with too long context should the model error out or truncate the context to fit?
     */
    truncate_inputs?: boolean;
}
interface BGEM3InputQueryAndContexts1 {
    /**
     * A query you wish to perform against the provided contexts. If no query is provided the model with respond with embeddings for contexts
     */
    query?: string;
    /**
     * List of provided contexts. Note that the index in this array is important, as the response will refer to it.
     */
    contexts: {
        /**
         * One of the provided context content
         */
        text?: string;
    }[];
    /**
     * When provided with too long context should the model error out or truncate the context to fit?
     */
    truncate_inputs?: boolean;
}
interface BGEM3InputEmbedding1 {
    text: string | string[];
    /**
     * When provided with too long context should the model error out or truncate the context to fit?
     */
    truncate_inputs?: boolean;
}
type Ai_Cf_Baai_Bge_M3_Output = BGEM3OuputQuery | BGEM3OutputEmbeddingForContexts | BGEM3OuputEmbedding | AsyncResponse;
interface BGEM3OuputQuery {
    response?: {
        /**
         * Index of the context in the request
         */
        id?: number;
        /**
         * Score of the context under the index.
         */
        score?: number;
    }[];
}
interface BGEM3OutputEmbeddingForContexts {
    response?: number[][];
    shape?: number[];
    /**
     * The pooling method used in the embedding process.
     */
    pooling?: "mean" | "cls";
}
interface BGEM3OuputEmbedding {
    shape?: number[];
    /**
     * Embeddings of the requested text values
     */
    data?: number[][];
    /**
     * The pooling method used in the embedding process.
     */
    pooling?: "mean" | "cls";
}
declare abstract class Base_Ai_Cf_Baai_Bge_M3 {
    inputs: Ai_Cf_Baai_Bge_M3_Input;
    postProcessedOutputs: Ai_Cf_Baai_Bge_M3_Output;
}
interface Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Input {
    /**
     * A text description of the image you want to generate.
     */
    prompt: string;
    /**
     * The number of diffusion steps; higher values can improve quality but take longer.
     */
    steps?: number;
}
interface Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Output {
    /**
     * The generated image in Base64 format.
     */
    image?: string;
}
declare abstract class Base_Ai_Cf_Black_Forest_Labs_Flux_1_Schnell {
    inputs: Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Input;
    postProcessedOutputs: Ai_Cf_Black_Forest_Labs_Flux_1_Schnell_Output;
}
type Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Input = Prompt | Messages;
interface Prompt {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    image?: number[] | (string & NonNullable<unknown>);
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
    /**
     * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
     */
    lora?: string;
}
interface Messages {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role?: string;
        /**
         * The tool call id. Must be supplied for tool calls for Mistral-3. If you don't know what to put here you can fall back to 000000001
         */
        tool_call_id?: string;
        content?: string | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        }[] | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        };
    }[];
    image?: number[] | (string & NonNullable<unknown>);
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    /**
     * If true, the response will be streamed back incrementally.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Controls the creativity of the AI's responses by adjusting how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
type Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Output = {
    /**
     * The generated text response from the model
     */
    response?: string;
    /**
     * An array of tool calls requests made during the response generation
     */
    tool_calls?: {
        /**
         * The arguments passed to be passed to the tool call request
         */
        arguments?: object;
        /**
         * The name of the tool to be called
         */
        name?: string;
    }[];
};
declare abstract class Base_Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct {
    inputs: Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Input;
    postProcessedOutputs: Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct_Output;
}
type Ai_Cf_Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Input = Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Prompt | Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Messages | AsyncBatch;
interface Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Prompt {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    /**
     * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
     */
    lora?: string;
    response_format?: JSONMode;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface JSONMode {
    type?: "json_object" | "json_schema";
    json_schema?: unknown;
}
interface Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Messages {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role: string;
        /**
         * The content of the message as a string.
         */
        content: string;
    }[];
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    response_format?: JSONMode;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface AsyncBatch {
    requests?: {
        /**
         * User-supplied reference. This field will be present in the response as well it can be used to reference the request and response. It's NOT validated to be unique.
         */
        external_reference?: string;
        /**
         * Prompt for the text generation model
         */
        prompt?: string;
        /**
         * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
         */
        stream?: boolean;
        /**
         * The maximum number of tokens to generate in the response.
         */
        max_tokens?: number;
        /**
         * Controls the randomness of the output; higher values produce more random results.
         */
        temperature?: number;
        /**
         * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
         */
        top_p?: number;
        /**
         * Random seed for reproducibility of the generation.
         */
        seed?: number;
        /**
         * Penalty for repeated tokens; higher values discourage repetition.
         */
        repetition_penalty?: number;
        /**
         * Decreases the likelihood of the model repeating the same lines verbatim.
         */
        frequency_penalty?: number;
        /**
         * Increases the likelihood of the model introducing new topics.
         */
        presence_penalty?: number;
        response_format?: JSONMode;
    }[];
}
type Ai_Cf_Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Output = {
    /**
     * The generated text response from the model
     */
    response: string;
    /**
     * Usage statistics for the inference request
     */
    usage?: {
        /**
         * Total number of tokens in input
         */
        prompt_tokens?: number;
        /**
         * Total number of tokens in output
         */
        completion_tokens?: number;
        /**
         * Total number of input and output tokens
         */
        total_tokens?: number;
    };
    /**
     * An array of tool calls requests made during the response generation
     */
    tool_calls?: {
        /**
         * The arguments passed to be passed to the tool call request
         */
        arguments?: object;
        /**
         * The name of the tool to be called
         */
        name?: string;
    }[];
} | string | AsyncResponse;
declare abstract class Base_Ai_Cf_Meta_Llama_3_3_70B_Instruct_Fp8_Fast {
    inputs: Ai_Cf_Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Input;
    postProcessedOutputs: Ai_Cf_Meta_Llama_3_3_70B_Instruct_Fp8_Fast_Output;
}
interface Ai_Cf_Meta_Llama_Guard_3_8B_Input {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender must alternate between 'user' and 'assistant'.
         */
        role: "user" | "assistant";
        /**
         * The content of the message as a string.
         */
        content: string;
    }[];
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Dictate the output format of the generated response.
     */
    response_format?: {
        /**
         * Set to json_object to process and output generated text as JSON.
         */
        type?: string;
    };
}
interface Ai_Cf_Meta_Llama_Guard_3_8B_Output {
    response?: string | {
        /**
         * Whether the conversation is safe or not.
         */
        safe?: boolean;
        /**
         * A list of what hazard categories predicted for the conversation, if the conversation is deemed unsafe.
         */
        categories?: string[];
    };
    /**
     * Usage statistics for the inference request
     */
    usage?: {
        /**
         * Total number of tokens in input
         */
        prompt_tokens?: number;
        /**
         * Total number of tokens in output
         */
        completion_tokens?: number;
        /**
         * Total number of input and output tokens
         */
        total_tokens?: number;
    };
}
declare abstract class Base_Ai_Cf_Meta_Llama_Guard_3_8B {
    inputs: Ai_Cf_Meta_Llama_Guard_3_8B_Input;
    postProcessedOutputs: Ai_Cf_Meta_Llama_Guard_3_8B_Output;
}
interface Ai_Cf_Baai_Bge_Reranker_Base_Input {
    /**
     * A query you wish to perform against the provided contexts.
     */
    /**
     * Number of returned results starting with the best score.
     */
    top_k?: number;
    /**
     * List of provided contexts. Note that the index in this array is important, as the response will refer to it.
     */
    contexts: {
        /**
         * One of the provided context content
         */
        text?: string;
    }[];
}
interface Ai_Cf_Baai_Bge_Reranker_Base_Output {
    response?: {
        /**
         * Index of the context in the request
         */
        id?: number;
        /**
         * Score of the context under the index.
         */
        score?: number;
    }[];
}
declare abstract class Base_Ai_Cf_Baai_Bge_Reranker_Base {
    inputs: Ai_Cf_Baai_Bge_Reranker_Base_Input;
    postProcessedOutputs: Ai_Cf_Baai_Bge_Reranker_Base_Output;
}
type Ai_Cf_Qwen_Qwen2_5_Coder_32B_Instruct_Input = Qwen2_5_Coder_32B_Instruct_Prompt | Qwen2_5_Coder_32B_Instruct_Messages;
interface Qwen2_5_Coder_32B_Instruct_Prompt {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    /**
     * Name of the LoRA (Low-Rank Adaptation) model to fine-tune the base model.
     */
    lora?: string;
    response_format?: JSONMode;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface Qwen2_5_Coder_32B_Instruct_Messages {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role: string;
        /**
         * The content of the message as a string.
         */
        content: string;
    }[];
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    response_format?: JSONMode;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
type Ai_Cf_Qwen_Qwen2_5_Coder_32B_Instruct_Output = {
    /**
     * The generated text response from the model
     */
    response: string;
    /**
     * Usage statistics for the inference request
     */
    usage?: {
        /**
         * Total number of tokens in input
         */
        prompt_tokens?: number;
        /**
         * Total number of tokens in output
         */
        completion_tokens?: number;
        /**
         * Total number of input and output tokens
         */
        total_tokens?: number;
    };
    /**
     * An array of tool calls requests made during the response generation
     */
    tool_calls?: {
        /**
         * The arguments passed to be passed to the tool call request
         */
        arguments?: object;
        /**
         * The name of the tool to be called
         */
        name?: string;
    }[];
};
declare abstract class Base_Ai_Cf_Qwen_Qwen2_5_Coder_32B_Instruct {
    inputs: Ai_Cf_Qwen_Qwen2_5_Coder_32B_Instruct_Input;
    postProcessedOutputs: Ai_Cf_Qwen_Qwen2_5_Coder_32B_Instruct_Output;
}
type Ai_Cf_Qwen_Qwq_32B_Input = Qwen_Qwq_32B_Prompt | Qwen_Qwq_32B_Messages;
interface Qwen_Qwq_32B_Prompt {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    /**
     * JSON schema that should be fulfilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface Qwen_Qwq_32B_Messages {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role?: string;
        /**
         * The tool call id. Must be supplied for tool calls for Mistral-3. If you don't know what to put here you can fall back to 000000001
         */
        tool_call_id?: string;
        content?: string | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        }[] | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        };
    }[];
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    /**
     * JSON schema that should be fufilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
type Ai_Cf_Qwen_Qwq_32B_Output = {
    /**
     * The generated text response from the model
     */
    response: string;
    /**
     * Usage statistics for the inference request
     */
    usage?: {
        /**
         * Total number of tokens in input
         */
        prompt_tokens?: number;
        /**
         * Total number of tokens in output
         */
        completion_tokens?: number;
        /**
         * Total number of input and output tokens
         */
        total_tokens?: number;
    };
    /**
     * An array of tool calls requests made during the response generation
     */
    tool_calls?: {
        /**
         * The arguments passed to be passed to the tool call request
         */
        arguments?: object;
        /**
         * The name of the tool to be called
         */
        name?: string;
    }[];
};
declare abstract class Base_Ai_Cf_Qwen_Qwq_32B {
    inputs: Ai_Cf_Qwen_Qwq_32B_Input;
    postProcessedOutputs: Ai_Cf_Qwen_Qwq_32B_Output;
}
type Ai_Cf_Mistralai_Mistral_Small_3_1_24B_Instruct_Input = Mistral_Small_3_1_24B_Instruct_Prompt | Mistral_Small_3_1_24B_Instruct_Messages;
interface Mistral_Small_3_1_24B_Instruct_Prompt {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    /**
     * JSON schema that should be fulfilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface Mistral_Small_3_1_24B_Instruct_Messages {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role?: string;
        /**
         * The tool call id. Must be supplied for tool calls for Mistral-3. If you don't know what to put here you can fall back to 000000001
         */
        tool_call_id?: string;
        content?: string | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        }[] | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        };
    }[];
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    /**
     * JSON schema that should be fufilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
type Ai_Cf_Mistralai_Mistral_Small_3_1_24B_Instruct_Output = {
    /**
     * The generated text response from the model
     */
    response: string;
    /**
     * Usage statistics for the inference request
     */
    usage?: {
        /**
         * Total number of tokens in input
         */
        prompt_tokens?: number;
        /**
         * Total number of tokens in output
         */
        completion_tokens?: number;
        /**
         * Total number of input and output tokens
         */
        total_tokens?: number;
    };
    /**
     * An array of tool calls requests made during the response generation
     */
    tool_calls?: {
        /**
         * The arguments passed to be passed to the tool call request
         */
        arguments?: object;
        /**
         * The name of the tool to be called
         */
        name?: string;
    }[];
};
declare abstract class Base_Ai_Cf_Mistralai_Mistral_Small_3_1_24B_Instruct {
    inputs: Ai_Cf_Mistralai_Mistral_Small_3_1_24B_Instruct_Input;
    postProcessedOutputs: Ai_Cf_Mistralai_Mistral_Small_3_1_24B_Instruct_Output;
}
type Ai_Cf_Google_Gemma_3_12B_It_Input = Google_Gemma_3_12B_It_Prompt | Google_Gemma_3_12B_It_Messages;
interface Google_Gemma_3_12B_It_Prompt {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    /**
     * JSON schema that should be fufilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface Google_Gemma_3_12B_It_Messages {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role?: string;
        content?: string | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        }[] | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        };
    }[];
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    /**
     * JSON schema that should be fufilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
type Ai_Cf_Google_Gemma_3_12B_It_Output = {
    /**
     * The generated text response from the model
     */
    response: string;
    /**
     * Usage statistics for the inference request
     */
    usage?: {
        /**
         * Total number of tokens in input
         */
        prompt_tokens?: number;
        /**
         * Total number of tokens in output
         */
        completion_tokens?: number;
        /**
         * Total number of input and output tokens
         */
        total_tokens?: number;
    };
    /**
     * An array of tool calls requests made during the response generation
     */
    tool_calls?: {
        /**
         * The arguments passed to be passed to the tool call request
         */
        arguments?: object;
        /**
         * The name of the tool to be called
         */
        name?: string;
    }[];
};
declare abstract class Base_Ai_Cf_Google_Gemma_3_12B_It {
    inputs: Ai_Cf_Google_Gemma_3_12B_It_Input;
    postProcessedOutputs: Ai_Cf_Google_Gemma_3_12B_It_Output;
}
type Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Input = Ai_Cf_Meta_Llama_4_Prompt | Ai_Cf_Meta_Llama_4_Messages | Ai_Cf_Meta_Llama_4_Async_Batch;
interface Ai_Cf_Meta_Llama_4_Prompt {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    /**
     * JSON schema that should be fulfilled for the response.
     */
    guided_json?: object;
    response_format?: JSONMode;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface Ai_Cf_Meta_Llama_4_Messages {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role?: string;
        /**
         * The tool call id. If you don't know what to put here you can fall back to 000000001
         */
        tool_call_id?: string;
        content?: string | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        }[] | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        };
    }[];
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    response_format?: JSONMode;
    /**
     * JSON schema that should be fufilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface Ai_Cf_Meta_Llama_4_Async_Batch {
    requests: (Ai_Cf_Meta_Llama_4_Prompt_Inner | Ai_Cf_Meta_Llama_4_Messages_Inner)[];
}
interface Ai_Cf_Meta_Llama_4_Prompt_Inner {
    /**
     * The input text prompt for the model to generate a response.
     */
    prompt: string;
    /**
     * JSON schema that should be fulfilled for the response.
     */
    guided_json?: object;
    response_format?: JSONMode;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
interface Ai_Cf_Meta_Llama_4_Messages_Inner {
    /**
     * An array of message objects representing the conversation history.
     */
    messages: {
        /**
         * The role of the message sender (e.g., 'user', 'assistant', 'system', 'tool').
         */
        role?: string;
        /**
         * The tool call id. If you don't know what to put here you can fall back to 000000001
         */
        tool_call_id?: string;
        content?: string | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        }[] | {
            /**
             * Type of the content provided
             */
            type?: string;
            text?: string;
            image_url?: {
                /**
                 * image uri with data (e.g. data:image/jpeg;base64,/9j/...). HTTP URL will not be accepted
                 */
                url?: string;
            };
        };
    }[];
    functions?: {
        name: string;
        code: string;
    }[];
    /**
     * A list of tools available for the assistant to use.
     */
    tools?: ({
        /**
         * The name of the tool. More descriptive the better.
         */
        name: string;
        /**
         * A brief description of what the tool does.
         */
        description: string;
        /**
         * Schema defining the parameters accepted by the tool.
         */
        parameters: {
            /**
             * The type of the parameters object (usually 'object').
             */
            type: string;
            /**
             * List of required parameter names.
             */
            required?: string[];
            /**
             * Definitions of each parameter.
             */
            properties: {
                [k: string]: {
                    /**
                     * The data type of the parameter.
                     */
                    type: string;
                    /**
                     * A description of the expected parameter.
                     */
                    description: string;
                };
            };
        };
    } | {
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type: string;
        /**
         * Details of the function tool.
         */
        function: {
            /**
             * The name of the function.
             */
            name: string;
            /**
             * A brief description of what the function does.
             */
            description: string;
            /**
             * Schema defining the parameters accepted by the function.
             */
            parameters: {
                /**
                 * The type of the parameters object (usually 'object').
                 */
                type: string;
                /**
                 * List of required parameter names.
                 */
                required?: string[];
                /**
                 * Definitions of each parameter.
                 */
                properties: {
                    [k: string]: {
                        /**
                         * The data type of the parameter.
                         */
                        type: string;
                        /**
                         * A description of the expected parameter.
                         */
                        description: string;
                    };
                };
            };
        };
    })[];
    response_format?: JSONMode;
    /**
     * JSON schema that should be fufilled for the response.
     */
    guided_json?: object;
    /**
     * If true, a chat template is not applied and you must adhere to the specific model's expected formatting.
     */
    raw?: boolean;
    /**
     * If true, the response will be streamed back incrementally using SSE, Server Sent Events.
     */
    stream?: boolean;
    /**
     * The maximum number of tokens to generate in the response.
     */
    max_tokens?: number;
    /**
     * Controls the randomness of the output; higher values produce more random results.
     */
    temperature?: number;
    /**
     * Adjusts the creativity of the AI's responses by controlling how many possible words it considers. Lower values make outputs more predictable; higher values allow for more varied and creative responses.
     */
    top_p?: number;
    /**
     * Limits the AI to choose from the top 'k' most probable words. Lower values make responses more focused; higher values introduce more variety and potential surprises.
     */
    top_k?: number;
    /**
     * Random seed for reproducibility of the generation.
     */
    seed?: number;
    /**
     * Penalty for repeated tokens; higher values discourage repetition.
     */
    repetition_penalty?: number;
    /**
     * Decreases the likelihood of the model repeating the same lines verbatim.
     */
    frequency_penalty?: number;
    /**
     * Increases the likelihood of the model introducing new topics.
     */
    presence_penalty?: number;
}
type Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Output = {
    /**
     * The generated text response from the model
     */
    response: string;
    /**
     * Usage statistics for the inference request
     */
    usage?: {
        /**
         * Total number of tokens in input
         */
        prompt_tokens?: number;
        /**
         * Total number of tokens in output
         */
        completion_tokens?: number;
        /**
         * Total number of input and output tokens
         */
        total_tokens?: number;
    };
    /**
     * An array of tool calls requests made during the response generation
     */
    tool_calls?: {
        /**
         * The tool call id.
         */
        id?: string;
        /**
         * Specifies the type of tool (e.g., 'function').
         */
        type?: string;
        /**
         * Details of the function tool.
         */
        function?: {
            /**
             * The name of the tool to be called
             */
            name?: string;
            /**
             * The arguments passed to be passed to the tool call request
             */
            arguments?: object;
        };
    }[];
};
declare abstract class Base_Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct {
    inputs: Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Input;
    postProcessedOutputs: Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct_Output;
}
interface Ai_Cf_Deepgram_Nova_3_Input {
    audio: {
        body: object;
        contentType: string;
    };
    /**
     * Sets how the model will interpret strings submitted to the custom_topic param. When strict, the model will only return topics submitted using the custom_topic param. When extended, the model will return its own detected topics in addition to those submitted using the custom_topic param.
     */
    custom_topic_mode?: "extended" | "strict";
    /**
     * Custom topics you want the model to detect within your input audio or text if present Submit up to 100
     */
    custom_topic?: string;
    /**
     * Sets how the model will interpret intents submitted to the custom_intent param. When strict, the model will only return intents submitted using the custom_intent param. When extended, the model will return its own detected intents in addition those submitted using the custom_intents param
     */
    custom_intent_mode?: "extended" | "strict";
    /**
     * Custom intents you want the model to detect within your input audio if present
     */
    custom_intent?: string;
    /**
     * Identifies and extracts key entities from content in submitted audio
     */
    detect_entities?: boolean;
    /**
     * Identifies the dominant language spoken in submitted audio
     */
    detect_language?: boolean;
    /**
     * Recognize speaker changes. Each word in the transcript will be assigned a speaker number starting at 0
     */
    diarize?: boolean;
    /**
     * Identify and extract key entities from content in submitted audio
     */
    dictation?: boolean;
    /**
     * Specify the expected encoding of your submitted audio
     */
    encoding?: "linear16" | "flac" | "mulaw" | "amr-nb" | "amr-wb" | "opus" | "speex" | "g729";
    /**
     * Arbitrary key-value pairs that are attached to the API response for usage in downstream processing
     */
    extra?: string;
    /**
     * Filler Words can help transcribe interruptions in your audio, like 'uh' and 'um'
     */
    filler_words?: boolean;
    /**
     * Key term prompting can boost or suppress specialized terminology and brands.
     */
    keyterm?: string;
    /**
     * Keywords can boost or suppress specialized terminology and brands.
     */
    keywords?: string;
    /**
     * The BCP-47 language tag that hints at the primary spoken language. Depending on the Model and API endpoint you choose only certain languages are available.
     */
    language?: string;
    /**
     * Spoken measurements will be converted to their corresponding abbreviations.
     */
    measurements?: boolean;
    /**
     * Opts out requests from the Deepgram Model Improvement Program. Refer to our Docs for pricing impacts before setting this to true. https://dpgr.am/deepgram-mip.
     */
    mip_opt_out?: boolean;
    /**
     * Mode of operation for the model representing broad area of topic that will be talked about in the supplied audio
     */
    mode?: "general" | "medical" | "finance";
    /**
     * Transcribe each audio channel independently.
     */
    multichannel?: boolean;
    /**
     * Numerals converts numbers from written format to numerical format.
     */
    numerals?: boolean;
    /**
     * Splits audio into paragraphs to improve transcript readability.
     */
    paragraphs?: boolean;
    /**
     * Profanity Filter looks for recognized profanity and converts it to the nearest recognized non-profane word or removes it from the transcript completely.
     */
    profanity_filter?: boolean;
    /**
     * Add punctuation and capitalization to the transcript.
     */
    punctuate?: boolean;
    /**
     * Redaction removes sensitive information from your transcripts.
     */
    redact?: string;
    /**
     * Search for terms or phrases in submitted audio and replaces them.
     */
    replace?: string;
    /**
     * Search for terms or phrases in submitted audio.
     */
    search?: string;
    /**
     * Recognizes the sentiment throughout a transcript or text.
     */
    sentiment?: boolean;
    /**
     * Apply formatting to transcript output. When set to true, additional formatting will be applied to transcripts to improve readability.
     */
    smart_format?: boolean;
    /**
     * Detect topics throughout a transcript or text.
     */
    topics?: boolean;
    /**
     * Segments speech into meaningful semantic units.
     */
    utterances?: boolean;
    /**
     * Seconds to wait before detecting a pause between words in submitted audio.
     */
    utt_split?: number;
    /**
     * The number of channels in the submitted audio
     */
    channels?: number;
    /**
     * Specifies whether the streaming endpoint should provide ongoing transcription updates as more audio is received. When set to true, the endpoint sends continuous updates, meaning transcription results may evolve over time. Note: Supported only for webosockets.
     */
    interim_results?: boolean;
    /**
     * Indicates how long model will wait to detect whether a speaker has finished speaking or pauses for a significant period of time. When set to a value, the streaming endpoint immediately finalizes the transcription for the processed time range and returns the transcript with a speech_final parameter set to true. Can also be set to false to disable endpointing
     */
    endpointing?: string;
    /**
     * Indicates that speech has started. You'll begin receiving Speech Started messages upon speech starting. Note: Supported only for webosockets.
     */
    vad_events?: boolean;
    /**
     * Indicates how long model will wait to send an UtteranceEnd message after a word has been transcribed. Use with interim_results. Note: Supported only for webosockets.
     */
    utterance_end_ms?: boolean;
}
interface Ai_Cf_Deepgram_Nova_3_Output {
    results?: {
        channels?: {
            alternatives?: {
                confidence?: number;
                transcript?: string;
                words?: {
                    confidence?: number;
                    end?: number;
                    start?: number;
                    word?: string;
                }[];
            }[];
        }[];
        summary?: {
            result?: string;
            short?: string;
        };
        sentiments?: {
            segments?: {
                text?: string;
                start_word?: number;
                end_word?: number;
                sentiment?: string;
                sentiment_score?: number;
            }[];
            average?: {
                sentiment?: string;
                sentiment_score?: number;
            };
        };
    };
}
declare abstract class Base_Ai_Cf_Deepgram_Nova_3 {
    inputs: Ai_Cf_Deepgram_Nova_3_Input;
    postProcessedOutputs: Ai_Cf_Deepgram_Nova_3_Output;
}
type Ai_Cf_Pipecat_Ai_Smart_Turn_V2_Input = {
    /**
     * readable stream with audio data and content-type specified for that data
     */
    audio: {
        body: object;
        contentType: string;
    };
    /**
     * type of data PCM data that's sent to the inference server as raw array
     */
    dtype?: "uint8" | "float32" | "float64";
} | {
    /**
     * base64 encoded audio data
     */
    audio: string;
    /**
     * type of data PCM data that's sent to the inference server as raw array
     */
    dtype?: "uint8" | "float32" | "float64";
};
interface Ai_Cf_Pipecat_Ai_Smart_Turn_V2_Output {
    /**
     * if true, end-of-turn was detected
     */
    is_complete?: boolean;
    /**
     * probability of the end-of-turn detection
     */
    probability?: number;
}
declare abstract class Base_Ai_Cf_Pipecat_Ai_Smart_Turn_V2 {
    inputs: Ai_Cf_Pipecat_Ai_Smart_Turn_V2_Input;
    postProcessedOutputs: Ai_Cf_Pipecat_Ai_Smart_Turn_V2_Output;
}
type Ai_Cf_Openai_Gpt_Oss_120B_Input = GPT_OSS_120B_Responses | GPT_OSS_120B_Responses_Async;
interface GPT_OSS_120B_Responses {
    /**
     * Responses API Input messages. Refer to OpenAI Responses API docs to learn more about supported content types
     */
    input: string | unknown[];
    reasoning?: {
        /**
         * Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
         */
        effort?: "low" | "medium" | "high";
        /**
         * A summary of the reasoning performed by the model. This can be useful for debugging and understanding the model's reasoning process. One of auto, concise, or detailed.
         */
        summary?: "auto" | "concise" | "detailed";
    };
}
interface GPT_OSS_120B_Responses_Async {
    requests: {
        /**
         * Responses API Input messages. Refer to OpenAI Responses API docs to learn more about supported content types
         */
        input: string | unknown[];
        reasoning?: {
            /**
             * Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
             */
            effort?: "low" | "medium" | "high";
            /**
             * A summary of the reasoning performed by the model. This can be useful for debugging and understanding the model's reasoning process. One of auto, concise, or detailed.
             */
            summary?: "auto" | "concise" | "detailed";
        };
    }[];
}
type Ai_Cf_Openai_Gpt_Oss_120B_Output = {} | (string & NonNullable<unknown>);
declare abstract class Base_Ai_Cf_Openai_Gpt_Oss_120B {
    inputs: Ai_Cf_Openai_Gpt_Oss_120B_Input;
    postProcessedOutputs: Ai_Cf_Openai_Gpt_Oss_120B_Output;
}
type Ai_Cf_Openai_Gpt_Oss_20B_Input = GPT_OSS_20B_Responses | GPT_OSS_20B_Responses_Async;
interface GPT_OSS_20B_Responses {
    /**
     * Responses API Input messages. Refer to OpenAI Responses API docs to learn more about supported content types
     */
    input: string | unknown[];
    reasoning?: {
        /**
         * Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
         */
        effort?: "low" | "medium" | "high";
        /**
         * A summary of the reasoning performed by the model. This can be useful for debugging and understanding the model's reasoning process. One of auto, concise, or detailed.
         */
        summary?: "auto" | "concise" | "detailed";
    };
}
interface GPT_OSS_20B_Responses_Async {
    requests: {
        /**
         * Responses API Input messages. Refer to OpenAI Responses API docs to learn more about supported content types
         */
        input: string | unknown[];
        reasoning?: {
            /**
             * Constrains effort on reasoning for reasoning models. Currently supported values are low, medium, and high. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
             */
            effort?: "low" | "medium" | "high";
            /**
             * A summary of the reasoning performed by the model. This can be useful for debugging and understanding the model's reasoning process. One of auto, concise, or detailed.
             */
            summary?: "auto" | "concise" | "detailed";
        };
    }[];
}
type Ai_Cf_Openai_Gpt_Oss_20B_Output = {} | (string & NonNullable<unknown>);
declare abstract class Base_Ai_Cf_Openai_Gpt_Oss_20B {
    inputs: Ai_Cf_Openai_Gpt_Oss_20B_Input;
    postProcessedOutputs: Ai_Cf_Openai_Gpt_Oss_20B_Output;
}
interface Ai_Cf_Leonardo_Phoenix_1_0_Input {
    /**
     * A text description of the image you want to generate.
     */
    prompt: string;
    /**
     * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
     */
    guidance?: number;
    /**
     * Random seed for reproducibility of the image generation
     */
    seed?: number;
    /**
     * The height of the generated image in pixels
     */
    height?: number;
    /**
     * The width of the generated image in pixels
     */
    width?: number;
    /**
     * The number of diffusion steps; higher values can improve quality but take longer
     */
    num_steps?: number;
    /**
     * Specify what to exclude from the generated images
     */
    negative_prompt?: string;
}
/**
 * The generated image in JPEG format
 */
type Ai_Cf_Leonardo_Phoenix_1_0_Output = string;
declare abstract class Base_Ai_Cf_Leonardo_Phoenix_1_0 {
    inputs: Ai_Cf_Leonardo_Phoenix_1_0_Input;
    postProcessedOutputs: Ai_Cf_Leonardo_Phoenix_1_0_Output;
}
interface Ai_Cf_Leonardo_Lucid_Origin_Input {
    /**
     * A text description of the image you want to generate.
     */
    prompt: string;
    /**
     * Controls how closely the generated image should adhere to the prompt; higher values make the image more aligned with the prompt
     */
    guidance?: number;
    /**
     * Random seed for reproducibility of the image generation
     */
    seed?: number;
    /**
     * The height of the generated image in pixels
     */
    height?: number;
    /**
     * The width of the generated image in pixels
     */
    width?: number;
    /**
     * The number of diffusion steps; higher values can improve quality but take longer
     */
    num_steps?: number;
    /**
     * The number of diffusion steps; higher values can improve quality but take longer
     */
    steps?: number;
}
interface Ai_Cf_Leonardo_Lucid_Origin_Output {
    /**
     * The generated image in Base64 format.
     */
    image?: string;
}
declare abstract class Base_Ai_Cf_Leonardo_Lucid_Origin {
    inputs: Ai_Cf_Leonardo_Lucid_Origin_Input;
    postProcessedOutputs: Ai_Cf_Leonardo_Lucid_Origin_Output;
}
interface Ai_Cf_Deepgram_Aura_1_Input {
    /**
     * Speaker used to produce the audio.
     */
    speaker?: "angus" | "asteria" | "arcas" | "orion" | "orpheus" | "athena" | "luna" | "zeus" | "perseus" | "helios" | "hera" | "stella";
    /**
     * Encoding of the output audio.
     */
    encoding?: "linear16" | "flac" | "mulaw" | "alaw" | "mp3" | "opus" | "aac";
    /**
     * Container specifies the file format wrapper for the output audio. The available options depend on the encoding type..
     */
    container?: "none" | "wav" | "ogg";
    /**
     * The text content to be converted to speech
     */
    text: string;
    /**
     * Sample Rate specifies the sample rate for the output audio. Based on the encoding, different sample rates are supported. For some encodings, the sample rate is not configurable
     */
    sample_rate?: number;
    /**
     * The bitrate of the audio in bits per second. Choose from predefined ranges or specific values based on the encoding type.
     */
    bit_rate?: number;
}
/**
 * The generated audio in MP3 format
 */
type Ai_Cf_Deepgram_Aura_1_Output = string;
declare abstract class Base_Ai_Cf_Deepgram_Aura_1 {
    inputs: Ai_Cf_Deepgram_Aura_1_Input;
    postProcessedOutputs: Ai_Cf_Deepgram_Aura_1_Output;
}
interface AiModels {
    "@cf/huggingface/distilbert-sst-2-int8": BaseAiTextClassification;
    "@cf/stabilityai/stable-diffusion-xl-base-1.0": BaseAiTextToImage;
    "@cf/runwayml/stable-diffusion-v1-5-inpainting": BaseAiTextToImage;
    "@cf/runwayml/stable-diffusion-v1-5-img2img": BaseAiTextToImage;
    "@cf/lykon/dreamshaper-8-lcm": BaseAiTextToImage;
    "@cf/bytedance/stable-diffusion-xl-lightning": BaseAiTextToImage;
    "@cf/myshell-ai/melotts": BaseAiTextToSpeech;
    "@cf/google/embeddinggemma-300m": BaseAiTextEmbeddings;
    "@cf/microsoft/resnet-50": BaseAiImageClassification;
    "@cf/meta/llama-2-7b-chat-int8": BaseAiTextGeneration;
    "@cf/mistral/mistral-7b-instruct-v0.1": BaseAiTextGeneration;
    "@cf/meta/llama-2-7b-chat-fp16": BaseAiTextGeneration;
    "@hf/thebloke/llama-2-13b-chat-awq": BaseAiTextGeneration;
    "@hf/thebloke/mistral-7b-instruct-v0.1-awq": BaseAiTextGeneration;
    "@hf/thebloke/zephyr-7b-beta-awq": BaseAiTextGeneration;
    "@hf/thebloke/openhermes-2.5-mistral-7b-awq": BaseAiTextGeneration;
    "@hf/thebloke/neural-chat-7b-v3-1-awq": BaseAiTextGeneration;
    "@hf/thebloke/llamaguard-7b-awq": BaseAiTextGeneration;
    "@hf/thebloke/deepseek-coder-6.7b-base-awq": BaseAiTextGeneration;
    "@hf/thebloke/deepseek-coder-6.7b-instruct-awq": BaseAiTextGeneration;
    "@cf/deepseek-ai/deepseek-math-7b-instruct": BaseAiTextGeneration;
    "@cf/defog/sqlcoder-7b-2": BaseAiTextGeneration;
    "@cf/openchat/openchat-3.5-0106": BaseAiTextGeneration;
    "@cf/tiiuae/falcon-7b-instruct": BaseAiTextGeneration;
    "@cf/thebloke/discolm-german-7b-v1-awq": BaseAiTextGeneration;
    "@cf/qwen/qwen1.5-0.5b-chat": BaseAiTextGeneration;
    "@cf/qwen/qwen1.5-7b-chat-awq": BaseAiTextGeneration;
    "@cf/qwen/qwen1.5-14b-chat-awq": BaseAiTextGeneration;
    "@cf/tinyllama/tinyllama-1.1b-chat-v1.0": BaseAiTextGeneration;
    "@cf/microsoft/phi-2": BaseAiTextGeneration;
    "@cf/qwen/qwen1.5-1.8b-chat": BaseAiTextGeneration;
    "@cf/mistral/mistral-7b-instruct-v0.2-lora": BaseAiTextGeneration;
    "@hf/nousresearch/hermes-2-pro-mistral-7b": BaseAiTextGeneration;
    "@hf/nexusflow/starling-lm-7b-beta": BaseAiTextGeneration;
    "@hf/google/gemma-7b-it": BaseAiTextGeneration;
    "@cf/meta-llama/llama-2-7b-chat-hf-lora": BaseAiTextGeneration;
    "@cf/google/gemma-2b-it-lora": BaseAiTextGeneration;
    "@cf/google/gemma-7b-it-lora": BaseAiTextGeneration;
    "@hf/mistral/mistral-7b-instruct-v0.2": BaseAiTextGeneration;
    "@cf/meta/llama-3-8b-instruct": BaseAiTextGeneration;
    "@cf/fblgit/una-cybertron-7b-v2-bf16": BaseAiTextGeneration;
    "@cf/meta/llama-3-8b-instruct-awq": BaseAiTextGeneration;
    "@hf/meta-llama/meta-llama-3-8b-instruct": BaseAiTextGeneration;
    "@cf/meta/llama-3.1-8b-instruct-fp8": BaseAiTextGeneration;
    "@cf/meta/llama-3.1-8b-instruct-awq": BaseAiTextGeneration;
    "@cf/meta/llama-3.2-3b-instruct": BaseAiTextGeneration;
    "@cf/meta/llama-3.2-1b-instruct": BaseAiTextGeneration;
    "@cf/deepseek-ai/deepseek-r1-distill-qwen-32b": BaseAiTextGeneration;
    "@cf/facebook/bart-large-cnn": BaseAiSummarization;
    "@cf/llava-hf/llava-1.5-7b-hf": BaseAiImageToText;
    "@cf/baai/bge-base-en-v1.5": Base_Ai_Cf_Baai_Bge_Base_En_V1_5;
    "@cf/openai/whisper": Base_Ai_Cf_Openai_Whisper;
    "@cf/meta/m2m100-1.2b": Base_Ai_Cf_Meta_M2M100_1_2B;
    "@cf/baai/bge-small-en-v1.5": Base_Ai_Cf_Baai_Bge_Small_En_V1_5;
    "@cf/baai/bge-large-en-v1.5": Base_Ai_Cf_Baai_Bge_Large_En_V1_5;
    "@cf/unum/uform-gen2-qwen-500m": Base_Ai_Cf_Unum_Uform_Gen2_Qwen_500M;
    "@cf/openai/whisper-tiny-en": Base_Ai_Cf_Openai_Whisper_Tiny_En;
    "@cf/openai/whisper-large-v3-turbo": Base_Ai_Cf_Openai_Whisper_Large_V3_Turbo;
    "@cf/baai/bge-m3": Base_Ai_Cf_Baai_Bge_M3;
    "@cf/black-forest-labs/flux-1-schnell": Base_Ai_Cf_Black_Forest_Labs_Flux_1_Schnell;
    "@cf/meta/llama-3.2-11b-vision-instruct": Base_Ai_Cf_Meta_Llama_3_2_11B_Vision_Instruct;
    "@cf/meta/llama-3.3-70b-instruct-fp8-fast": Base_Ai_Cf_Meta_Llama_3_3_70B_Instruct_Fp8_Fast;
    "@cf/meta/llama-guard-3-8b": Base_Ai_Cf_Meta_Llama_Guard_3_8B;
    "@cf/baai/bge-reranker-base": Base_Ai_Cf_Baai_Bge_Reranker_Base;
    "@cf/qwen/qwen2.5-coder-32b-instruct": Base_Ai_Cf_Qwen_Qwen2_5_Coder_32B_Instruct;
    "@cf/qwen/qwq-32b": Base_Ai_Cf_Qwen_Qwq_32B;
    "@cf/mistralai/mistral-small-3.1-24b-instruct": Base_Ai_Cf_Mistralai_Mistral_Small_3_1_24B_Instruct;
    "@cf/google/gemma-3-12b-it": Base_Ai_Cf_Google_Gemma_3_12B_It;
    "@cf/meta/llama-4-scout-17b-16e-instruct": Base_Ai_Cf_Meta_Llama_4_Scout_17B_16E_Instruct;
    "@cf/deepgram/nova-3": Base_Ai_Cf_Deepgram_Nova_3;
    "@cf/pipecat-ai/smart-turn-v2": Base_Ai_Cf_Pipecat_Ai_Smart_Turn_V2;
    "@cf/openai/gpt-oss-120b": Base_Ai_Cf_Openai_Gpt_Oss_120B;
    "@cf/openai/gpt-oss-20b": Base_Ai_Cf_Openai_Gpt_Oss_20B;
    "@cf/leonardo/phoenix-1.0": Base_Ai_Cf_Leonardo_Phoenix_1_0;
    "@cf/leonardo/lucid-origin": Base_Ai_Cf_Leonardo_Lucid_Origin;
    "@cf/deepgram/aura-1": Base_Ai_Cf_Deepgram_Aura_1;
}
type AiOptions = {
    /**
     * Send requests as an asynchronous batch job, only works for supported models
     * https://developers.cloudflare.com/workers-ai/features/batch-api
     */
    queueRequest?: boolean;
    /**
     * Establish websocket connections, only works for supported models
     */
    websocket?: boolean;
    gateway?: GatewayOptions;
    returnRawResponse?: boolean;
    prefix?: string;
    extraHeaders?: object;
};
type AiModelsSearchParams = {
    author?: string;
    hide_experimental?: boolean;
    page?: number;
    per_page?: number;
    search?: string;
    source?: number;
    task?: string;
};
type AiModelsSearchObject = {
    id: string;
    source: number;
    name: string;
    description: string;
    task: {
        id: string;
        name: string;
        description: string;
    };
    tags: string[];
    properties: {
        property_id: string;
        value: string;
    }[];
};
interface InferenceUpstreamError extends Error {
}
interface AiInternalError extends Error {
}
type AiModelListType = Record<string, any>;
declare abstract class Ai<AiModelList extends AiModelListType = AiModels> {
    aiGatewayLogId: string | null;
    gateway(gatewayId: string): AiGateway;
    autorag(autoragId: string): AutoRAG;
    run<Name extends keyof AiModelList, Options extends AiOptions, InputOptions extends AiModelList[Name]["inputs"]>(model: Name, inputs: InputOptions, options?: Options): Promise<Options extends {
        returnRawResponse: true;
    } | {
        websocket: true;
    } ? Response : InputOptions extends {
        stream: true;
    } ? ReadableStream : AiModelList[Name]["postProcessedOutputs"]>;
    models(params?: AiModelsSearchParams): Promise<AiModelsSearchObject[]>;
    toMarkdown(): ToMarkdownService;
    toMarkdown(files: {
        name: string;
        blob: Blob;
    }[], options?: {
        gateway?: GatewayOptions;
        extraHeaders?: object;
    }): Promise<ConversionResponse[]>;
    toMarkdown(files: {
        name: string;
        blob: Blob;
    }, options?: {
        gateway?: GatewayOptions;
        extraHeaders?: object;
    }): Promise<ConversionResponse>;
}
type GatewayRetries = {
    maxAttempts?: 1 | 2 | 3 | 4 | 5;
    retryDelayMs?: number;
    backoff?: 'constant' | 'linear' | 'exponential';
};
type GatewayOptions = {
    id: string;
    cacheKey?: string;
    cacheTtl?: number;
    skipCache?: boolean;
    metadata?: Record<string, number | string | boolean | null | bigint>;
    collectLog?: boolean;
    eventId?: string;
    requestTimeoutMs?: number;
    retries?: GatewayRetries;
};
type UniversalGatewayOptions = Exclude<GatewayOptions, 'id'> & {
    /**
     ** @deprecated
     */
    id?: string;
};
type AiGatewayPatchLog = {
    score?: number | null;
    feedback?: -1 | 1 | null;
    metadata?: Record<string, number | string | boolean | null | bigint> | null;
};
type AiGatewayLog = {
    id: string;
    provider: string;
    model: string;
    model_type?: string;
    path: string;
    duration: number;
    request_type?: string;
    request_content_type?: string;
    status_code: number;
    response_content_type?: string;
    success: boolean;
    cached: boolean;
    tokens_in?: number;
    tokens_out?: number;
    metadata?: Record<string, number | string | boolean | null | bigint>;
    step?: number;
    cost?: number;
    custom_cost?: boolean;
    request_size: number;
    request_head?: string;
    request_head_complete: boolean;
    response_size: number;
    response_head?: string;
    response_head_complete: boolean;
    created_at: Date;
};
type AIGatewayProviders = 'workers-ai' | 'anthropic' | 'aws-bedrock' | 'azure-openai' | 'google-vertex-ai' | 'huggingface' | 'openai' | 'perplexity-ai' | 'replicate' | 'groq' | 'cohere' | 'google-ai-studio' | 'mistral' | 'grok' | 'openrouter' | 'deepseek' | 'cerebras' | 'cartesia' | 'elevenlabs' | 'adobe-firefly';
type AIGatewayHeaders = {
    'cf-aig-metadata': Record<string, number | string | boolean | null | bigint> | string;
    'cf-aig-custom-cost': {
        per_token_in?: number;
        per_token_out?: number;
    } | {
        total_cost?: number;
    } | string;
    'cf-aig-cache-ttl': number | string;
    'cf-aig-skip-cache': boolean | string;
    'cf-aig-cache-key': string;
    'cf-aig-event-id': string;
    'cf-aig-request-timeout': number | string;
    'cf-aig-max-attempts': number | string;
    'cf-aig-retry-delay': number | string;
    'cf-aig-backoff': string;
    'cf-aig-collect-log': boolean | string;
    Authorization: string;
    'Content-Type': string;
    [key: string]: string | number | boolean | object;
};
type AIGatewayUniversalRequest = {
    provider: AIGatewayProviders | string; // eslint-disable-line
    endpoint: string;
    headers: Partial<AIGatewayHeaders>;
    query: unknown;
};
interface AiGatewayInternalError extends Error {
}
interface AiGatewayLogNotFound extends Error {
}
declare abstract class AiGateway {
    patchLog(logId: string, data: AiGatewayPatchLog): Promise<void>;
    getLog(logId: string): Promise<AiGatewayLog>;
    run(data: AIGatewayUniversalRequest | AIGatewayUniversalRequest[], options?: {
        gateway?: UniversalGatewayOptions;
        extraHeaders?: object;
    }): Promise<Response>;
    getUrl(provider?: AIGatewayProviders | string): Promise<string>; // eslint-disable-line
}
interface AutoRAGInternalError extends Error {
}
interface AutoRAGNotFoundError extends Error {
}
interface AutoRAGUnauthorizedError extends Error {
}
interface AutoRAGNameNotSetError extends Error {
}
type ComparisonFilter = {
    key: string;
    type: 'eq' | 'ne' | 'gt' | 'gte' | 'lt' | 'lte';
    value: string | number | boolean;
};
type CompoundFilter = {
    type: 'and' | 'or';
    filters: ComparisonFilter[];
};
type AutoRagSearchRequest = {
    query: string;
    filters?: CompoundFilter | ComparisonFilter;
    max_num_results?: number;
    ranking_options?: {
        ranker?: string;
        score_threshold?: number;
    };
    rewrite_query?: boolean;
};
type AutoRagAiSearchRequest = AutoRagSearchRequest & {
    stream?: boolean;
    system_prompt?: string;
};
type AutoRagAiSearchRequestStreaming = Omit<AutoRagAiSearchRequest, 'stream'> & {
    stream: true;
};
type AutoRagSearchResponse = {
    object: 'vector_store.search_results.page';
    search_query: string;
    data: {
        file_id: string;
        filename: string;
        score: number;
        attributes: Record<string, string | number | boolean | null>;
        content: {
            type: 'text';
            text: string;
        }[];
    }[];
    has_more: boolean;
    next_page: string | null;
};
type AutoRagListResponse = {
    id: string;
    enable: boolean;
    type: string;
    source: string;
    vectorize_name: string;
    paused: boolean;
    status: string;
}[];
type AutoRagAiSearchResponse = AutoRagSearchResponse & {
    response: string;
};
declare abstract class AutoRAG {
    list(): Promise<AutoRagListResponse>;
    search(params: AutoRagSearchRequest): Promise<AutoRagSearchResponse>;
    aiSearch(params: AutoRagAiSearchRequestStreaming): Promise<Response>;
    aiSearch(params: AutoRagAiSearchRequest): Promise<AutoRagAiSearchResponse>;
    aiSearch(params: AutoRagAiSearchRequest): Promise<AutoRagAiSearchResponse | Response>;
}
interface BasicImageTransformations {
    /**
     * Maximum width in image pixels. The value must be an integer.
     */
    width?: number;
    /**
     * Maximum height in image pixels. The value must be an integer.
     */
    height?: number;
    /**
     * Resizing mode as a string. It affects interpretation of width and height
     * options:
     *  - scale-down: Similar to contain, but the image is never enlarged. If
     *    the image is larger than given width or height, it will be resized.
     *    Otherwise its original size will be kept.
     *  - contain: Resizes to maximum size that fits within the given width and
     *    height. If only a single dimension is given (e.g. only width), the
     *    image will be shrunk or enlarged to exactly match that dimension.
     *    Aspect ratio is always preserved.
     *  - cover: Resizes (shrinks or enlarges) to fill the entire area of width
     *    and height. If the image has an aspect ratio different from the ratio
     *    of width and height, it will be cropped to fit.
     *  - crop: The image will be shrunk and cropped to fit within the area
     *    specified by width and height. The image will not be enlarged. For images
     *    smaller than the given dimensions it's the same as scale-down. For
     *    images larger than the given dimensions, it's the same as cover.
     *    See also trim.
     *  - pad: Resizes to the maximum size that fits within the given width and
     *    height, and then fills the remaining area with a background color
     *    (white by default). Use of this mode is not recommended, as the same
     *    effect can be more efficiently achieved with the contain mode and the
     *    CSS object-fit: contain property.
     *  - squeeze: Stretches and deforms to the width and height given, even if it
     *    breaks aspect ratio
     */
    fit?: "scale-down" | "contain" | "cover" | "crop" | "pad" | "squeeze";
    /**
     * Image segmentation using artificial intelligence models. Sets pixels not
     * within selected segment area to transparent e.g "foreground" sets every
     * background pixel as transparent.
     */
    segment?: "foreground";
    /**
     * When cropping with fit: "cover", this defines the side or point that should
     * be left uncropped. The value is either a string
     * "left", "right", "top", "bottom", "auto", or "center" (the default),
     * or an object {x, y} containing focal point coordinates in the original
     * image expressed as fractions ranging from 0.0 (top or left) to 1.0
     * (bottom or right), 0.5 being the center. {fit: "cover", gravity: "top"} will
     * crop bottom or left and right sides as necessary, but won’t crop anything
     * from the top. {fit: "cover", gravity: {x:0.5, y:0.2}} will crop each side to
     * preserve as much as possible around a point at 20% of the height of the
     * source image.
     */
    gravity?: 'face' | 'left' | 'right' | 'top' | 'bottom' | 'center' | 'auto' | 'entropy' | BasicImageTransformationsGravityCoordinates;
    /**
     * Background color to add underneath the image. Applies only to images with
     * transparency (such as PNG). Accepts any CSS color (#RRGGBB, rgba(…),
     * hsl(…), etc.)
     */
    background?: string;
    /**
     * Number of degrees (90, 180, 270) to rotate the image by. width and height
     * options refer to axes after rotation.
     */
    rotate?: 0 | 90 | 180 | 270 | 360;
}
interface BasicImageTransformationsGravityCoordinates {
    x?: number;
    y?: number;
    mode?: 'remainder' | 'box-center';
}
/**
 * In addition to the properties you can set in the RequestInit dict
 * that you pass as an argument to the Request constructor, you can
 * set certain properties of a `cf` object to control how Cloudflare
 * features are applied to that new Request.
 *
 * Note: Currently, these properties cannot be tested in the
 * playground.
 */
interface RequestInitCfProperties extends Record<string, unknown> {
    cacheEverything?: boolean;
    /**
     * A request's cache key is what determines if two requests are
     * "the same" for caching purposes. If a request has the same cache key
     * as some previous request, then we can serve the same cached response for
     * both. (e.g. 'some-key')
     *
     * Only available for Enterprise customers.
     */
    cacheKey?: string;
    /**
     * This allows you to append additional Cache-Tag response headers
     * to the origin response without modifications to the origin server.
     * This will allow for greater control over the Purge by Cache Tag feature
     * utilizing changes only in the Workers process.
     *
     * Only available for Enterprise customers.
     */
    cacheTags?: string[];
    /**
     * Force response to be cached for a given number of seconds. (e.g. 300)
     */
    cacheTtl?: number;
    /**
     * Force response to be cached for a given number of seconds based on the Origin status code.
     * (e.g. { '200-299': 86400, '404': 1, '500-599': 0 })
     */
    cacheTtlByStatus?: Record<string, number>;
    scrapeShield?: boolean;
    apps?: boolean;
    image?: RequestInitCfPropertiesImage;
    minify?: RequestInitCfPropertiesImageMinify;
    mirage?: boolean;
    polish?: "lossy" | "lossless" | "off";
    r2?: RequestInitCfPropertiesR2;
    /**
     * Redirects the request to an alternate origin server. You can use this,
     * for example, to implement load balancing across several origins.
     * (e.g.us-east.example.com)
     *
     * Note - For security reasons, the hostname set in resolveOverride must
     * be proxied on the same Cloudflare zone of the incoming request.
     * Otherwise, the setting is ignored. CNAME hosts are allowed, so to
     * resolve to a host under a different domain or a DNS only domain first
     * declare a CNAME record within your own zone’s DNS mapping to the
     * external hostname, set proxy on Cloudflare, then set resolveOverride
     * to point to that CNAME record.
     */
    resolveOverride?: string;
}
interface RequestInitCfPropertiesImageDraw extends BasicImageTransformations {
    /**
     * Absolute URL of the image file to use for the drawing. It can be any of
     * the supported file formats. For drawing of watermarks or non-rectangular
     * overlays we recommend using PNG or WebP images.
     */
    url: string;
    /**
     * Floating-point number between 0 (transparent) and 1 (opaque).
     * For example, opacity: 0.5 makes overlay semitransparent.
     */
    opacity?: number;
    /**
     * - If set to true, the overlay image will be tiled to cover the entire
     *   area. This is useful for stock-photo-like watermarks.
     * - If set to "x", the overlay image will be tiled horizontally only
     *   (form a line).
     * - If set to "y", the overlay image will be tiled vertically only
     *   (form a line).
     */
    repeat?: true | "x" | "y";
    /**
     * Position of the overlay image relative to a given edge. Each property is
     * an offset in pixels. 0 aligns exactly to the edge. For example, left: 10
     * positions left side of the overlay 10 pixels from the left edge of the
     * image it's drawn over. bottom: 0 aligns bottom of the overlay with bottom
     * of the background image.
     *
     * Setting both left & right, or both top & bottom is an error.
     *
     * If no position is specified, the image will be centered.
     */
    top?: number;
    left?: number;
    bottom?: number;
    right?: number;
}
interface RequestInitCfPropertiesImage extends BasicImageTransformations {
    /**
     * Device Pixel Ratio. Default 1. Multiplier for width/height that makes it
     * easier to specify higher-DPI sizes in <img srcset>.
     */
    dpr?: number;
    /**
     * Allows you to trim your image. Takes dpr into account and is performed before
     * resizing or rotation.
     *
     * It can be used as:
     * - left, top, right, bottom - it will specify the number of pixels to cut
     *   off each side
     * - width, height - the width/height you'd like to end up with - can be used
     *   in combination with the properties above
     * - border - this will automatically trim the surroundings of an image based on
     *   it's color. It consists of three properties:
     *    - color: rgb or hex representation of the color you wish to trim (todo: verify the rgba bit)
     *    - tolerance: difference from color to treat as color
     *    - keep: the number of pixels of border to keep
     */
    trim?: "border" | {
        top?: number;
        bottom?: number;
        left?: number;
        right?: number;
        width?: number;
        height?: number;
        border?: boolean | {
            color?: string;
            tolerance?: number;
            keep?: number;
        };
    };
    /**
     * Quality setting from 1-100 (useful values are in 60-90 range). Lower values
     * make images look worse, but load faster. The default is 85. It applies only
     * to JPEG and WebP images. It doesn’t have any effect on PNG.
     */
    quality?: number | "low" | "medium-low" | "medium-high" | "high";
    /**
     * Output format to generate. It can be:
     *  - avif: generate images in AVIF format.
     *  - webp: generate images in Google WebP format. Set quality to 100 to get
     *    the WebP-lossless format.
     *  - json: instead of generating an image, outputs information about the
     *    image, in JSON format. The JSON object will contain image size
     *    (before and after resizing), source image’s MIME type, file size, etc.
     * - jpeg: generate images in JPEG format.
     * - png: generate images in PNG format.
     */
    format?: "avif" | "webp" | "json" | "jpeg" | "png" | "baseline-jpeg" | "png-force" | "svg";
    /**
     * Whether to preserve animation frames from input files. Default is true.
     * Setting it to false reduces animations to still images. This setting is
     * recommended when enlarging images or processing arbitrary user content,
     * because large GIF animations can weigh tens or even hundreds of megabytes.
     * It is also useful to set anim:false when using format:"json" to get the
     * response quicker without the number of frames.
     */
    anim?: boolean;
    /**
     * What EXIF data should be preserved in the output image. Note that EXIF
     * rotation and embedded color profiles are always applied ("baked in" into
     * the image), and aren't affected by this option. Note that if the Polish
     * feature is enabled, all metadata may have been removed already and this
     * option may have no effect.
     *  - keep: Preserve most of EXIF metadata, including GPS location if there's
     *    any.
     *  - copyright: Only keep the copyright tag, and discard everything else.
     *    This is the default behavior for JPEG files.
     *  - none: Discard all invisible EXIF metadata. Currently WebP and PNG
     *    output formats always discard metadata.
     */
    metadata?: "keep" | "copyright" | "none";
    /**
     * Strength of sharpening filter to apply to the image. Floating-point
     * number between 0 (no sharpening, default) and 10 (maximum). 1.0 is a
     * recommended value for downscaled images.
     */
    sharpen?: number;
    /**
     * Radius of a blur filter (approximate gaussian). Maximum supported radius
     * is 250.
     */
    blur?: number;
    /**
     * Overlays are drawn in the order they appear in the array (last array
     * entry is the topmost layer).
     */
    draw?: RequestInitCfPropertiesImageDraw[];
    /**
     * Fetching image from authenticated origin. Setting this property will
     * pass authentication headers (Authorization, Cookie, etc.) through to
     * the origin.
     */
    "origin-auth"?: "share-publicly";
    /**
     * Adds a border around the image. The border is added after resizing. Border
     * width takes dpr into account, and can be specified either using a single
     * width property, or individually for each side.
     */
    border?: {
        color: string;
        width: number;
    } | {
        color: string;
        top: number;
        right: number;
        bottom: number;
        left: number;
    };
    /**
     * Increase brightness by a factor. A value of 1.0 equals no change, a value
     * of 0.5 equals half brightness, and a value of 2.0 equals twice as bright.
     * 0 is ignored.
     */
    brightness?: number;
    /**
     * Increase contrast by a factor. A value of 1.0 equals no change, a value of
     * 0.5 equals low contrast, and a value of 2.0 equals high contrast. 0 is
     * ignored.
     */
    contrast?: number;
    /**
     * Increase exposure by a factor. A value of 1.0 equals no change, a value of
     * 0.5 darkens the image, and a value of 2.0 lightens the image. 0 is ignored.
     */
    gamma?: number;
    /**
     * Increase contrast by a factor. A value of 1.0 equals no change, a value of
     * 0.5 equals low contrast, and a value of 2.0 equals high contrast. 0 is
     * ignored.
     */
    saturation?: number;
    /**
     * Flips the images horizontally, vertically, or both. Flipping is applied before
     * rotation, so if you apply flip=h,rotate=90 then the image will be flipped
     * horizontally, then rotated by 90 degrees.
     */
    flip?: 'h' | 'v' | 'hv';
    /**
     * Slightly reduces latency on a cache miss by selecting a
     * quickest-to-compress file format, at a cost of increased file size and
     * lower image quality. It will usually override the format option and choose
     * JPEG over WebP or AVIF. We do not recommend using this option, except in
     * unusual circumstances like resizing uncacheable dynamically-generated
     * images.
     */
    compression?: "fast";
}
interface RequestInitCfPropertiesImageMinify {
    javascript?: boolean;
    css?: boolean;
    html?: boolean;
}
interface RequestInitCfPropertiesR2 {
    /**
     * Colo id of bucket that an object is stored in
     */
    bucketColoId?: number;
}
/**
 * Request metadata provided by Cloudflare's edge.
 */
type IncomingRequestCfProperties<HostMetadata = unknown> = IncomingRequestCfPropertiesBase & IncomingRequestCfPropertiesBotManagementEnterprise & IncomingRequestCfPropertiesCloudflareForSaaSEnterprise<HostMetadata> & IncomingRequestCfPropertiesGeographicInformation & IncomingRequestCfPropertiesCloudflareAccessOrApiShield;
interface IncomingRequestCfPropertiesBase extends Record<string, unknown> {
    /**
     * [ASN](https://www.iana.org/assignments/as-numbers/as-numbers.xhtml) of the incoming request.
     *
     * @example 395747
     */
    asn?: number;
    /**
     * The organization which owns the ASN of the incoming request.
     *
     * @example "Google Cloud"
     */
    asOrganization?: string;
    /**
     * The original value of the `Accept-Encoding` header if Cloudflare modified it.
     *
     * @example "gzip, deflate, br"
     */
    clientAcceptEncoding?: string;
    /**
     * The number of milliseconds it took for the request to reach your worker.
     *
     * @example 22
     */
    clientTcpRtt?: number;
    /**
     * The three-letter [IATA](https://en.wikipedia.org/wiki/IATA_airport_code)
     * airport code of the data center that the request hit.
     *
     * @example "DFW"
     */
    colo: string;
    /**
     * Represents the upstream's response to a
     * [TCP `keepalive` message](https://tldp.org/HOWTO/TCP-Keepalive-HOWTO/overview.html)
     * from cloudflare.
     *
     * For workers with no upstream, this will always be `1`.
     *
     * @example 3
     */
    edgeRequestKeepAliveStatus: IncomingRequestCfPropertiesEdgeRequestKeepAliveStatus;
    /**
     * The HTTP Protocol the request used.
     *
     * @example "HTTP/2"
     */
    httpProtocol: string;
    /**
     * The browser-requested prioritization information in the request object.
     *
     * If no information was set, defaults to the empty string `""`
     *
     * @example "weight=192;exclusive=0;group=3;group-weight=127"
     * @default ""
     */
    requestPriority: string;
    /**
     * The TLS version of the connection to Cloudflare.
     * In requests served over plaintext (without TLS), this property is the empty string `""`.
     *
     * @example "TLSv1.3"
     */
    tlsVersion: string;
    /**
     * The cipher for the connection to Cloudflare.
     * In requests served over plaintext (without TLS), this property is the empty string `""`.
     *
     * @example "AEAD-AES128-GCM-SHA256"
     */
    tlsCipher: string;
    /**
     * Metadata containing the [`HELLO`](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.2) and [`FINISHED`](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.9) messages from this request's TLS handshake.
     *
     * If the incoming request was served over plaintext (without TLS) this field is undefined.
     */
    tlsExportedAuthenticator?: IncomingRequestCfPropertiesExportedAuthenticatorMetadata;
}
interface IncomingRequestCfPropertiesBotManagementBase {
    /**
     * Cloudflare’s [level of certainty](https://developers.cloudflare.com/bots/concepts/bot-score/) that a request comes from a bot,
     * represented as an integer percentage between `1` (almost certainly a bot) and `99` (almost certainly human).
     *
     * @example 54
     */
    score: number;
    /**
     * A boolean value that is true if the request comes from a good bot, like Google or Bing.
     * Most customers choose to allow this traffic. For more details, see [Traffic from known bots](https://developers.cloudflare.com/firewall/known-issues-and-faq/#how-does-firewall-rules-handle-traffic-from-known-bots).
     */
    verifiedBot: boolean;
    /**
     * A boolean value that is true if the request originates from a
     * Cloudflare-verified proxy service.
     */
    corporateProxy: boolean;
    /**
     * A boolean value that's true if the request matches [file extensions](https://developers.cloudflare.com/bots/reference/static-resources/) for many types of static resources.
     */
    staticResource: boolean;
    /**
     * List of IDs that correlate to the Bot Management heuristic detections made on a request (you can have multiple heuristic detections on the same request).
     */
    detectionIds: number[];
}
interface IncomingRequestCfPropertiesBotManagement {
    /**
     * Results of Cloudflare's Bot Management analysis
     */
    botManagement: IncomingRequestCfPropertiesBotManagementBase;
    /**
     * Duplicate of `botManagement.score`.
     *
     * @deprecated
     */
    clientTrustScore: number;
}
interface IncomingRequestCfPropertiesBotManagementEnterprise extends IncomingRequestCfPropertiesBotManagement {
    /**
     * Results of Cloudflare's Bot Management analysis
     */
    botManagement: IncomingRequestCfPropertiesBotManagementBase & {
        /**
         * A [JA3 Fingerprint](https://developers.cloudflare.com/bots/concepts/ja3-fingerprint/) to help profile specific SSL/TLS clients
         * across different destination IPs, Ports, and X509 certificates.
         */
        ja3Hash: string;
    };
}
interface IncomingRequestCfPropertiesCloudflareForSaaSEnterprise<HostMetadata> {
    /**
     * Custom metadata set per-host in [Cloudflare for SaaS](https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/).
     *
     * This field is only present if you have Cloudflare for SaaS enabled on your account
     * and you have followed the [required steps to enable it]((https://developers.cloudflare.com/cloudflare-for-platforms/cloudflare-for-saas/domain-support/custom-metadata/)).
     */
    hostMetadata?: HostMetadata;
}
interface IncomingRequestCfPropertiesCloudflareAccessOrApiShield {
    /**
     * Information about the client certificate presented to Cloudflare.
     *
     * This is populated when the incoming request is served over TLS using
     * either Cloudflare Access or API Shield (mTLS)
     * and the presented SSL certificate has a valid
     * [Certificate Serial Number](https://ldapwiki.com/wiki/Certificate%20Serial%20Number)
     * (i.e., not `null` or `""`).
     *
     * Otherwise, a set of placeholder values are used.
     *
     * The property `certPresented` will be set to `"1"` when
     * the object is populated (i.e. the above conditions were met).
     */
    tlsClientAuth: IncomingRequestCfPropertiesTLSClientAuth | IncomingRequestCfPropertiesTLSClientAuthPlaceholder;
}
/**
 * Metadata about the request's TLS handshake
 */
interface IncomingRequestCfPropertiesExportedAuthenticatorMetadata {
    /**
     * The client's [`HELLO` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.2), encoded in hexadecimal
     *
     * @example "44372ba35fa1270921d318f34c12f155dc87b682cf36a790cfaa3ba8737a1b5d"
     */
    clientHandshake: string;
    /**
     * The server's [`HELLO` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.1.2), encoded in hexadecimal
     *
     * @example "44372ba35fa1270921d318f34c12f155dc87b682cf36a790cfaa3ba8737a1b5d"
     */
    serverHandshake: string;
    /**
     * The client's [`FINISHED` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.9), encoded in hexadecimal
     *
     * @example "084ee802fe1348f688220e2a6040a05b2199a761f33cf753abb1b006792d3f8b"
     */
    clientFinished: string;
    /**
     * The server's [`FINISHED` message](https://www.rfc-editor.org/rfc/rfc5246#section-7.4.9), encoded in hexadecimal
     *
     * @example "084ee802fe1348f688220e2a6040a05b2199a761f33cf753abb1b006792d3f8b"
     */
    serverFinished: string;
}
/**
 * Geographic data about the request's origin.
 */
interface IncomingRequestCfPropertiesGeographicInformation {
    /**
     * The [ISO 3166-1 Alpha 2](https://www.iso.org/iso-3166-country-codes.html) country code the request originated from.
     *
     * If your worker is [configured to accept TOR connections](https://support.cloudflare.com/hc/en-us/articles/203306930-Understanding-Cloudflare-Tor-support-and-Onion-Routing), this may also be `"T1"`, indicating a request that originated over TOR.
     *
     * If Cloudflare is unable to determine where the request originated this property is omitted.
     *
     * The country code `"T1"` is used for requests originating on TOR.
     *
     * @example "GB"
     */
    country?: Iso3166Alpha2Code | "T1";
    /**
     * If present, this property indicates that the request originated in the EU
     *
     * @example "1"
     */
    isEUCountry?: "1";
    /**
     * A two-letter code indicating the continent the request originated from.
     *
     * @example "AN"
     */
    continent?: ContinentCode;
    /**
     * The city the request originated from
     *
     * @example "Austin"
     */
    city?: string;
    /**
     * Postal code of the incoming request
     *
     * @example "78701"
     */
    postalCode?: string;
    /**
     * Latitude of the incoming request
     *
     * @example "30.27130"
     */
    latitude?: string;
    /**
     * Longitude of the incoming request
     *
     * @example "-97.74260"
     */
    longitude?: string;
    /**
     * Timezone of the incoming request
     *
     * @example "America/Chicago"
     */
    timezone?: string;
    /**
     * If known, the ISO 3166-2 name for the first level region associated with
     * the IP address of the incoming request
     *
     * @example "Texas"
     */
    region?: string;
    /**
     * If known, the ISO 3166-2 code for the first-level region associated with
     * the IP address of the incoming request
     *
     * @example "TX"
     */
    regionCode?: string;
    /**
     * Metro code (DMA) of the incoming request
     *
     * @example "635"
     */
    metroCode?: string;
}
/** Data about the incoming request's TLS certificate */
interface IncomingRequestCfPropertiesTLSClientAuth {
    /** Always `"1"`, indicating that the certificate was presented */
    certPresented: "1";
    /**
     * Result of certificate verification.
     *
     * @example "FAILED:self signed certificate"
     */
    certVerified: Exclude<CertVerificationStatus, "NONE">;
    /** The presented certificate's revokation status.
     *
     * - A value of `"1"` indicates the certificate has been revoked
     * - A value of `"0"` indicates the certificate has not been revoked
     */
    certRevoked: "1" | "0";
    /**
     * The certificate issuer's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html)
     *
     * @example "CN=cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare"
     */
    certIssuerDN: string;
    /**
     * The certificate subject's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html)
     *
     * @example "CN=*.cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare"
     */
    certSubjectDN: string;
    /**
     * The certificate issuer's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html) ([RFC 2253](https://www.rfc-editor.org/rfc/rfc2253.html) formatted)
     *
     * @example "CN=cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare"
     */
    certIssuerDNRFC2253: string;
    /**
     * The certificate subject's [distinguished name](https://knowledge.digicert.com/generalinformation/INFO1745.html) ([RFC 2253](https://www.rfc-editor.org/rfc/rfc2253.html) formatted)
     *
     * @example "CN=*.cloudflareaccess.com, C=US, ST=Texas, L=Austin, O=Cloudflare"
     */
    certSubjectDNRFC2253: string;
    /** The certificate issuer's distinguished name (legacy policies) */
    certIssuerDNLegacy: string;
    /** The certificate subject's distinguished name (legacy policies) */
    certSubjectDNLegacy: string;
    /**
     * The certificate's serial number
     *
     * @example "00936EACBE07F201DF"
     */
    certSerial: string;
    /**
     * The certificate issuer's serial number
     *
     * @example "2489002934BDFEA34"
     */
    certIssuerSerial: string;
    /**
     * The certificate's Subject Key Identifier
     *
     * @example "BB:AF:7E:02:3D:FA:A6:F1:3C:84:8E:AD:EE:38:98:EC:D9:32:32:D4"
     */
    certSKI: string;
    /**
     * The certificate issuer's Subject Key Identifier
     *
     * @example "BB:AF:7E:02:3D:FA:A6:F1:3C:84:8E:AD:EE:38:98:EC:D9:32:32:D4"
     */
    certIssuerSKI: string;
    /**
     * The certificate's SHA-1 fingerprint
     *
     * @example "6b9109f323999e52259cda7373ff0b4d26bd232e"
     */
    certFingerprintSHA1: string;
    /**
     * The certificate's SHA-256 fingerprint
     *
     * @example "acf77cf37b4156a2708e34c4eb755f9b5dbbe5ebb55adfec8f11493438d19e6ad3f157f81fa3b98278453d5652b0c1fd1d71e5695ae4d709803a4d3f39de9dea"
     */
    certFingerprintSHA256: string;
    /**
     * The effective starting date of the certificate
     *
     * @example "Dec 22 19:39:00 2018 GMT"
     */
    certNotBefore: string;
    /**
     * The effective expiration date of the certificate
     *
     * @example "Dec 22 19:39:00 2018 GMT"
     */
    certNotAfter: string;
}
/** Placeholder values for TLS Client Authorization */
interface IncomingRequestCfPropertiesTLSClientAuthPlaceholder {
    certPresented: "0";
    certVerified: "NONE";
    certRevoked: "0";
    certIssuerDN: "";
    certSubjectDN: "";
    certIssuerDNRFC2253: "";
    certSubjectDNRFC2253: "";
    certIssuerDNLegacy: "";
    certSubjectDNLegacy: "";
    certSerial: "";
    certIssuerSerial: "";
    certSKI: "";
    certIssuerSKI: "";
    certFingerprintSHA1: "";
    certFingerprintSHA256: "";
    certNotBefore: "";
    certNotAfter: "";
}
/** Possible outcomes of TLS verification */
declare type CertVerificationStatus = 
/** Authentication succeeded */
"SUCCESS"
/** No certificate was presented */
 | "NONE"
/** Failed because the certificate was self-signed */
 | "FAILED:self signed certificate"
/** Failed because the certificate failed a trust chain check */
 | "FAILED:unable to verify the first certificate"
/** Failed because the certificate not yet valid */
 | "FAILED:certificate is not yet valid"
/** Failed because the certificate is expired */
 | "FAILED:certificate has expired"
/** Failed for another unspecified reason */
 | "FAILED";
/**
 * An upstream endpoint's response to a TCP `keepalive` message from Cloudflare.
 */
declare type IncomingRequestCfPropertiesEdgeRequestKeepAliveStatus = 0 /** Unknown */ | 1 /** no keepalives (not found) */ | 2 /** no connection re-use, opening keepalive connection failed */ | 3 /** no connection re-use, keepalive accepted and saved */ | 4 /** connection re-use, refused by the origin server (`TCP FIN`) */ | 5; /** connection re-use, accepted by the origin server */
/** ISO 3166-1 Alpha-2 codes */
declare type Iso3166Alpha2Code = "AD" | "AE" | "AF" | "AG" | "AI" | "AL" | "AM" | "AO" | "AQ" | "AR" | "AS" | "AT" | "AU" | "AW" | "AX" | "AZ" | "BA" | "BB" | "BD" | "BE" | "BF" | "BG" | "BH" | "BI" | "BJ" | "BL" | "BM" | "BN" | "BO" | "BQ" | "BR" | "BS" | "BT" | "BV" | "BW" | "BY" | "BZ" | "CA" | "CC" | "CD" | "CF" | "CG" | "CH" | "CI" | "CK" | "CL" | "CM" | "CN" | "CO" | "CR" | "CU" | "CV" | "CW" | "CX" | "CY" | "CZ" | "DE" | "DJ" | "DK" | "DM" | "DO" | "DZ" | "EC" | "EE" | "EG" | "EH" | "ER" | "ES" | "ET" | "FI" | "FJ" | "FK" | "FM" | "FO" | "FR" | "GA" | "GB" | "GD" | "GE" | "GF" | "GG" | "GH" | "GI" | "GL" | "GM" | "GN" | "GP" | "GQ" | "GR" | "GS" | "GT" | "GU" | "GW" | "GY" | "HK" | "HM" | "HN" | "HR" | "HT" | "HU" | "ID" | "IE" | "IL" | "IM" | "IN" | "IO" | "IQ" | "IR" | "IS" | "IT" | "JE" | "JM" | "JO" | "JP" | "KE" | "KG" | "KH" | "KI" | "KM" | "KN" | "KP" | "KR" | "KW" | "KY" | "KZ" | "LA" | "LB" | "LC" | "LI" | "LK" | "LR" | "LS" | "LT" | "LU" | "LV" | "LY" | "MA" | "MC" | "MD" | "ME" | "MF" | "MG" | "MH" | "MK" | "ML" | "MM" | "MN" | "MO" | "MP" | "MQ" | "MR" | "MS" | "MT" | "MU" | "MV" | "MW" | "MX" | "MY" | "MZ" | "NA" | "NC" | "NE" | "NF" | "NG" | "NI" | "NL" | "NO" | "NP" | "NR" | "NU" | "NZ" | "OM" | "PA" | "PE" | "PF" | "PG" | "PH" | "PK" | "PL" | "PM" | "PN" | "PR" | "PS" | "PT" | "PW" | "PY" | "QA" | "RE" | "RO" | "RS" | "RU" | "RW" | "SA" | "SB" | "SC" | "SD" | "SE" | "SG" | "SH" | "SI" | "SJ" | "SK" | "SL" | "SM" | "SN" | "SO" | "SR" | "SS" | "ST" | "SV" | "SX" | "SY" | "SZ" | "TC" | "TD" | "TF" | "TG" | "TH" | "TJ" | "TK" | "TL" | "TM" | "TN" | "TO" | "TR" | "TT" | "TV" | "TW" | "TZ" | "UA" | "UG" | "UM" | "US" | "UY" | "UZ" | "VA" | "VC" | "VE" | "VG" | "VI" | "VN" | "VU" | "WF" | "WS" | "YE" | "YT" | "ZA" | "ZM" | "ZW";
/** The 2-letter continent codes Cloudflare uses */
declare type ContinentCode = "AF" | "AN" | "AS" | "EU" | "NA" | "OC" | "SA";
type CfProperties<HostMetadata = unknown> = IncomingRequestCfProperties<HostMetadata> | RequestInitCfProperties;
interface D1Meta {
    duration: number;
    size_after: number;
    rows_read: number;
    rows_written: number;
    last_row_id: number;
    changed_db: boolean;
    changes: number;
    /**
     * The region of the database instance that executed the query.
     */
    served_by_region?: string;
    /**
     * True if-and-only-if the database instance that executed the query was the primary.
     */
    served_by_primary?: boolean;
    timings?: {
        /**
         * The duration of the SQL query execution by the database instance. It doesn't include any network time.
         */
        sql_duration_ms: number;
    };
    /**
     * Number of total attempts to execute the query, due to automatic retries.
     * Note: All other fields in the response like `timings` only apply to the last attempt.
     */
    total_attempts?: number;
}
interface D1Response {
    success: true;
    meta: D1Meta & Record<string, unknown>;
    error?: never;
}
type D1Result<T = unknown> = D1Response & {
    results: T[];
};
interface D1ExecResult {
    count: number;
    duration: number;
}
type D1SessionConstraint = 
// Indicates that the first query should go to the primary, and the rest queries
// using the same D1DatabaseSession will go to any replica that is consistent with
// the bookmark maintained by the session (returned by the first query).
'first-primary'
// Indicates that the first query can go anywhere (primary or replica), and the rest queries
// using the same D1DatabaseSession will go to any replica that is consistent with
// the bookmark maintained by the session (returned by the first query).
 | 'first-unconstrained';
type D1SessionBookmark = string;
declare abstract class D1Database {
    prepare(query: string): D1PreparedStatement;
    batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
    exec(query: string): Promise<D1ExecResult>;
    /**
     * Creates a new D1 Session anchored at the given constraint or the bookmark.
     * All queries executed using the created session will have sequential consistency,
     * meaning that all writes done through the session will be visible in subsequent reads.
     *
     * @param constraintOrBookmark Either the session constraint or the explicit bookmark to anchor the created session.
     */
    withSession(constraintOrBookmark?: D1SessionBookmark | D1SessionConstraint): D1DatabaseSession;
    /**
     * @deprecated dump() will be removed soon, only applies to deprecated alpha v1 databases.
     */
    dump(): Promise<ArrayBuffer>;
}
declare abstract class D1DatabaseSession {
    prepare(query: string): D1PreparedStatement;
    batch<T = unknown>(statements: D1PreparedStatement[]): Promise<D1Result<T>[]>;
    /**
     * @returns The latest session bookmark across all executed queries on the session.
     *          If no query has been executed yet, `null` is returned.
     */
    getBookmark(): D1SessionBookmark | null;
}
declare abstract class D1PreparedStatement {
    bind(...values: unknown[]): D1PreparedStatement;
    first<T = unknown>(colName: string): Promise<T | null>;
    first<T = Record<string, unknown>>(): Promise<T | null>;
    run<T = Record<string, unknown>>(): Promise<D1Result<T>>;
    all<T = Record<string, unknown>>(): Promise<D1Result<T>>;
    raw<T = unknown[]>(options: {
        columnNames: true;
    }): Promise<[
        string[],
        ...T[]
    ]>;
    raw<T = unknown[]>(options?: {
        columnNames?: false;
    }): Promise<T[]>;
}
// `Disposable` was added to TypeScript's standard lib types in version 5.2.
// To support older TypeScript versions, define an empty `Disposable` interface.
// Users won't be able to use `using`/`Symbol.dispose` without upgrading to 5.2,
// but this will ensure type checking on older versions still passes.
// TypeScript's interface merging will ensure our empty interface is effectively
// ignored when `Disposable` is included in the standard lib.
interface Disposable {
}
/**
 * An email message that can be sent from a Worker.
 */
interface EmailMessage {
    /**
     * Envelope From attribute of the email message.
     */
    readonly from: string;
    /**
     * Envelope To attribute of the email message.
     */
    readonly to: string;
}
/**
 * An email message that is sent to a consumer Worker and can be rejected/forwarded.
 */
interface ForwardableEmailMessage extends EmailMessage {
    /**
     * Stream of the email message content.
     */
    readonly raw: ReadableStream<Uint8Array>;
    /**
     * An [Headers object](https://developer.mozilla.org/en-US/docs/Web/API/Headers).
     */
    readonly headers: Headers;
    /**
     * Size of the email message content.
     */
    readonly rawSize: number;
    /**
     * Reject this email message by returning a permanent SMTP error back to the connecting client including the given reason.
     * @param reason The reject reason.
     * @returns void
     */
    setReject(reason: string): void;
    /**
     * Forward this email message to a verified destination address of the account.
     * @param rcptTo Verified destination address.
     * @param headers A [Headers object](https://developer.mozilla.org/en-US/docs/Web/API/Headers).
     * @returns A promise that resolves when the email message is forwarded.
     */
    forward(rcptTo: string, headers?: Headers): Promise<void>;
    /**
     * Reply to the sender of this email message with a new EmailMessage object.
     * @param message The reply message.
     * @returns A promise that resolves when the email message is replied.
     */
    reply(message: EmailMessage): Promise<void>;
}
/**
 * A binding that allows a Worker to send email messages.
 */
interface SendEmail {
    send(message: EmailMessage): Promise<void>;
}
declare abstract class EmailEvent extends ExtendableEvent {
    readonly message: ForwardableEmailMessage;
}
declare type EmailExportedHandler<Env = unknown> = (message: ForwardableEmailMessage, env: Env, ctx: ExecutionContext) => void | Promise<void>;
declare module "cloudflare:email" {
    let _EmailMessage: {
        prototype: EmailMessage;
        new (from: string, to: string, raw: ReadableStream | string): EmailMessage;
    };
    export { _EmailMessage as EmailMessage };
}
/**
 * Hello World binding to serve as an explanatory example. DO NOT USE
 */
interface HelloWorldBinding {
    /**
     * Retrieve the current stored value
     */
    get(): Promise<{
        value: string;
        ms?: number;
    }>;
    /**
     * Set a new stored value
     */
    set(value: string): Promise<void>;
}
interface Hyperdrive {
    /**
     * Connect directly to Hyperdrive as if it's your database, returning a TCP socket.
     *
     * Calling this method returns an idential socket to if you call
     * `connect("host:port")` using the `host` and `port` fields from this object.
     * Pick whichever approach works better with your preferred DB client library.
     *
     * Note that this socket is not yet authenticated -- it's expected that your
     * code (or preferably, the client library of your choice) will authenticate
     * using the information in this class's readonly fields.
     */
    connect(): Socket;
    /**
     * A valid DB connection string that can be passed straight into the typical
     * client library/driver/ORM. This will typically be the easiest way to use
     * Hyperdrive.
     */
    readonly connectionString: string;
    /*
     * A randomly generated hostname that is only valid within the context of the
     * currently running Worker which, when passed into `connect()` function from
     * the "cloudflare:sockets" module, will connect to the Hyperdrive instance
     * for your database.
     */
    readonly host: string;
    /*
     * The port that must be paired the the host field when connecting.
     */
    readonly port: number;
    /*
     * The username to use when authenticating to your database via Hyperdrive.
     * Unlike the host and password, this will be the same every time
     */
    readonly user: string;
    /*
     * The randomly generated password to use when authenticating to your
     * database via Hyperdrive. Like the host field, this password is only valid
     * within the context of the currently running Worker instance from which
     * it's read.
     */
    readonly password: string;
    /*
     * The name of the database to connect to.
     */
    readonly database: string;
}
// Copyright (c) 2024 Cloudflare, Inc.
// Licensed under the Apache 2.0 license found in the LICENSE file or at:
//     https://opensource.org/licenses/Apache-2.0
type ImageInfoResponse = {
    format: 'image/svg+xml';
} | {
    format: string;
    fileSize: number;
    width: number;
    height: number;
};
type ImageTransform = {
    width?: number;
    height?: number;
    background?: string;
    blur?: number;
    border?: {
        color?: string;
        width?: number;
    } | {
        top?: number;
        bottom?: number;
        left?: number;
        right?: number;
    };
    brightness?: number;
    contrast?: number;
    fit?: 'scale-down' | 'contain' | 'pad' | 'squeeze' | 'cover' | 'crop';
    flip?: 'h' | 'v' | 'hv';
    gamma?: number;
    segment?: 'foreground';
    gravity?: 'face' | 'left' | 'right' | 'top' | 'bottom' | 'center' | 'auto' | 'entropy' | {
        x?: number;
        y?: number;
        mode: 'remainder' | 'box-center';
    };
    rotate?: 0 | 90 | 180 | 270;
    saturation?: number;
    sharpen?: number;
    trim?: 'border' | {
        top?: number;
        bottom?: number;
        left?: number;
        right?: number;
        width?: number;
        height?: number;
        border?: boolean | {
            color?: string;
            tolerance?: number;
            keep?: number;
        };
    };
};
type ImageDrawOptions = {
    opacity?: number;
    repeat?: boolean | string;
    top?: number;
    left?: number;
    bottom?: number;
    right?: number;
};
type ImageInputOptions = {
    encoding?: 'base64';
};
type ImageOutputOptions = {
    format: 'image/jpeg' | 'image/png' | 'image/gif' | 'image/webp' | 'image/avif' | 'rgb' | 'rgba';
    quality?: number;
    background?: string;
    anim?: boolean;
};
interface ImagesBinding {
    /**
     * Get image metadata (type, width and height)
     * @throws {@link ImagesError} with code 9412 if input is not an image
     * @param stream The image bytes
     */
    info(stream: ReadableStream<Uint8Array>, options?: ImageInputOptions): Promise<ImageInfoResponse>;
    /**
     * Begin applying a series of transformations to an image
     * @param stream The image bytes
     * @returns A transform handle
     */
    input(stream: ReadableStream<Uint8Array>, options?: ImageInputOptions): ImageTransformer;
}
interface ImageTransformer {
    /**
     * Apply transform next, returning a transform handle.
     * You can then apply more transformations, draw, or retrieve the output.
     * @param transform
     */
    transform(transform: ImageTransform): ImageTransformer;
    /**
     * Draw an image on this transformer, returning a transform handle.
     * You can then apply more transformations, draw, or retrieve the output.
     * @param image The image (or transformer that will give the image) to draw
     * @param options The options configuring how to draw the image
     */
    draw(image: ReadableStream<Uint8Array> | ImageTransformer, options?: ImageDrawOptions): ImageTransformer;
    /**
     * Retrieve the image that results from applying the transforms to the
     * provided input
     * @param options Options that apply to the output e.g. output format
     */
    output(options: ImageOutputOptions): Promise<ImageTransformationResult>;
}
type ImageTransformationOutputOptions = {
    encoding?: 'base64';
};
interface ImageTransformationResult {
    /**
     * The image as a response, ready to store in cache or return to users
     */
    response(): Response;
    /**
     * The content type of the returned image
     */
    contentType(): string;
    /**
     * The bytes of the response
     */
    image(options?: ImageTransformationOutputOptions): ReadableStream<Uint8Array>;
}
interface ImagesError extends Error {
    readonly code: number;
    readonly message: string;
    readonly stack?: string;
}
/**
 * Media binding for transforming media streams.
 * Provides the entry point for media transformation operations.
 */
interface MediaBinding {
    /**
     * Creates a media transformer from an input stream.
     * @param media - The input media bytes
     * @returns A MediaTransformer instance for applying transformations
     */
    input(media: ReadableStream<Uint8Array>): MediaTransformer;
}
/**
 * Media transformer for applying transformation operations to media content.
 * Handles sizing, fitting, and other input transformation parameters.
 */
interface MediaTransformer {
    /**
     * Applies transformation options to the media content.
     * @param transform - Configuration for how the media should be transformed
     * @returns A generator for producing the transformed media output
     */
    transform(transform: MediaTransformationInputOptions): MediaTransformationGenerator;
}
/**
 * Generator for producing media transformation results.
 * Configures the output format and parameters for the transformed media.
 */
interface MediaTransformationGenerator {
    /**
     * Generates the final media output with specified options.
     * @param output - Configuration for the output format and parameters
     * @returns The final transformation result containing the transformed media
     */
    output(output: MediaTransformationOutputOptions): MediaTransformationResult;
}
/**
 * Result of a media transformation operation.
 * Provides multiple ways to access the transformed media content.
 */
interface MediaTransformationResult {
    /**
     * Returns the transformed media as a readable stream of bytes.
     * @returns A stream containing the transformed media data
     */
    media(): ReadableStream<Uint8Array>;
    /**
     * Returns the transformed media as an HTTP response object.
     * @returns The transformed media as a Response, ready to store in cache or return to users
     */
    response(): Response;
    /**
     * Returns the MIME type of the transformed media.
     * @returns The content type string (e.g., 'image/jpeg', 'video/mp4')
     */
    contentType(): string;
}
/**
 * Configuration options for transforming media input.
 * Controls how the media should be resized and fitted.
 */
type MediaTransformationInputOptions = {
    /** How the media should be resized to fit the specified dimensions */
    fit?: 'contain' | 'cover' | 'scale-down';
    /** Target width in pixels */
    width?: number;
    /** Target height in pixels */
    height?: number;
};
/**
 * Configuration options for Media Transformations output.
 * Controls the format, timing, and type of the generated output.
 */
type MediaTransformationOutputOptions = {
    /**
     * Output mode determining the type of media to generate
     */
    mode?: 'video' | 'spritesheet' | 'frame' | 'audio';
    /** Whether to include audio in the output */
    audio?: boolean;
    /**
     * Starting timestamp for frame extraction or start time for clips. (e.g. '2s').
     */
    time?: string;
    /**
     * Duration for video clips, audio extraction, and spritesheet generation (e.g. '5s').
     */
    duration?: string;
    /**
     * Number of frames in the spritesheet.
     */
    imageCount?: number;
    /**
     * Output format for the generated media.
     */
    format?: 'jpg' | 'png' | 'm4a';
};
/**
 * Error object for media transformation operations.
 * Extends the standard Error interface with additional media-specific information.
 */
interface MediaError extends Error {
    readonly code: number;
    readonly message: string;
    readonly stack?: string;
}
declare module 'cloudflare:node' {
    interface NodeStyleServer {
        listen(...args: unknown[]): this;
        address(): {
            port?: number | null | undefined;
        };
    }
    export function httpServerHandler(port: number): ExportedHandler;
    export function httpServerHandler(options: {
        port: number;
    }): ExportedHandler;
    export function httpServerHandler(server: NodeStyleServer): ExportedHandler;
}
type Params<P extends string = any> = Record<P, string | string[]>;
type EventContext<Env, P extends string, Data> = {
    request: Request<unknown, IncomingRequestCfProperties<unknown>>;
    functionPath: string;
    waitUntil: (promise: Promise<any>) => void;
    passThroughOnException: () => void;
    next: (input?: Request | string, init?: RequestInit) => Promise<Response>;
    env: Env & {
        ASSETS: {
            fetch: typeof fetch;
        };
    };
    params: Params<P>;
    data: Data;
};
type PagesFunction<Env = unknown, Params extends string = any, Data extends Record<string, unknown> = Record<string, unknown>> = (context: EventContext<Env, Params, Data>) => Response | Promise<Response>;
type EventPluginContext<Env, P extends string, Data, PluginArgs> = {
    request: Request<unknown, IncomingRequestCfProperties<unknown>>;
    functionPath: string;
    waitUntil: (promise: Promise<any>) => void;
    passThroughOnException: () => void;
    next: (input?: Request | string, init?: RequestInit) => Promise<Response>;
    env: Env & {
        ASSETS: {
            fetch: typeof fetch;
        };
    };
    params: Params<P>;
    data: Data;
    pluginArgs: PluginArgs;
};
type PagesPluginFunction<Env = unknown, Params extends string = any, Data extends Record<string, unknown> = Record<string, unknown>, PluginArgs = unknown> = (context: EventPluginContext<Env, Params, Data, PluginArgs>) => Response | Promise<Response>;
declare module "assets:*" {
    export const onRequest: PagesFunction;
}
// Copyright (c) 2022-2023 Cloudflare, Inc.
// Licensed under the Apache 2.0 license found in the LICENSE file or at:
//     https://opensource.org/licenses/Apache-2.0
declare module "cloudflare:pipelines" {
    export abstract class PipelineTransformationEntrypoint<Env = unknown, I extends PipelineRecord = PipelineRecord, O extends PipelineRecord = PipelineRecord> {
        protected env: Env;
        protected ctx: ExecutionContext;
        constructor(ctx: ExecutionContext, env: Env);
        /**
         * run recieves an array of PipelineRecord which can be
         * transformed and returned to the pipeline
         * @param records Incoming records from the pipeline to be transformed
         * @param metadata Information about the specific pipeline calling the transformation entrypoint
         * @returns A promise containing the transformed PipelineRecord array
         */
        public run(records: I[], metadata: PipelineBatchMetadata): Promise<O[]>;
    }
    export type PipelineRecord = Record<string, unknown>;
    export type PipelineBatchMetadata = {
        pipelineId: string;
        pipelineName: string;
    };
    export interface Pipeline<T extends PipelineRecord = PipelineRecord> {
        /**
         * The Pipeline interface represents the type of a binding to a Pipeline
         *
         * @param records The records to send to the pipeline
         */
        send(records: T[]): Promise<void>;
    }
}
// PubSubMessage represents an incoming PubSub message.
// The message includes metadata about the broker, the client, and the payload
// itself.
// https://developers.cloudflare.com/pub-sub/
interface PubSubMessage {
    // Message ID
    readonly mid: number;
    // MQTT broker FQDN in the form mqtts://BROKER.NAMESPACE.cloudflarepubsub.com:PORT
    readonly broker: string;
    // The MQTT topic the message was sent on.
    readonly topic: string;
    // The client ID of the client that published this message.
    readonly clientId: string;
    // The unique identifier (JWT ID) used by the client to authenticate, if token
    // auth was used.
    readonly jti?: string;
    // A Unix timestamp (seconds from Jan 1, 1970), set when the Pub/Sub Broker
    // received the message from the client.
    readonly receivedAt: number;
    // An (optional) string with the MIME type of the payload, if set by the
    // client.
    readonly contentType: string;
    // Set to 1 when the payload is a UTF-8 string
    // https://docs.oasis-open.org/mqtt/mqtt/v5.0/os/mqtt-v5.0-os.html#_Toc3901063
    readonly payloadFormatIndicator: number;
    // Pub/Sub (MQTT) payloads can be UTF-8 strings, or byte arrays.
    // You can use payloadFormatIndicator to inspect this before decoding.
    payload: string | Uint8Array;
}
// JsonWebKey extended by kid parameter
interface JsonWebKeyWithKid extends JsonWebKey {
    // Key Identifier of the JWK
    readonly kid: string;
}
interface RateLimitOptions {
    key: string;
}
interface RateLimitOutcome {
    success: boolean;
}
interface RateLimit {
    /**
     * Rate limit a request based on the provided options.
     * @see https://developers.cloudflare.com/workers/runtime-apis/bindings/rate-limit/
     * @returns A promise that resolves with the outcome of the rate limit.
     */
    limit(options: RateLimitOptions): Promise<RateLimitOutcome>;
}
// Namespace for RPC utility types. Unfortunately, we can't use a `module` here as these types need
// to referenced by `Fetcher`. This is included in the "importable" version of the types which
// strips all `module` blocks.
declare namespace Rpc {
    // Branded types for identifying `WorkerEntrypoint`/`DurableObject`/`Target`s.
    // TypeScript uses *structural* typing meaning anything with the same shape as type `T` is a `T`.
    // For the classes exported by `cloudflare:workers` we want *nominal* typing (i.e. we only want to
    // accept `WorkerEntrypoint` from `cloudflare:workers`, not any other class with the same shape)
    export const __RPC_STUB_BRAND: '__RPC_STUB_BRAND';
    export const __RPC_TARGET_BRAND: '__RPC_TARGET_BRAND';
    export const __WORKER_ENTRYPOINT_BRAND: '__WORKER_ENTRYPOINT_BRAND';
    export const __DURABLE_OBJECT_BRAND: '__DURABLE_OBJECT_BRAND';
    export const __WORKFLOW_ENTRYPOINT_BRAND: '__WORKFLOW_ENTRYPOINT_BRAND';
    export interface RpcTargetBranded {
        [__RPC_TARGET_BRAND]: never;
    }
    export interface WorkerEntrypointBranded {
        [__WORKER_ENTRYPOINT_BRAND]: never;
    }
    export interface DurableObjectBranded {
        [__DURABLE_OBJECT_BRAND]: never;
    }
    export interface WorkflowEntrypointBranded {
        [__WORKFLOW_ENTRYPOINT_BRAND]: never;
    }
    export type EntrypointBranded = WorkerEntrypointBranded | DurableObjectBranded | WorkflowEntrypointBranded;
    // Types that can be used through `Stub`s
    export type Stubable = RpcTargetBranded | ((...args: any[]) => any);
    // Types that can be passed over RPC
    // The reason for using a generic type here is to build a serializable subset of structured
    //   cloneable composite types. This allows types defined with the "interface" keyword to pass the
    //   serializable check as well. Otherwise, only types defined with the "type" keyword would pass.
    type Serializable<T> = 
    // Structured cloneables
    BaseType
    // Structured cloneable composites
     | Map<T extends Map<infer U, unknown> ? Serializable<U> : never, T extends Map<unknown, infer U> ? Serializable<U> : never> | Set<T extends Set<infer U> ? Serializable<U> : never> | ReadonlyArray<T extends ReadonlyArray<infer U> ? Serializable<U> : never> | {
        [K in keyof T]: K extends number | string ? Serializable<T[K]> : never;
    }
    // Special types
     | Stub<Stubable>
    // Serialized as stubs, see `Stubify`
     | Stubable;
    // Base type for all RPC stubs, including common memory management methods.
    // `T` is used as a marker type for unwrapping `Stub`s later.
    interface StubBase<T extends Stubable> extends Disposable {
        [__RPC_STUB_BRAND]: T;
        dup(): this;
    }
    export type Stub<T extends Stubable> = Provider<T> & StubBase<T>;
    // This represents all the types that can be sent as-is over an RPC boundary
    type BaseType = void | undefined | null | boolean | number | bigint | string | TypedArray | ArrayBuffer | DataView | Date | Error | RegExp | ReadableStream<Uint8Array> | WritableStream<Uint8Array> | Request | Response | Headers;
    // Recursively rewrite all `Stubable` types with `Stub`s
    // prettier-ignore
    type Stubify<T> = T extends Stubable ? Stub<T> : T extends Map<infer K, infer V> ? Map<Stubify<K>, Stubify<V>> : T extends Set<infer V> ? Set<Stubify<V>> : T extends Array<infer V> ? Array<Stubify<V>> : T extends ReadonlyArray<infer V> ? ReadonlyArray<Stubify<V>> : T extends BaseType ? T : T extends {
        [key: string | number]: any;
    } ? {
        [K in keyof T]: Stubify<T[K]>;
    } : T;
    // Recursively rewrite all `Stub<T>`s with the corresponding `T`s.
    // Note we use `StubBase` instead of `Stub` here to avoid circular dependencies:
    // `Stub` depends on `Provider`, which depends on `Unstubify`, which would depend on `Stub`.
    // prettier-ignore
    type Unstubify<T> = T extends StubBase<infer V> ? V : T extends Map<infer K, infer V> ? Map<Unstubify<K>, Unstubify<V>> : T extends Set<infer V> ? Set<Unstubify<V>> : T extends Array<infer V> ? Array<Unstubify<V>> : T extends ReadonlyArray<infer V> ? ReadonlyArray<Unstubify<V>> : T extends BaseType ? T : T extends {
        [key: string | number]: unknown;
    } ? {
        [K in keyof T]: Unstubify<T[K]>;
    } : T;
    type UnstubifyAll<A extends any[]> = {
        [I in keyof A]: Unstubify<A[I]>;
    };
    // Utility type for adding `Provider`/`Disposable`s to `object` types only.
    // Note `unknown & T` is equivalent to `T`.
    type MaybeProvider<T> = T extends object ? Provider<T> : unknown;
    type MaybeDisposable<T> = T extends object ? Disposable : unknown;
    // Type for method return or property on an RPC interface.
    // - Stubable types are replaced by stubs.
    // - Serializable types are passed by value, with stubable types replaced by stubs
    //   and a top-level `Disposer`.
    // Everything else can't be passed over PRC.
    // Technically, we use custom thenables here, but they quack like `Promise`s.
    // Intersecting with `(Maybe)Provider` allows pipelining.
    // prettier-ignore
    type Result<R> = R extends Stubable ? Promise<Stub<R>> & Provider<R> : R extends Serializable<R> ? Promise<Stubify<R> & MaybeDisposable<R>> & MaybeProvider<R> : never;
    // Type for method or property on an RPC interface.
    // For methods, unwrap `Stub`s in parameters, and rewrite returns to be `Result`s.
    // Unwrapping `Stub`s allows calling with `Stubable` arguments.
    // For properties, rewrite types to be `Result`s.
    // In each case, unwrap `Promise`s.
    type MethodOrProperty<V> = V extends (...args: infer P) => infer R ? (...args: UnstubifyAll<P>) => Result<Awaited<R>> : Result<Awaited<V>>;
    // Type for the callable part of an `Provider` if `T` is callable.
    // This is intersected with methods/properties.
    type MaybeCallableProvider<T> = T extends (...args: any[]) => any ? MethodOrProperty<T> : unknown;
    // Base type for all other types providing RPC-like interfaces.
    // Rewrites all methods/properties to be `MethodOrProperty`s, while preserving callable types.
    // `Reserved` names (e.g. stub method names like `dup()`) and symbols can't be accessed over RPC.
    export type Provider<T extends object, Reserved extends string = never> = MaybeCallableProvider<T> & {
        [K in Exclude<keyof T, Reserved | symbol | keyof StubBase<never>>]: MethodOrProperty<T[K]>;
    };
}
declare namespace Cloudflare {
    // Type of `env`.
    //
    // The specific project can extend `Env` by redeclaring it in project-specific files. Typescript
    // will merge all declarations.
    //
    // You can use `wrangler types` to generate the `Env` type automatically.
    interface Env {
    }
    // Project-specific parameters used to inform types.
    //
    // This interface is, again, intended to be declared in project-specific files, and then that
    // declaration will be merged with this one.
    //
    // A project should have a declaration like this:
    //
    //     interface GlobalProps {
    //       // Declares the main module's exports. Used to populate Cloudflare.Exports aka the type
    //       // of `ctx.exports`.
    //       mainModule: typeof import("my-main-module");
    //
    //       // Declares which of the main module's exports are configured with durable storage, and
    //       // thus should behave as Durable Object namsepace bindings.
    //       durableNamespaces: "MyDurableObject" | "AnotherDurableObject";
    //     }
    //
    // You can use `wrangler types` to generate `GlobalProps` automatically.
    interface GlobalProps {
    }
    // Evaluates to the type of a property in GlobalProps, defaulting to `Default` if it is not
    // present.
    type GlobalProp<K extends string, Default> = K extends keyof GlobalProps ? GlobalProps[K] : Default;
    // The type of the program's main module exports, if known. Requires `GlobalProps` to declare the
    // `mainModule` property.
    type MainModule = GlobalProp<"mainModule", {}>;
    // The type of ctx.exports, which contains loopback bindings for all top-level exports.
    type Exports = {
        [K in keyof MainModule]: LoopbackForExport<MainModule[K]>
        // If the export is listed in `durableNamespaces`, then it is also a
        // DurableObjectNamespace.
         & (K extends GlobalProp<"durableNamespaces", never> ? MainModule[K] extends new (...args: any[]) => infer DoInstance ? DoInstance extends Rpc.DurableObjectBranded ? DurableObjectNamespace<DoInstance> : DurableObjectNamespace<undefined> : DurableObjectNamespace<undefined> : {});
    };
}
declare namespace CloudflareWorkersModule {
    export type RpcStub<T extends Rpc.Stubable> = Rpc.Stub<T>;
    export const RpcStub: {
        new <T extends Rpc.Stubable>(value: T): Rpc.Stub<T>;
    };
    export abstract class RpcTarget implements Rpc.RpcTargetBranded {
        [Rpc.__RPC_TARGET_BRAND]: never;
    }
    // `protected` fields don't appear in `keyof`s, so can't be accessed over RPC
    export abstract class WorkerEntrypoint<Env = Cloudflare.Env, Props = {}> implements Rpc.WorkerEntrypointBranded {
        [Rpc.__WORKER_ENTRYPOINT_BRAND]: never;
        protected ctx: ExecutionContext<Props>;
        protected env: Env;
        constructor(ctx: ExecutionContext, env: Env);
        fetch?(request: Request): Response | Promise<Response>;
        tail?(events: TraceItem[]): void | Promise<void>;
        trace?(traces: TraceItem[]): void | Promise<void>;
        scheduled?(controller: ScheduledController): void | Promise<void>;
        queue?(batch: MessageBatch<unknown>): void | Promise<void>;
        test?(controller: TestController): void | Promise<void>;
    }
    export abstract class DurableObject<Env = Cloudflare.Env, Props = {}> implements Rpc.DurableObjectBranded {
        [Rpc.__DURABLE_OBJECT_BRAND]: never;
        protected ctx: DurableObjectState<Props>;
        protected env: Env;
        constructor(ctx: DurableObjectState, env: Env);
        fetch?(request: Request): Response | Promise<Response>;
        alarm?(alarmInfo?: AlarmInvocationInfo): void | Promise<void>;
        webSocketMessage?(ws: WebSocket, message: string | ArrayBuffer): void | Promise<void>;
        webSocketClose?(ws: WebSocket, code: number, reason: string, wasClean: boolean): void | Promise<void>;
        webSocketError?(ws: WebSocket, error: unknown): void | Promise<void>;
    }
    export type WorkflowDurationLabel = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';
    export type WorkflowSleepDuration = `${number} ${WorkflowDurationLabel}${'s' | ''}` | number;
    export type WorkflowDelayDuration = WorkflowSleepDuration;
    export type WorkflowTimeoutDuration = WorkflowSleepDuration;
    export type WorkflowRetentionDuration = WorkflowSleepDuration;
    export type WorkflowBackoff = 'constant' | 'linear' | 'exponential';
    export type WorkflowStepConfig = {
        retries?: {
            limit: number;
            delay: WorkflowDelayDuration | number;
            backoff?: WorkflowBackoff;
        };
        timeout?: WorkflowTimeoutDuration | number;
    };
    export type WorkflowEvent<T> = {
        payload: Readonly<T>;
        timestamp: Date;
        instanceId: string;
    };
    export type WorkflowStepEvent<T> = {
        payload: Readonly<T>;
        timestamp: Date;
        type: string;
    };
    export abstract class WorkflowStep {
        do<T extends Rpc.Serializable<T>>(name: string, callback: () => Promise<T>): Promise<T>;
        do<T extends Rpc.Serializable<T>>(name: string, config: WorkflowStepConfig, callback: () => Promise<T>): Promise<T>;
        sleep: (name: string, duration: WorkflowSleepDuration) => Promise<void>;
        sleepUntil: (name: string, timestamp: Date | number) => Promise<void>;
        waitForEvent<T extends Rpc.Serializable<T>>(name: string, options: {
            type: string;
            timeout?: WorkflowTimeoutDuration | number;
        }): Promise<WorkflowStepEvent<T>>;
    }
    export abstract class WorkflowEntrypoint<Env = unknown, T extends Rpc.Serializable<T> | unknown = unknown> implements Rpc.WorkflowEntrypointBranded {
        [Rpc.__WORKFLOW_ENTRYPOINT_BRAND]: never;
        protected ctx: ExecutionContext;
        protected env: Env;
        constructor(ctx: ExecutionContext, env: Env);
        run(event: Readonly<WorkflowEvent<T>>, step: WorkflowStep): Promise<unknown>;
    }
    export function waitUntil(promise: Promise<unknown>): void;
    export const env: Cloudflare.Env;
}
declare module 'cloudflare:workers' {
    export = CloudflareWorkersModule;
}
interface SecretsStoreSecret {
    /**
     * Get a secret from the Secrets Store, returning a string of the secret value
     * if it exists, or throws an error if it does not exist
     */
    get(): Promise<string>;
}
declare module "cloudflare:sockets" {
    function _connect(address: string | SocketAddress, options?: SocketOptions): Socket;
    export { _connect as connect };
}
type ConversionResponse = {
    name: string;
    mimeType: string;
} & ({
    format: "markdown";
    tokens: number;
    data: string;
} | {
    format: "error";
    error: string;
});
type SupportedFileFormat = {
    mimeType: string;
    extension: string;
};
declare abstract class ToMarkdownService {
    transform(files: {
        name: string;
        blob: Blob;
    }[], options?: {
        gateway?: GatewayOptions;
        extraHeaders?: object;
    }): Promise<ConversionResponse[]>;
    transform(files: {
        name: string;
        blob: Blob;
    }, options?: {
        gateway?: GatewayOptions;
        extraHeaders?: object;
    }): Promise<ConversionResponse>;
    supported(): Promise<SupportedFileFormat[]>;
}
declare namespace TailStream {
    interface Header {
        readonly name: string;
        readonly value: string;
    }
    interface FetchEventInfo {
        readonly type: "fetch";
        readonly method: string;
        readonly url: string;
        readonly cfJson?: object;
        readonly headers: Header[];
    }
    interface JsRpcEventInfo {
        readonly type: "jsrpc";
    }
    interface ScheduledEventInfo {
        readonly type: "scheduled";
        readonly scheduledTime: Date;
        readonly cron: string;
    }
    interface AlarmEventInfo {
        readonly type: "alarm";
        readonly scheduledTime: Date;
    }
    interface QueueEventInfo {
        readonly type: "queue";
        readonly queueName: string;
        readonly batchSize: number;
    }
    interface EmailEventInfo {
        readonly type: "email";
        readonly mailFrom: string;
        readonly rcptTo: string;
        readonly rawSize: number;
    }
    interface TraceEventInfo {
        readonly type: "trace";
        readonly traces: (string | null)[];
    }
    interface HibernatableWebSocketEventInfoMessage {
        readonly type: "message";
    }
    interface HibernatableWebSocketEventInfoError {
        readonly type: "error";
    }
    interface HibernatableWebSocketEventInfoClose {
        readonly type: "close";
        readonly code: number;
        readonly wasClean: boolean;
    }
    interface HibernatableWebSocketEventInfo {
        readonly type: "hibernatableWebSocket";
        readonly info: HibernatableWebSocketEventInfoClose | HibernatableWebSocketEventInfoError | HibernatableWebSocketEventInfoMessage;
    }
    interface CustomEventInfo {
        readonly type: "custom";
    }
    interface FetchResponseInfo {
        readonly type: "fetch";
        readonly statusCode: number;
    }
    type EventOutcome = "ok" | "canceled" | "exception" | "unknown" | "killSwitch" | "daemonDown" | "exceededCpu" | "exceededMemory" | "loadShed" | "responseStreamDisconnected" | "scriptNotFound";
    interface ScriptVersion {
        readonly id: string;
        readonly tag?: string;
        readonly message?: string;
    }
    interface Onset {
        readonly type: "onset";
        readonly attributes: Attribute[];
        // id for the span being opened by this Onset event.
        readonly spanId: string;
        readonly dispatchNamespace?: string;
        readonly entrypoint?: string;
        readonly executionModel: string;
        readonly scriptName?: string;
        readonly scriptTags?: string[];
        readonly scriptVersion?: ScriptVersion;
        readonly info: FetchEventInfo | JsRpcEventInfo | ScheduledEventInfo | AlarmEventInfo | QueueEventInfo | EmailEventInfo | TraceEventInfo | HibernatableWebSocketEventInfo | CustomEventInfo;
    }
    interface Outcome {
        readonly type: "outcome";
        readonly outcome: EventOutcome;
        readonly cpuTime: number;
        readonly wallTime: number;
    }
    interface SpanOpen {
        readonly type: "spanOpen";
        readonly name: string;
        // id for the span being opened by this SpanOpen event.
        readonly spanId: string;
        readonly info?: FetchEventInfo | JsRpcEventInfo | Attributes;
    }
    interface SpanClose {
        readonly type: "spanClose";
        readonly outcome: EventOutcome;
    }
    interface DiagnosticChannelEvent {
        readonly type: "diagnosticChannel";
        readonly channel: string;
        readonly message: any;
    }
    interface Exception {
        readonly type: "exception";
        readonly name: string;
        readonly message: string;
        readonly stack?: string;
    }
    interface Log {
        readonly type: "log";
        readonly level: "debug" | "error" | "info" | "log" | "warn";
        readonly message: object;
    }
    // This marks the worker handler return information.
    // This is separate from Outcome because the worker invocation can live for a long time after
    // returning. For example - Websockets that return an http upgrade response but then continue
    // streaming information or SSE http connections.
    interface Return {
        readonly type: "return";
        readonly info?: FetchResponseInfo;
    }
    interface Attribute {
        readonly name: string;
        readonly value: string | string[] | boolean | boolean[] | number | number[] | bigint | bigint[];
    }
    interface Attributes {
        readonly type: "attributes";
        readonly info: Attribute[];
    }
    type EventType = Onset | Outcome | SpanOpen | SpanClose | DiagnosticChannelEvent | Exception | Log | Return | Attributes;
    // Context in which this trace event lives.
    interface SpanContext {
        // Single id for the entire top-level invocation
        // This should be a new traceId for the first worker stage invoked in the eyeball request and then
        // same-account service-bindings should reuse the same traceId but cross-account service-bindings
        // should use a new traceId.
        readonly traceId: string;
        // spanId in which this event is handled
        // for Onset and SpanOpen events this would be the parent span id
        // for Outcome and SpanClose these this would be the span id of the opening Onset and SpanOpen events
        // For Hibernate and Mark this would be the span under which they were emitted.
        // spanId is not set ONLY if:
        //  1. This is an Onset event
        //  2. We are not inherting any SpanContext. (e.g. this is a cross-account service binding or a new top-level invocation)
        readonly spanId?: string;
    }
    interface TailEvent<Event extends EventType> {
        // invocation id of the currently invoked worker stage.
        // invocation id will always be unique to every Onset event and will be the same until the Outcome event.
        readonly invocationId: string;
        // Inherited spanContext for this event.
        readonly spanContext: SpanContext;
        readonly timestamp: Date;
        readonly sequence: number;
        readonly event: Event;
    }
    type TailEventHandler<Event extends EventType = EventType> = (event: TailEvent<Event>) => void | Promise<void>;
    type TailEventHandlerObject = {
        outcome?: TailEventHandler<Outcome>;
        spanOpen?: TailEventHandler<SpanOpen>;
        spanClose?: TailEventHandler<SpanClose>;
        diagnosticChannel?: TailEventHandler<DiagnosticChannelEvent>;
        exception?: TailEventHandler<Exception>;
        log?: TailEventHandler<Log>;
        return?: TailEventHandler<Return>;
        attributes?: TailEventHandler<Attributes>;
    };
    type TailEventHandlerType = TailEventHandler | TailEventHandlerObject;
}
// Copyright (c) 2022-2023 Cloudflare, Inc.
// Licensed under the Apache 2.0 license found in the LICENSE file or at:
//     https://opensource.org/licenses/Apache-2.0
/**
 * Data types supported for holding vector metadata.
 */
type VectorizeVectorMetadataValue = string | number | boolean | string[];
/**
 * Additional information to associate with a vector.
 */
type VectorizeVectorMetadata = VectorizeVectorMetadataValue | Record<string, VectorizeVectorMetadataValue>;
type VectorFloatArray = Float32Array | Float64Array;
interface VectorizeError {
    code?: number;
    error: string;
}
/**
 * Comparison logic/operation to use for metadata filtering.
 *
 * This list is expected to grow as support for more operations are released.
 */
type VectorizeVectorMetadataFilterOp = "$eq" | "$ne";
/**
 * Filter criteria for vector metadata used to limit the retrieved query result set.
 */
type VectorizeVectorMetadataFilter = {
    [field: string]: Exclude<VectorizeVectorMetadataValue, string[]> | null | {
        [Op in VectorizeVectorMetadataFilterOp]?: Exclude<VectorizeVectorMetadataValue, string[]> | null;
    };
};
/**
 * Supported distance metrics for an index.
 * Distance metrics determine how other "similar" vectors are determined.
 */
type VectorizeDistanceMetric = "euclidean" | "cosine" | "dot-product";
/**
 * Metadata return levels for a Vectorize query.
 *
 * Default to "none".
 *
 * @property all      Full metadata for the vector return set, including all fields (including those un-indexed) without truncation. This is a more expensive retrieval, as it requires additional fetching & reading of un-indexed data.
 * @property indexed  Return all metadata fields configured for indexing in the vector return set. This level of retrieval is "free" in that no additional overhead is incurred returning this data. However, note that indexed metadata is subject to truncation (especially for larger strings).
 * @property none     No indexed metadata will be returned.
 */
type VectorizeMetadataRetrievalLevel = "all" | "indexed" | "none";
interface VectorizeQueryOptions {
    topK?: number;
    namespace?: string;
    returnValues?: boolean;
    returnMetadata?: boolean | VectorizeMetadataRetrievalLevel;
    filter?: VectorizeVectorMetadataFilter;
}
/**
 * Information about the configuration of an index.
 */
type VectorizeIndexConfig = {
    dimensions: number;
    metric: VectorizeDistanceMetric;
} | {
    preset: string; // keep this generic, as we'll be adding more presets in the future and this is only in a read capacity
};
/**
 * Metadata about an existing index.
 *
 * This type is exclusively for the Vectorize **beta** and will be deprecated once Vectorize RC is released.
 * See {@link VectorizeIndexInfo} for its post-beta equivalent.
 */
interface VectorizeIndexDetails {
    /** The unique ID of the index */
    readonly id: string;
    /** The name of the index. */
    name: string;
    /** (optional) A human readable description for the index. */
    description?: string;
    /** The index configuration, including the dimension size and distance metric. */
    config: VectorizeIndexConfig;
    /** The number of records containing vectors within the index. */
    vectorsCount: number;
}
/**
 * Metadata about an existing index.
 */
interface VectorizeIndexInfo {
    /** The number of records containing vectors within the index. */
    vectorCount: number;
    /** Number of dimensions the index has been configured for. */
    dimensions: number;
    /** ISO 8601 datetime of the last processed mutation on in the index. All changes before this mutation will be reflected in the index state. */
    processedUpToDatetime: number;
    /** UUIDv4 of the last mutation processed by the index. All changes before this mutation will be reflected in the index state. */
    processedUpToMutation: number;
}
/**
 * Represents a single vector value set along with its associated metadata.
 */
interface VectorizeVector {
    /** The ID for the vector. This can be user-defined, and must be unique. It should uniquely identify the object, and is best set based on the ID of what the vector represents. */
    id: string;
    /** The vector values */
    values: VectorFloatArray | number[];
    /** The namespace this vector belongs to. */
    namespace?: string;
    /** Metadata associated with the vector. Includes the values of other fields and potentially additional details. */
    metadata?: Record<string, VectorizeVectorMetadata>;
}
/**
 * Represents a matched vector for a query along with its score and (if specified) the matching vector information.
 */
type VectorizeMatch = Pick<Partial<VectorizeVector>, "values"> & Omit<VectorizeVector, "values"> & {
    /** The score or rank for similarity, when returned as a result */
    score: number;
};
/**
 * A set of matching {@link VectorizeMatch} for a particular query.
 */
interface VectorizeMatches {
    matches: VectorizeMatch[];
    count: number;
}
/**
 * Results of an operation that performed a mutation on a set of vectors.
 * Here, `ids` is a list of vectors that were successfully processed.
 *
 * This type is exclusively for the Vectorize **beta** and will be deprecated once Vectorize RC is released.
 * See {@link VectorizeAsyncMutation} for its post-beta equivalent.
 */
interface VectorizeVectorMutation {
    /* List of ids of vectors that were successfully processed. */
    ids: string[];
    /* Total count of the number of processed vectors. */
    count: number;
}
/**
 * Result type indicating a mutation on the Vectorize Index.
 * Actual mutations are processed async where the `mutationId` is the unique identifier for the operation.
 */
interface VectorizeAsyncMutation {
    /** The unique identifier for the async mutation operation containing the changeset. */
    mutationId: string;
}
/**
 * A Vectorize Vector Search Index for querying vectors/embeddings.
 *
 * This type is exclusively for the Vectorize **beta** and will be deprecated once Vectorize RC is released.
 * See {@link Vectorize} for its new implementation.
 */
declare abstract class VectorizeIndex {
    /**
     * Get information about the currently bound index.
     * @returns A promise that resolves with information about the current index.
     */
    public describe(): Promise<VectorizeIndexDetails>;
    /**
     * Use the provided vector to perform a similarity search across the index.
     * @param vector Input vector that will be used to drive the similarity search.
     * @param options Configuration options to massage the returned data.
     * @returns A promise that resolves with matched and scored vectors.
     */
    public query(vector: VectorFloatArray | number[], options?: VectorizeQueryOptions): Promise<VectorizeMatches>;
    /**
     * Insert a list of vectors into the index dataset. If a provided id exists, an error will be thrown.
     * @param vectors List of vectors that will be inserted.
     * @returns A promise that resolves with the ids & count of records that were successfully processed.
     */
    public insert(vectors: VectorizeVector[]): Promise<VectorizeVectorMutation>;
    /**
     * Upsert a list of vectors into the index dataset. If a provided id exists, it will be replaced with the new values.
     * @param vectors List of vectors that will be upserted.
     * @returns A promise that resolves with the ids & count of records that were successfully processed.
     */
    public upsert(vectors: VectorizeVector[]): Promise<VectorizeVectorMutation>;
    /**
     * Delete a list of vectors with a matching id.
     * @param ids List of vector ids that should be deleted.
     * @returns A promise that resolves with the ids & count of records that were successfully processed (and thus deleted).
     */
    public deleteByIds(ids: string[]): Promise<VectorizeVectorMutation>;
    /**
     * Get a list of vectors with a matching id.
     * @param ids List of vector ids that should be returned.
     * @returns A promise that resolves with the raw unscored vectors matching the id set.
     */
    public getByIds(ids: string[]): Promise<VectorizeVector[]>;
}
/**
 * A Vectorize Vector Search Index for querying vectors/embeddings.
 *
 * Mutations in this version are async, returning a mutation id.
 */
declare abstract class Vectorize {
    /**
     * Get information about the currently bound index.
     * @returns A promise that resolves with information about the current index.
     */
    public describe(): Promise<VectorizeIndexInfo>;
    /**
     * Use the provided vector to perform a similarity search across the index.
     * @param vector Input vector that will be used to drive the similarity search.
     * @param options Configuration options to massage the returned data.
     * @returns A promise that resolves with matched and scored vectors.
     */
    public query(vector: VectorFloatArray | number[], options?: VectorizeQueryOptions): Promise<VectorizeMatches>;
    /**
     * Use the provided vector-id to perform a similarity search across the index.
     * @param vectorId Id for a vector in the index against which the index should be queried.
     * @param options Configuration options to massage the returned data.
     * @returns A promise that resolves with matched and scored vectors.
     */
    public queryById(vectorId: string, options?: VectorizeQueryOptions): Promise<VectorizeMatches>;
    /**
     * Insert a list of vectors into the index dataset. If a provided id exists, an error will be thrown.
     * @param vectors List of vectors that will be inserted.
     * @returns A promise that resolves with a unique identifier of a mutation containing the insert changeset.
     */
    public insert(vectors: VectorizeVector[]): Promise<VectorizeAsyncMutation>;
    /**
     * Upsert a list of vectors into the index dataset. If a provided id exists, it will be replaced with the new values.
     * @param vectors List of vectors that will be upserted.
     * @returns A promise that resolves with a unique identifier of a mutation containing the upsert changeset.
     */
    public upsert(vectors: VectorizeVector[]): Promise<VectorizeAsyncMutation>;
    /**
     * Delete a list of vectors with a matching id.
     * @param ids List of vector ids that should be deleted.
     * @returns A promise that resolves with a unique identifier of a mutation containing the delete changeset.
     */
    public deleteByIds(ids: string[]): Promise<VectorizeAsyncMutation>;
    /**
     * Get a list of vectors with a matching id.
     * @param ids List of vector ids that should be returned.
     * @returns A promise that resolves with the raw unscored vectors matching the id set.
     */
    public getByIds(ids: string[]): Promise<VectorizeVector[]>;
}
/**
 * The interface for "version_metadata" binding
 * providing metadata about the Worker Version using this binding.
 */
type WorkerVersionMetadata = {
    /** The ID of the Worker Version using this binding */
    id: string;
    /** The tag of the Worker Version using this binding */
    tag: string;
    /** The timestamp of when the Worker Version was uploaded */
    timestamp: string;
};
interface DynamicDispatchLimits {
    /**
     * Limit CPU time in milliseconds.
     */
    cpuMs?: number;
    /**
     * Limit number of subrequests.
     */
    subRequests?: number;
}
interface DynamicDispatchOptions {
    /**
     * Limit resources of invoked Worker script.
     */
    limits?: DynamicDispatchLimits;
    /**
     * Arguments for outbound Worker script, if configured.
     */
    outbound?: {
        [key: string]: any;
    };
}
interface DispatchNamespace {
    /**
    * @param name Name of the Worker script.
    * @param args Arguments to Worker script.
    * @param options Options for Dynamic Dispatch invocation.
    * @returns A Fetcher object that allows you to send requests to the Worker script.
    * @throws If the Worker script does not exist in this dispatch namespace, an error will be thrown.
    */
    get(name: string, args?: {
        [key: string]: any;
    }, options?: DynamicDispatchOptions): Fetcher;
}
declare module 'cloudflare:workflows' {
    /**
     * NonRetryableError allows for a user to throw a fatal error
     * that makes a Workflow instance fail immediately without triggering a retry
     */
    export class NonRetryableError extends Error {
        public constructor(message: string, name?: string);
    }
}
declare abstract class Workflow<PARAMS = unknown> {
    /**
     * Get a handle to an existing instance of the Workflow.
     * @param id Id for the instance of this Workflow
     * @returns A promise that resolves with a handle for the Instance
     */
    public get(id: string): Promise<WorkflowInstance>;
    /**
     * Create a new instance and return a handle to it. If a provided id exists, an error will be thrown.
     * @param options Options when creating an instance including id and params
     * @returns A promise that resolves with a handle for the Instance
     */
    public create(options?: WorkflowInstanceCreateOptions<PARAMS>): Promise<WorkflowInstance>;
    /**
     * Create a batch of instances and return handle for all of them. If a provided id exists, an error will be thrown.
     * `createBatch` is limited at 100 instances at a time or when the RPC limit for the batch (1MiB) is reached.
     * @param batch List of Options when creating an instance including name and params
     * @returns A promise that resolves with a list of handles for the created instances.
     */
    public createBatch(batch: WorkflowInstanceCreateOptions<PARAMS>[]): Promise<WorkflowInstance[]>;
}
type WorkflowDurationLabel = 'second' | 'minute' | 'hour' | 'day' | 'week' | 'month' | 'year';
type WorkflowSleepDuration = `${number} ${WorkflowDurationLabel}${'s' | ''}` | number;
type WorkflowRetentionDuration = WorkflowSleepDuration;
interface WorkflowInstanceCreateOptions<PARAMS = unknown> {
    /**
     * An id for your Workflow instance. Must be unique within the Workflow.
     */
    id?: string;
    /**
     * The event payload the Workflow instance is triggered with
     */
    params?: PARAMS;
    /**
     * The retention policy for Workflow instance.
     * Defaults to the maximum retention period available for the owner's account.
     */
    retention?: {
        successRetention?: WorkflowRetentionDuration;
        errorRetention?: WorkflowRetentionDuration;
    };
}
type InstanceStatus = {
    status: 'queued' // means that instance is waiting to be started (see concurrency limits)
     | 'running' | 'paused' | 'errored' | 'terminated' // user terminated the instance while it was running
     | 'complete' | 'waiting' // instance is hibernating and waiting for sleep or event to finish
     | 'waitingForPause' // instance is finishing the current work to pause
     | 'unknown';
    error?: string;
    output?: object;
};
interface WorkflowError {
    code?: number;
    message: string;
}
declare abstract class WorkflowInstance {
    public id: string;
    /**
     * Pause the instance.
     */
    public pause(): Promise<void>;
    /**
     * Resume the instance. If it is already running, an error will be thrown.
     */
    public resume(): Promise<void>;
    /**
     * Terminate the instance. If it is errored, terminated or complete, an error will be thrown.
     */
    public terminate(): Promise<void>;
    /**
     * Restart the instance.
     */
    public restart(): Promise<void>;
    /**
     * Returns the current status of the instance.
     */
    public status(): Promise<InstanceStatus>;
    /**
     * Send an event to this instance.
     */
    public sendEvent({ type, payload, }: {
        type: string;
        payload: unknown;
    }): Promise<void>;
}
</file>

<file path="hyperdrive-tutorial/wrangler.jsonc">
/**
 * For more details on how to configure Wrangler, refer to:
 * https://developers.cloudflare.com/workers/wrangler/configuration/
 */
{
	"$schema": "node_modules/wrangler/config-schema.json",
	"name": "rushes-hyperdrive",
	"main": "src/index.ts",
	"compatibility_flags": ["nodejs_compat"],
	"compatibility_date": "2025-10-23",
	"observability": {
		"enabled": true
	}
	/**
	 * Smart Placement
	 * Docs: https://developers.cloudflare.com/workers/configuration/smart-placement/#smart-placement
	 */
	// "placement": { "mode": "smart" }
	/**
	 * Bindings
	 * Bindings allow your Worker to interact with resources on the Cloudflare Developer Platform, including
	 * databases, object storage, AI inference, real-time communication and more.
	 * https://developers.cloudflare.com/workers/runtime-apis/bindings/
	 */
	/**
	 * Environment Variables
	 * https://developers.cloudflare.com/workers/wrangler/configuration/#environment-variables
	 */
	// "vars": { "MY_VARIABLE": "production_value" }
	/**
	 * Note: Use secrets to store sensitive data.
	 * https://developers.cloudflare.com/workers/configuration/secrets/
	 */
	/**
	 * Static Assets
	 * https://developers.cloudflare.com/workers/static-assets/binding/
	 */
	// "assets": { "directory": "./public/", "binding": "ASSETS" }
	/**
	 * Service Bindings (communicate between multiple Workers)
	 * https://developers.cloudflare.com/workers/wrangler/configuration/#service-bindings
	 */
	// "services": [{ "binding": "MY_SERVICE", "service": "my-service" }]
}
</file>

<file path="src/lib/components/dashboard/DashboardPanel.svelte">
<script lang="ts">
	import { slide } from 'svelte/transition';
	import { SHADOW_ITEM_MARKER_PROPERTY_NAME } from 'svelte-dnd-action';
	import { selectedVideo } from '$lib/stores/selectedVideo';
	import Map from '$lib/components/Map.svelte';
	import { authStore } from '$lib/stores/auth';
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		TableKey,
		TableState
	} from '$lib/types/dashboard';

	interface ProfileMetrics {
		videos: number;
		sounds: number;
		duration: string;
		likes: number;
	}

	interface ActivityItem {
		id: string;
		user: string;
		action: string;
		content: string;
		type: 'like' | 'comment' | string;
		time: string;
	}

	const {
		item,
		collapsed,
		toggleCollapse,
		tableState,
		sortedVideoRows,
		sortedSoundRows,
		sortedMemberRows,
		sortedKeywordRows,
		toggleSort,
		openVideo,
		handleVideoRowKey,
		liveActivity,
		formatStat,
		latestLocations,
		locationCenter,
		profileStats
	} = $props<{
		item: DashboardItem;
		collapsed: Record<DashboardComponentKey, boolean>;
		toggleCollapse: (component: DashboardComponentKey) => void;
		tableState: Record<TableKey, TableState>;
		sortedVideoRows: any[];
		sortedSoundRows: any[];
		sortedMemberRows: any[];
		sortedKeywordRows: any[];
		toggleSort: (table: TableKey, columnKey: string) => void;
		openVideo: (video: any, event?: MouseEvent) => void;
		handleVideoRowKey: (event: KeyboardEvent, video: any) => void;
		liveActivity: ActivityItem[];
		formatStat: (num: number) => string;
		latestLocations: LatestLocationPin[];
		locationCenter: LocationCenter;
		profileStats: ProfileMetrics;
	}>();

	const isShadow = $derived(Boolean(item[SHADOW_ITEM_MARKER_PROPERTY_NAME]));

const mapPins = $derived(
	(() =>
		latestLocations.map((loc: LatestLocationPin) => ({
			mapLat: loc.lat,
			mapLon: loc.lon,
			setting: loc.setting,
			name: loc.setting,
			videoTitle: loc.videoTitle,
			videoAuthor: loc.videoAuthor
		}))
	)()
);

	const auth = $derived($authStore);

	function createUserId() {
		if (typeof crypto !== 'undefined' && 'randomUUID' in crypto) {
			return crypto.randomUUID();
		}
		return `user-${Math.random().toString(36).slice(2, 10)}`;
	}

	function resolveAvatar(email: string, avatarUrl?: string) {
		if (avatarUrl) return avatarUrl;
		return `https://i.pravatar.cc/150?u=${encodeURIComponent(email)}`;
	}

	let displayName = $state('');
	let email = $state('');
	let isSubmitting = $state(false);
	let errorMessage = $state<string | null>(null);

	const EMAIL_REGEX = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
	const MAX_NAME_LENGTH = 100;
	const MAX_EMAIL_LENGTH = 254; // RFC 5321

	function handleAuthSubmit(event: Event) {
		event.preventDefault();
		const nameValue = displayName.trim();
		const emailValue = email.trim().toLowerCase();
		errorMessage = null;

		// Validate name
		if (!nameValue) {
			errorMessage = 'Please enter your name.';
			return;
		}

		if (nameValue.length > MAX_NAME_LENGTH) {
			errorMessage = `Name must be ${MAX_NAME_LENGTH} characters or less.`;
			return;
		}

		// Validate email
		if (!emailValue) {
			errorMessage = 'Please enter your email address.';
			return;
		}

		if (emailValue.length > MAX_EMAIL_LENGTH) {
			errorMessage = 'Email address is too long.';
			return;
		}

		if (!EMAIL_REGEX.test(emailValue)) {
			errorMessage = 'Please enter a valid email address.';
			return;
		}

		isSubmitting = true;
		try {
			authStore.login({
				id: createUserId(),
				name: nameValue,
				email: emailValue,
				avatarUrl: resolveAvatar(emailValue)
			});
			displayName = '';
			email = '';
		} finally {
			isSubmitting = false;
		}
	}

	function handleLogout() {
		authStore.logout();
	}
</script>

{#if isShadow}
	<div class="panel-placeholder" />
{:else if item.component === 'videos'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab" aria-label="Drag panel">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">{$selectedVideo.id ? 'Next in Queue' : 'Suggested Rushes'}</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.videos.sortKey.toUpperCase()} [{tableState.videos.sortDirection.toUpperCase()}]</span>
				<button onclick={() => toggleCollapse('videos')}>{collapsed.videos ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.videos}
			<div transition:slide>
				{#if sortedVideoRows.length === 0}
					<p class="mt-6 text-[11px] text-slate-500">The queue is clear—add new rushes to keep production moving.</p>
				{:else}
					{@const next = sortedVideoRows[0]}
					<div class="mt-6 min-w-0 rounded-2xl overflow-hidden border border-white/10 bg-black/30">
						<div class="flex w-full flex-col gap-5 ">
							<img
								src={next.original.thumbnailUrl ?? 'https://placehold.co/640x360?text=Rushes'}
								alt={next.title}
								class="h-30 w-full object-cover transition duration-300 group-hover:scale-105"
								loading="lazy"
							/>
							<div class="flex min-w-0 flex-1 flex-col justify-between pb-4 px-4">
								<h3 class=" text-lg font-medium text-white">{next.title}</h3>

								<div class="grid min-w-0 mt-0 gap-2 text-[11px] text-slate-300 sm:grid-cols-2">
									<span class="flex items-center gap-2"><span class="h-1.5 w-1.5 rounded-full bg-sky-400"></span> By {next.author}</span>
									<span>{next.uploaded}</span>
								</div>
							</div>
						</div>
					</div>
					<div class="mt-6 min-w-0 space-y-4">
						<div class="grid min-w-0 gap-3 sm:grid-cols-2">
							{#each sortedVideoRows.slice(1, 5) as row, index (row.id)}
									<button
										type="button"
										class="group flex min-w-0 items-center gap-4 rounded-lg overflow-hidden border border-white/5 bg-white/[0.06] text-left transition hover:border-white/15 hover:bg-white/[0.1]"
										onclick={(event) => openVideo(row.original, event)}
										onkeydown={(event) => handleVideoRowKey(event, row.original)}
									>
								<div class="flex flex-col items-center">
										<img
											src={row.original.thumbnailUrl ?? 'https://placehold.co/160x90?text=Rushes'}
											alt={row.title}
											class="h-20 w-full object-cover transition duration-300 group-hover:scale-105"
											loading="lazy"
										/>
										
									<div class="flex flex-col w-full p-3">
										<p class="text-sm font-medium m-0 text-white">{row.title}</p>
										<div class="flex flex-col text-[11px] text-slate-400">
											<span>{row.author}</span>
										</div>
									</div>
									</div>

								</button>
							{/each}
						</div>
						{#if sortedVideoRows.length <= 1}<p class="text-[11px] text-slate-500">No additional items in the queue.</p>{/if}
					</div>
				{/if}
			</div>
		{/if}
	</section>
{:else if item.component === 'profile'}
	<section class="min-w-0  border border-white/10 bg-white/[0.06] p-6 shadow-[0_24px_80px_-48px_rgba(8,47,73,0.85)] backdrop-blur-md">
		{#if auth.user}
			<div class="space-y-6">
				<div class="flex flex-col gap-4 sm:flex-row sm:items-center sm:justify-between">
					<div class="flex items-center gap-4">
						<img
							src={resolveAvatar(auth.user.email, auth.user.avatarUrl)}
							alt="User avatar"
							class="h-16 w-16 rounded-full border-2 border-white/20 object-cover shadow-[0_12px_32px_-18px_rgba(56,189,248,0.65)]"
						/>
						<div>
							<h3 class="text-lg font-semibold text-white">Welcome back, {auth.user.name}</h3>
							<p class="text-sm text-slate-400">{auth.user.email}</p>
						</div>
					</div>
					<button
						class="rounded-full border border-white/15 bg-white/[0.08] px-5 py-2 text-[11px] uppercase tracking-[0.3em] text-slate-200 transition hover:border-white/30 hover:bg-white/[0.14] hover:text-white"
						type="button"
						onclick={handleLogout}
					>
						Sign out
					</button>
				</div>

				<div class="grid grid-cols-2 gap-4">
					{#each [
						{ label: 'VIDEOS', value: formatStat(profileStats.videos) },
						{ label: 'SOUNDS', value: formatStat(profileStats.sounds) },
						{ label: 'TOTAL DURATION', value: profileStats.duration },
						{ label: 'LIKES', value: formatStat(profileStats.likes) }
					] as metric (metric.label)}
						<div class="rounded-2xl border border-white/10 bg-black/25 px-4 py-3 text-left shadow-[0_12px_48px_-36px_rgba(56,189,248,0.45)]">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-400">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>

				<p class="text-[11px] uppercase tracking-[0.3em] text-slate-500">Account controls coming soon.</p>
			</div>
		{:else}
			<div class="space-y-6">
				<div>
					<h3 class="text-lg font-semibold text-white">Join Rushes</h3>
					<p class="mt-1 text-sm text-slate-400">Create an account to sync playlists, follow curators, and save notes.</p>
				</div>
		<form
			class="space-y-4"
			onsubmit={(event) => {
				event.preventDefault();
				handleAuthSubmit(event);
			}}
		>
					<div class="space-y-2">
						<label class="text-[10px] uppercase tracking-[0.3em] text-slate-500" for="dashboard-name">Name</label>
						<input
							id="dashboard-name"
							name="name"
							type="text"
							bind:value={displayName}
							placeholder="Alex Rivera"
							class="w-full rounded-xl border border-white/15 bg-white/[0.08] px-3 py-2 text-sm text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/40 focus:border-transparent"
						/>
					</div>
					<div class="space-y-2">
						<label class="text-[10px] uppercase tracking-[0.3em] text-slate-500" for="dashboard-email">Email</label>
						<input
							id="dashboard-email"
							name="email"
							type="email"
							bind:value={email}
							placeholder="alex@rushes.fm"
							class="w-full rounded-xl border border-white/15 bg-white/[0.08] px-3 py-2 text-sm text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-sky-400/40 focus:border-transparent"
						/>
					</div>
					{#if errorMessage}
						<p class="text-xs text-rose-400">{errorMessage}</p>
					{/if}
					<button
						type="submit"
						class="w-full rounded-full bg-gradient-to-r from-sky-500 to-purple-500 px-5 py-2 text-[11px] uppercase tracking-[0.35em] text-white shadow-[0_18px_48px_-24px_rgba(56,189,248,0.8)] transition hover:opacity-90 disabled:opacity-50"
						disabled={isSubmitting}
					>
						{isSubmitting ? "Creating account…" : "Create account"}
					</button>
				</form>
				<p class="text-xs text-slate-500">
					We’ll remember your session in this workspace. No actual emails are sent—this is a mock authentication flow.
				</p>
			</div>
		{/if}
	</section>
{:else if item.component === 'activity'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex items-center justify-between">
			<div class="flex items-center gap-4">
		<button class="cursor-grab" aria-label="Drag panel">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Live Activity</p>
			</div>
			<button onclick={() => toggleCollapse('activity')}>{collapsed.activity ? '+' : '-'}</button>
		</header>
		{#if !collapsed.activity}
			<div class="mt-4 space-y-3" transition:slide>
				{#each liveActivity as event (event.id)}
					<div class="flex items-center gap-4 rounded-xl bg-black/20 p-3">
						<div class="flex h-8 w-8 items-center justify-center rounded-full bg-white/5">
							{#if event.type === 'like'}
								<svg class="h-4 w-4 text-pink-400" viewBox="0 0 20 20" fill="currentColor">
									<path d="M9.653 16.915l-.005-.003-.019-.01a20.759 20.759 0 01-1.162-.682 22.045 22.045 0 01-2.582-1.9 22.045 22.045 0 01-2.582-1.9A20.759 20.759 0 013 12.311l-.01-.019a1.002 1.002 0 010-1.415l.006-.006a1 1 0 011.414 0l.006.006a6.67 6.67 0 001.036.634 8.67 8.67 0 005.188 0 6.67 6.67 0 001.036-.634l.006-.006a1 1 0 011.414 0l.006.006a1.002 1.002 0 010 1.415l-.01.019a20.759 20.759 0 01-1.162.682 22.045 22.045 0 01-2.582 1.9 22.045 22.045 0 01-2.582 1.9 20.759 20.759 0 01-1.162.682zM10 11.973a8.67 8.67 0 00-5.188 0 6.67 6.67 0 00-1.036.634l-.006.006a1 1 0 01-1.414 0l-.006-.006a1.002 1.002 0 010-1.415l.01-.019a20.759 20.759 0 011.162-.682 22.045 22.045 0 012.582-1.9 22.045 22.045 0 012.582-1.9A20.759 20.759 0 0110 3.689a1 1 0 011.415 0l.01.01a20.759 20.759 0 011.162.682 22.045 22.045 0 012.582 1.9 22.045 22.045 0 012.582 1.9 20.759 20.759 0 011.162.682l.01.019a1.002 1.002 0 010 1.415l-.006.006a1 1 0 01-1.414 0l-.006-.006a6.67 6.67 0 00-1.036-.634 8.67 8.67 0 00-5.188 0z" />
								</svg>
							{:else}
								<svg class="h-4 w-4 text-sky-400" viewBox="0 0 20 20" fill="currentColor">
									<path fill-rule="evenodd" d="M10 2c-4.418 0-8 3.134-8 7 0 2.033.944 3.863 2.451 5.116a.75.75 0 00.916-1.185A6.47 6.47 0 014.5 9c0-2.899 2.529-5.25 5.5-5.25s5.5 2.351 5.5 5.25c0 1.258-.468 2.404-1.255 3.284a.75.75 0 101.185.916A7.962 7.962 0 0018 9c0-3.866-3.582-7-8-7z" clip-rule="evenodd" />
									<path d="M12.249 14.126a.75.75 0 01.393.972l-1.5 3a.75.75 0 01-1.284-.64l1.5-3a.75.75 0 01.891-.332z" />
									<path d="M14 11.25a.75.75 0 01.75.75v2.5a.75.75 0 01-1.5 0v-2.5a.75.75 0 01.75-.75z" />
									<path d="M8.25 15.126a.75.75 0 01.891.332l1.5 3a.75.75 0 11-1.284.64l-1.5-3a.75.75 0 01.393-.972z" />
									<path d="M6.25 12a.75.75 0 011.5 0v2.5a.75.75 0 01-1.5 0v-2.5z" />
								</svg>
							{/if}
						</div>
						<div class="flex-1 text-xs">
							<p class="text-slate-300">
								<span class="font-semibold text-white">{event.user}</span> {event.action} <span class="font-semibold text-white">“{event.content}”</span>
							</p>
							<p class="text-slate-500">{event.time}</p>
						</div>
					</div>
				{/each}
			</div>
		{/if}
	</section>
{:else if item.component === 'sounds'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
		<button class="cursor-grab" aria-label="Drag panel">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Latest Sounds</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.sounds.sortKey.toUpperCase()} [{tableState.sounds.sortDirection.toUpperCase()}]</span>
				<button onclick={() => toggleCollapse('sounds')}>{collapsed.sounds ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.sounds}
			<div class="mt-4 min-w-0 rounded-2xl border border-white/10 bg-black/20" transition:slide>
				<div class="min-w-0 overflow-x-auto rounded-2xl">
					<table class="min-w-full border-collapse text-left text-[12px] leading-snug">
						<thead class="bg-white/5 text-slate-500">
							<tr>
								{#each tableState.sounds.columns as column}
									<th scope="col" class={`px-4 py-3 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
										<button
											type="button"
											class="flex items-center gap-2 text-[11px] uppercase tracking-[0.25em] text-slate-500 transition hover:text-slate-200"
											onclick={() => toggleSort('sounds', column.key)}
										>
											<span>{column.label}</span>
											{#if tableState.sounds.sortKey === column.key}<span aria-hidden="true">{tableState.sounds.sortDirection === 'asc' ? '▲' : '▼'}</span>{/if}
										</button>
									</th>
								{/each}
							</tr>
						</thead>
						<tbody class="bg-black/20">
							{#each sortedSoundRows as row, index (row.id)}
								<tr class={`${index % 2 === 0 ? 'bg-white/[0.04]' : ''}`}>
									{#each tableState.sounds.columns as column}
										<td class={`px-4 py-3 text-slate-200 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
											{#if column.key === 'title'}<span class="text-slate-100">{row.title}</span>
											{:else if column.key === 'recordist'}<span>{row.recordist}</span>
											{:else if column.key === 'captured'}<span>{row.captured}</span>
											{:else if column.key === 'duration'}<span>{row.duration}</span>{/if}
										</td>
									{/each}
								</tr>
							{/each}
						</tbody>
					</table>
				</div>
			</div>
		{/if}
	</section>
{:else if item.component === 'members'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
		<button class="cursor-grab" aria-label="Drag panel">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Members</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.members.sortKey.toUpperCase()} [{tableState.members.sortDirection.toUpperCase()}]</span>
				<button onclick={() => toggleCollapse('members')}>{collapsed.members ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.members}
			<div class="mt-4 min-w-0 rounded-2xl border border-white/10 bg-black/20" transition:slide>
				<div class="min-w-0 overflow-x-auto rounded-2xl">
					<table class="min-w-full border-collapse text-left text-[12px] leading-snug">
						<thead class="bg-white/5 text-slate-500">
							<tr>
								{#each tableState.members.columns as column}
									<th scope="col" class={`px-4 py-3 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
										<button
											type="button"
											class="flex items-center gap-2 text-[11px] uppercase tracking-[0.25em] text-slate-500 transition hover:text-slate-200"
											onclick={() => toggleSort('members', column.key)}
										>
											<span>{column.label}</span>
											{#if tableState.members.sortKey === column.key}<span aria-hidden="true">{tableState.members.sortDirection === 'asc' ? '▲' : '▼'}</span>{/if}
										</button>
									</th>
								{/each}
							</tr>
						</thead>
						<tbody class="bg-black/20">
							{#each sortedMemberRows as row, index (row.id)}
								<tr class={`${index % 2 === 0 ? 'bg-white/[0.04]' : ''}`}>
									{#each tableState.members.columns as column}
										<td class={`px-4 py-3 text-slate-200 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
											{#if column.key === 'name'}<span class="text-slate-100">{row.name}</span>
											{:else if column.key === 'videos'}<span>{row.videos}</span>
											{:else if column.key === 'followers'}<span>{row.followers}</span>
											{:else if column.key === 'following'}<span>{row.following}</span>
											{:else if column.key === 'joined'}<span>{row.joined}</span>{/if}
										</td>
									{/each}
								</tr>
							{/each}
						</tbody>
					</table>
				</div>
			</div>
		{/if}
	</section>
{:else if item.component === 'keywords'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
		<button class="cursor-grab" aria-label="Drag panel">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Keywords</p>
				</div>
			</div>
			<div class="flex items-center gap-4">
				<span class="text-[11px] text-slate-500">SORT {tableState.keywords.sortKey.toUpperCase()} [{tableState.keywords.sortDirection.toUpperCase()}]</span>
				<button onclick={() => toggleCollapse('keywords')}>{collapsed.keywords ? '+' : '-'}</button>
			</div>
		</header>
		{#if !collapsed.keywords}
			<div class="mt-4 min-w-0 rounded-2xl border border-white/10 bg-black/20" transition:slide>
				<div class="min-w-0 overflow-x-auto rounded-2xl">
					<table class="min-w-full border-collapse text-left text-[12px] leading-snug">
						<thead class="bg-white/5 text-slate-500">
							<tr>
								{#each tableState.keywords.columns as column}
									<th scope="col" class={`px-4 py-3 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
										<button
											type="button"
											class="flex items-center gap-2 text-[11px] uppercase tracking-[0.25em] text-slate-500 transition hover:text-slate-200"
											onclick={() => toggleSort('keywords', column.key)}
										>
											<span>{column.label}</span>
											{#if tableState.keywords.sortKey === column.key}<span aria-hidden="true">{tableState.keywords.sortDirection === 'asc' ? '▲' : '▼'}</span>{/if}
										</button>
									</th>
								{/each}
							</tr>
						</thead>
						<tbody class="bg-black/20">
							{#each sortedKeywordRows as row, index (row.keyword)}
								<tr class={`${index % 2 === 0 ? 'bg-white/[0.04]' : ''}`}>
									{#each tableState.keywords.columns as column}
										<td class={`px-4 py-3 text-slate-200 ${column.align === 'right' ? 'text-right' : 'text-left'}`}>
											{#if column.key === 'keyword'}<span class="text-slate-100">{row.keyword}</span>
											{:else if column.key === 'usage'}<span>{row.usage.toString().padStart(2, '0')}</span>
											{:else if column.key === 'related'}<span class="text-[10px] text-slate-400/80">{row.related}</span>{/if}
										</td>
									{/each}
								</tr>
							{/each}
						</tbody>
					</table>
				</div>
			</div>
		{/if}
	</section>
{:else if item.component === 'locations'}
	<section class="min-w-0 border border-white/10 bg-white/[0.04] p-6">
		<header class="flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between">
			<div class="flex items-center gap-4">
				<button class="cursor-grab">
					<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" class="text-slate-500">
						<path d="M6 4h1v1H6V4zm3 0h1v1H9V4zM6 7h1v1H6V7zm3 0h1v1H9V7zm-3 3h1v1H6v-1zm3 3h1v1H9v-1zm0-3h1v1H9v-1z" fill="currentColor"></path>
					</svg>
				</button>
				<div>
					<p class="text-[10px] uppercase tracking-[0.35em] text-slate-500">Latest Locations</p>
					<p class="text-[11px] text-slate-500/70">Recent shoots plotted across the Rushes.fm map.</p>
				</div>
			</div>
			<button onclick={() => toggleCollapse('locations')}>{collapsed.locations ? '+' : '-'}</button>
		</header>
		{#if !collapsed.locations}
			<div class="mt-5 grid gap-6 lg:grid-cols-5" transition:slide>
				<div class="relative min-h-[18rem] overflow-hidden rounded-2xl border border-white/10 bg-black/30 lg:col-span-3">
					<Map
						locations={mapPins}
						initialCenterLat={locationCenter.lat}
						initialCenterLon={locationCenter.lon}
						initialZoom={locationCenter.zoom}
					/>
				</div>
				<div class="space-y-4 lg:col-span-2">
					{#if latestLocations.length === 0}
						<p class="text-[11px] text-slate-500">No geo-tagged videos yet. Pins appear here once locations are available.</p>
					{:else}
						<ul class="space-y-3">
							{#each latestLocations as loc (loc.id)}
								<li class="flex items-start gap-3 rounded-2xl border border-white/10 bg-white/[0.05] p-3">
									{#if loc.thumbnailUrl}
										<img src={loc.thumbnailUrl} alt={loc.videoTitle} class="h-12 w-12 flex-shrink-0 rounded-xl object-cover" loading="lazy" />
									{:else}
										<div class="flex h-12 w-12 flex-shrink-0 items-center justify-center rounded-xl bg-white/10 text-[11px] uppercase tracking-[0.3em] text-white">
											{loc.videoTitle.slice(0, 2)}
										</div>
									{/if}
									<div class="min-w-0 flex-1 space-y-1">
										<p class="text-sm font-medium text-white">{loc.videoTitle}</p>
										<p class="text-[11px] uppercase tracking-[0.25em] text-slate-500">{loc.setting ?? 'On location'}</p>
										<div class="flex flex-wrap gap-3 text-[11px] text-slate-400">
											{#if loc.videoAuthor}<span>{loc.videoAuthor}</span>{/if}
											<span>{loc.uploadedLabel}</span>
										</div>
									</div>
								</li>
							{/each}
						</ul>
					{/if}
				</div>
			</div>
		{/if}
	</section>
{/if}

<style>
	.panel-placeholder {
		min-height: 4rem;
		border-radius: 1rem;
		border: 1px dashed rgba(148, 163, 184, 0.3);
		background-color: rgba(15, 23, 42, 0.2);
	}
</style>
</file>

<file path="src/lib/components/home/AuthSection.svelte">
<script lang="ts">
  let showSignIn = $state(false);
  let showSignUp = $state(false);
  
  // Form states
  let signInForm = $state({
    email: '',
    password: ''
  });
  
  let signUpForm = $state({
    name: '',
    email: '',
    password: '',
    confirmPassword: ''
  });
  
  function toggleSignIn() {
    showSignIn = !showSignIn;
    showSignUp = false;
  }
  
  function toggleSignUp() {
    showSignUp = !showSignUp;
    showSignIn = false;
  }
  
  function handleSignIn(e: Event) {
    e.preventDefault();
    console.log('Sign in:', signInForm);
    // TODO: Implement sign in logic
  }
  
  function handleSignUp(e: Event) {
    e.preventDefault();
    console.log('Sign up:', signUpForm);
    // TODO: Implement sign up logic
  }

  // Export functions for external use
  export function openSignIn() {
    showSignIn = true;
    showSignUp = false;
  }

  export function openSignUp() {
    showSignUp = true;
    showSignIn = false;
  }
</script>

<section class="mb-16">
  <div class="text-center mb-8">
    <h2 class="text-2xl font-semibold text-gray-900 dark:text-white mb-4">
      Join the Community
    </h2>
    <p class="text-gray-600 dark:text-gray-400 mb-6">
      Sign up to share your videos, discover new content, and connect with creators
    </p>
    
    <!-- Auth Toggle Buttons -->
    <div class="flex items-center justify-center gap-4">
      <button 
        onclick={toggleSignUp}
        class="rounded-full bg-blue-600 px-6 py-3 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
      >
        Create Account
      </button>
      <button 
        onclick={toggleSignIn}
        class="rounded-full border border-gray-300 dark:border-gray-600 px-6 py-3 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
      >
        Sign In
      </button>
    </div>
  </div>

  <!-- Sign Up Form -->
  {#if showSignUp}
    <div class="mx-auto max-w-md">
      <div class="rounded-xl bg-gray-50 dark:bg-gray-900 p-6 border border-gray-200 dark:border-gray-800">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Create Your Account</h3>
        <form onsubmit={handleSignUp} class="space-y-4">
          <div>
            <label for="signup-name" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Full Name
            </label>
            <input
              id="signup-name"
              type="text"
              bind:value={signUpForm.name}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your full name"
            />
          </div>
          
          <div>
            <label for="signup-email" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Email Address
            </label>
            <input
              id="signup-email"
              type="email"
              bind:value={signUpForm.email}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your email"
            />
          </div>
          
          <div>
            <label for="signup-password" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Password
            </label>
            <input
              id="signup-password"
              type="password"
              bind:value={signUpForm.password}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Create a password"
            />
          </div>
          
          <div>
            <label for="signup-confirm" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Confirm Password
            </label>
            <input
              id="signup-confirm"
              type="password"
              bind:value={signUpForm.confirmPassword}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Confirm your password"
            />
          </div>
          
          <button
            type="submit"
            class="w-full rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
          >
            Create Account
          </button>
        </form>
        
        <button 
          onclick={() => showSignUp = false}
          class="mt-4 w-full text-sm text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 transition-colors"
        >
          Cancel
        </button>
      </div>
    </div>
  {/if}

  <!-- Sign In Form -->
  {#if showSignIn}
    <div class="mx-auto max-w-md">
      <div class="rounded-xl bg-gray-50 dark:bg-gray-900 p-6 border border-gray-200 dark:border-gray-800">
        <h3 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Welcome Back</h3>
        <form onsubmit={handleSignIn} class="space-y-4">
          <div>
            <label for="signin-email" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Email Address
            </label>
            <input
              id="signin-email"
              type="email"
              bind:value={signInForm.email}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your email"
            />
          </div>
          
          <div>
            <label for="signin-password" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-1">
              Password
            </label>
            <input
              id="signin-password"
              type="password"
              bind:value={signInForm.password}
              required
              class="w-full rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 px-3 py-2 text-sm text-gray-900 dark:text-white placeholder-gray-500 dark:placeholder-gray-400 focus:border-blue-500 focus:outline-none focus:ring-1 focus:ring-blue-500"
              placeholder="Enter your password"
            />
          </div>
          
          <button
            type="submit"
            class="w-full rounded-lg bg-blue-600 px-4 py-2 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
          >
            Sign In
          </button>
        </form>
        
        <div class="mt-4 text-center">
          <button class="text-sm text-blue-600 dark:text-blue-400 hover:text-blue-500 dark:hover:text-blue-300 transition-colors">
            Forgot your password?
          </button>
        </div>
        
        <button 
          onclick={() => showSignIn = false}
          class="mt-4 w-full text-sm text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-300 transition-colors"
        >
          Cancel
        </button>
      </div>
    </div>
  {/if}
</section>
</file>

<file path="src/lib/components/home/FeaturedChannels.svelte">
<script lang="ts">
  import { usersStore } from '$lib/stores/library';

  function formatCount(value: number) {
    if (value >= 1_000_000) return `${(value / 1_000_000).toFixed(1)}M`;
    if (value >= 1_000) return `${(value / 1_000).toFixed(1)}K`;
    return value.toString();
  }

  const featuredChannels = $derived(
    $usersStore.slice(0, 4).map((user) => ({
      id: user.id,
      name: user.name,
      description: user.bio,
      avatar: user.avatar,
      subscribers: formatCount(user.stats?.followers ?? 0),
      videos: user.stats?.videos ?? 0
    }))
  );
</script>

<section class="py-16 bg-gray-50 dark:bg-gray-900">
  <div class="mx-auto max-w-7xl px-6 lg:px-8">
    <div class="mx-auto max-w-2xl text-center">
      <h2 class="text-3xl font-bold tracking-tight text-gray-900 dark:text-white sm:text-4xl">
        Featured Channels
      </h2>
      <p class="mt-4 text-lg leading-8 text-gray-600 dark:text-gray-300">
        Discover amazing creators and their unique perspectives
      </p>
    </div>
    
    <div class="mx-auto mt-12 grid max-w-2xl grid-cols-1 gap-8 lg:mx-0 lg:max-w-none lg:grid-cols-2">
      {#each featuredChannels as channel}
        <div class="group relative overflow-hidden rounded-2xl bg-white dark:bg-gray-800 p-6 shadow-sm hover:shadow-lg transition-all duration-300">
          <div class="flex items-start gap-4">
      
            
            <div class="flex-1 min-w-0">
              <div class="flex items-center gap-2">
                <h3 class="text-lg font-semibold text-gray-900 dark:text-white group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors">
                  {channel.name}
                </h3>
           
              </div>
              
              <p class="mt-1 text-sm text-gray-600 dark:text-gray-400">
                {channel.description}
              </p>
              
              <div class="mt-3 flex items-center gap-4 text-sm text-gray-500 dark:text-gray-400">
                <span class="flex items-center gap-1">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z"/>
                  </svg>
                  {channel.subscribers} subscribers
                </span>
                <span class="flex items-center gap-1">
                  <svg class="h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                  </svg>
                  {channel.videos} videos
                </span>
              </div>
              
            
            </div>
          </div>
          
          <div class="mt-6 flex gap-3">
            <a 
              href={`/users/${channel.id}`}
              class="flex-1 rounded-lg border border-gray-300 dark:border-gray-600 px-4 py-2 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors text-center"
            >
              View Channel
            </a>
          </div>
        </div>
      {/each}
    </div>
  </div>
</section>
</file>

<file path="src/lib/components/home/GeneratedChannels.svelte">
<script lang="ts">
  // Generate channels based on different criteria
  const generatedChannels = [
    {
      id: 'tokyo-streets',
      title: 'Around Tokyo - This Year',
      type: 'location',
      description: 'Unedited footage from Tokyo',
      location: 'Tokyo, Japan',
      videoCount: 12,
      thumbnails: [
        'https://images.unsplash.com/photo-1540959733332-eab4deabeeaf?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1513407030348-c983a97b98d8?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1542051841857-5f90071e7989?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1503899036084-c55cdd92da26?w=200&h=112&fit=crop'
      ],
      generatedAt: '2024-01-15',
      badge: '📍'
    },
    {
      id: 'digital-art-week',
      title: 'Digital Art Week',
      type: 'keyword',
      description: 'Creative digital art processes and studio sessions',
      keyword: 'digital art',
      videoCount: 8,
      thumbnails: [
        'https://images.unsplash.com/photo-1518709268805-4e9042af2176?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1561736778-92e52a7769ef?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1550745165-9bc0b252726f?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1558618666-fcd25c85cd64?w=200&h=112&fit=crop'
      ],
      generatedAt: '2024-01-14',
      badge: '🎨'
    },
    {
      id: 'urban-exploration',
      title: 'Urban Exploration',
      type: 'vibe',
      description: 'Raw footage of abandoned places and hidden urban gems',
      query: 'abandoned urban exploration architecture',
      videoCount: 15,
      thumbnails: [
        'https://images.unsplash.com/photo-1449824913935-59a10b8d2000?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1487958449943-2429e8be8625?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1486406146926-c627a92ad1ab?w=200&h=112&fit=crop',
        'https://images.unsplash.com/photo-1511818966892-d7d671e672a2?w=200&h=112&fit=crop'
      ],
      generatedAt: '2024-01-13',
      badge: '🏗️'
    }
  ];

  function handleChannelClick(channelId: string) {
    // For now, just navigate to a channel page
    window.location.href = `/channels/${channelId}`;
  }

  function formatDate(dateString: string) {
    return new Date(dateString).toLocaleDateString('en-US', { 
      month: 'short', 
      day: 'numeric' 
    });
  }
</script>

<section class="mb-16">
  <div class="text-center mb-8">
    <h2 class="text-2xl font-semibold text-gray-900 dark:text-white mb-2">
      This Week's Featured Channels
    </h2>
  
  </div>

  <div class="space-y-4">
    {#each generatedChannels as channel}
      <div class="group cursor-pointer">
        <button
          onclick={() => handleChannelClick(channel.id)}
          class="w-full text-left border-t p-4 pb-1 transition-colors  border-gray-200/10 "
        >
          <div class="flex items-center justify-between w-full gap-4">
            <!-- Channel Badge -->
            <!--<div class="text-xl flex-shrink-0">{channel.badge}</div>
-->
            <!-- Overlapping Thumbnails -->
            <div class="flex -space-x-2 flex-shrink-0">
              {#each channel.thumbnails.slice(0, 5) as thumbnail, index}
                <div class="relative h-8 w-8  overflow-hidden rounded-full bg-gray-900 border-2 border-white dark:border-gray-900 shadow-sm">
                  <img
                    src={thumbnail}
                    alt="Video thumbnail {index + 1}"
                    class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                  />
                </div>
              {/each}
            </div>

            <!-- Channel Info -->
            <div class="flex-1 min-w-0">
              <div class="flex items-center justify-end gap-2 mb-1">
                <h3 class="text-base font-semibold text-gray-900 dark:text-white group-hover:text-blue-600 dark:group-hover:text-blue-400 transition-colors truncate">
                  {channel.title}
                </h3>

                <!-- Type Badge -->
                {#if channel.type === 'location'}
                  <span class="inline-flex items-center rounded-full bg-green-100 dark:bg-green-900 px-2 py-0.5 text-xs font-medium text-green-800 dark:text-green-200 flex-shrink-0">
                    Location
                  </span>
                {:else if channel.type === 'keyword'}
                  <span class="inline-flex items-center rounded-full bg-blue-100 dark:bg-blue-900 px-2 py-0.5 text-xs font-medium text-blue-800 dark:text-blue-200 flex-shrink-0">
                    Keyword
                  </span>
                {:else if channel.type === 'vibe'}
                  <span class="inline-flex items-center rounded-full bg-purple-100 dark:bg-purple-900 px-2 py-0.5 text-xs font-medium text-purple-800 dark:text-purple-200 flex-shrink-0">
                    Vibe
                  </span>
                {/if}
              </div>

              

               <div class="flex items-center justify-end gap-3 text-xs text-gray-500 dark:text-gray-400">
                <span>{channel.videoCount} videos</span>
                <span>•</span>
                <span>Generated {formatDate(channel.generatedAt)}</span>
                {#if channel.type === 'location'}
                  <span>•</span>
                  <span>{channel.location}</span>
                {:else if channel.type === 'keyword'}
                  <span>•</span>
                  <span>#{channel.keyword}</span>
                {/if}
              </div>
  <!-- <p class="text-sm text-gray-600 dark:text-gray-400 truncate mb-1">
                {channel.description}
              </p> -->

              
            
            </div>

            <!-- Arrow -->
            <div class="flex-shrink-0 opacity-0 group-hover:opacity-100 transition-opacity duration-300">
              <svg class="h-5 w-5 text-gray-400 group-hover:text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
              </svg>
            </div>
          </div>
        </button>
      </div>
    {/each}
  </div>

  
</section>
</file>

<file path="src/lib/components/home/HeroSection.svelte">
<script lang="ts">
  import { videosStore } from '$lib/stores/library';

  const fallbackVideo = {
    id: 'placeholder',
    title: 'Featured Video',
    author: 'Creator',
    thumbnailUrl: 'https://placehold.co/800x450?text=Rushes'
  };

  const featuredVideo = $derived(($videosStore[0] ?? fallbackVideo));
</script>

<section class="relative overflow-hidden bg-black">
  <!-- Subtle dot pattern overlay -->
  <div class="absolute inset-0 opacity-30" style="background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,.6) 1px, transparent 0); background-size: 20px 20px;"></div>

  <!-- Additional subtle gradient overlay -->
  <div class="absolute inset-0 bg-gradient-to-br from-gray-900/50 via-transparent to-gray-900/50"></div>
  
  <div class="relative px-6 py-16 lg:py-24">
    <div class="mx-auto max-w-4xl text-center">
      <h1 class="text-4xl font-bold tracking-tight text-white sm:text-6xl">
         <span class="text-blue-400">Rushes</span>
      </h1>
      <p class="mt-6 text-lg leading-8 text-gray-300">
      </p>
      
      <div class="mt-10 flex items-center justify-center gap-x-6">
        <a
          href="/videos"
          class="rounded-full bg-white px-6 py-3 text-sm font-semibold text-gray-900 shadow-sm hover:bg-gray-100 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white transition-all"
        >
          Explore Videos
        </a>
        <a
          href={`/videos/${featuredVideo.id}`}
          class="text-sm font-semibold leading-6 text-white hover:text-blue-400 transition-colors"
        >
          Watch Featured <span aria-hidden="true">→</span>
        </a>
      </div>
    </div>
    
    <!-- Featured Video Preview -->
    <div class="mx-auto mt-16 max-w-2xl">
      <div class="relative rounded-xl bg-gray-900/40 backdrop-blur-sm p-4 border border-gray-800/50">
        <div class="aspect-video overflow-hidden rounded-lg bg-gray-900">
          <img
            src={featuredVideo.thumbnailUrl ?? fallbackVideo.thumbnailUrl}
            alt={featuredVideo.title}
            class="h-full w-full object-cover"
          />
          <div class="absolute inset-0 flex items-center justify-center">
            <button class="rounded-full bg-black/60 p-4 backdrop-blur-sm hover:bg-black/80 transition-colors border border-gray-600" aria-label="Play featured video">
              <svg class="h-8 w-8 text-white" fill="currentColor" viewBox="0 0 24 24">
                <path d="M8 5v14l11-7z"/>
              </svg>
            </button>
          </div>
        </div>
        <div class="mt-4 text-center">
          <h3 class="text-lg font-semibold text-white">{featuredVideo.title}</h3>
          <p class="text-sm text-gray-400">by {featuredVideo.author}</p>
        </div>
      </div>
    </div>
  </div>
</section>
</file>

<file path="src/lib/components/home/StatsSection.svelte">
<script lang="ts">
  // Mock platform statistics
  const stats = [
    {
      name: 'Total Videos',
      value: '12,847',
      change: '+12%',
      changeType: 'increase',
      icon: 'M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z'
    },
    {
      name: 'Active Creators',
      value: '2,341',
      change: '+8%',
      changeType: 'increase',
      icon: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z'
    },
    {
      name: 'Hours Watched',
      value: '847K',
      change: '+23%',
      changeType: 'increase',
      icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z'
    },
    {
      name: 'Community Members',
      value: '89,432',
      change: '+15%',
      changeType: 'increase',
      icon: 'M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z'
    }
  ];
</script>

<section class="border-t border-gray-200 dark:border-gray-800 bg-gray-50 dark:bg-gray-900 py-12">
  <div class="mx-auto max-w-4xl px-6">
    <div class="grid grid-cols-2 gap-8 lg:grid-cols-4">
      {#each stats as stat}
        <div class="text-center">
          <!-- Value -->
          <div class="text-2xl font-bold text-gray-900 dark:text-white">
            {stat.value}
          </div>
          <div class="mt-1 text-sm text-gray-600 dark:text-gray-400">
            {stat.name}
          </div>
        </div>
      {/each}
    </div>

    <!-- Footer -->
    <div class="mt-8 text-center">
      <p class="text-xs text-gray-500 dark:text-gray-400">
        © 2024 Rushes. A community for video creators and enthusiasts.
      </p>
    </div>
  </div>
</section>
</file>

<file path="src/lib/components/Barcode.svelte">
<script lang="ts">
    let videoElement: HTMLVideoElement | null = null;
    let barcodeCanvas: HTMLCanvasElement | null = null;

    let isProcessing = false;
    let progress = 0;
    let barcodeDataUrl: string | null = null; // This will hold the final image data

    // These dimensions control the final barcode image
    const BARCODE_WIDTH = 1200; // The number of "slices" to take
    const BARCODE_HEIGHT = 200; // The height of the final image

    async function handleFileSelect(event: Event) {
        const input = event.currentTarget as HTMLInputElement | null;
        const file = input?.files?.[0];
        if (!file) return;

        isProcessing = true;
        progress = 0;
        barcodeDataUrl = null;

        // Clean up any previous object URL
        if (videoElement?.src) {
            URL.revokeObjectURL(videoElement.src);
        }

        // Load the video file into the hidden <video> element
        const fileURL = URL.createObjectURL(file);
        if (videoElement) {
            videoElement.src = fileURL;
        }

        // The 'loadedmetadata' event will fire, triggering generateBarcode()
    }

    /**
     * Helper function to wait for the video to seek to a new time.
     * We wrap this in a Promise to use it with async/await.
     */
    function seekVideo(time: number) {
        const element = videoElement;
        if (!element) return Promise.reject(new Error('Video element not ready'));
        return new Promise((resolve, reject) => {
            // Set up event listeners *before* changing currentTime
            element.onseeked = () => resolve(true);
            element.onerror = (e) => reject(e);

            element.currentTime = time;
        });
    }

    /**
     * This function runs once the video's duration and dimensions are known.
     */
    async function generateBarcode() {
        const element = videoElement;
        const canvas = barcodeCanvas;
        if (!element || !canvas) return;
        console.log("Video metadata loaded. Starting barcode generation...");

        const duration = element.duration;
        const videoWidth = element.videoWidth;
        const videoHeight = element.videoHeight;

        // 1. Set up the final canvas
        canvas.width = BARCODE_WIDTH;
        canvas.height = BARCODE_HEIGHT;
        const ctx = canvas.getContext("2d");
        if (!ctx) {
            console.error('Unable to get barcode canvas context');
            isProcessing = false;
            return;
        }

        // 2. Create a hidden, in-memory canvas to draw full frames
        const tempCanvas = document.createElement("canvas");
        tempCanvas.width = videoWidth;
        tempCanvas.height = videoHeight;
        const tempCtx = tempCanvas.getContext("2d");
        if (!tempCtx) {
            console.error('Unable to get temp canvas context');
            isProcessing = false;
            return;
        }

        const interval = duration / BARCODE_WIDTH;

        // 3. Loop through, seeking and sampling
        for (let i = 0; i < BARCODE_WIDTH; i++) {
            const time = i * interval;

            try {
                await seekVideo(time);

                // Draw the full video frame onto the temporary canvas
                tempCtx.drawImage(element, 0, 0, videoWidth, videoHeight);

                // Draw a 1px slice from the *center* of the temp canvas
                // onto the final barcode canvas.
                // We stretch the slice's height to fit our barcode height.
                ctx.drawImage(
                    tempCanvas, // Source canvas
                    videoWidth / 2,
                    0, // Source (x, y) - from center
                    1,
                    videoHeight, // Source (width, height) - 1px wide slice
                    i,
                    0, // Destination (x, y) - at column 'i'
                    1,
                    BARCODE_HEIGHT, // Destination (width, height) - 1px wide, stretched
                );
            } catch (error) {
                console.error("Error seeking or drawing frame:", error);
                // Continue to the next frame
            }

            // Update progress
            progress = (i / BARCODE_WIDTH) * 100;
        }

        // 4. Done. Export the final canvas to an image.
        console.log("Barcode generation complete.");
        isProcessing = false;
        progress = 100;
        barcodeDataUrl = canvas.toDataURL("image/png");

        // Clean up the object URL to free memory
        if (element.src) {
            URL.revokeObjectURL(element.src);
            element.src = "";
        }
    }
</script>

<div class="barcode-generator">
    <h2>Movie Barcode Generator (In-Browser)</h2>
    <p>Select a video file. Processing happens entirely on your computer.</p>

    <input
        type="file"
        accept="video/mp4,video/webm,video/ogg"
        on:change={handleFileSelect}
        disabled={isProcessing}
    />

    {#if isProcessing}
        <div class="progress-bar">
            <p>Processing... {Math.round(progress)}%</p>
            <progress value={progress} max="100"></progress>
        </div>
    {/if}

    {#if barcodeDataUrl}
        <div class="result">
            <h3>Your Barcode:</h3>
            <img src={barcodeDataUrl} alt="Movie Barcode" />
            <a
                href={barcodeDataUrl}
                download="movie-barcode.png"
                class="download-btn"
            >
                Download Barcode
            </a>
        </div>
    {/if}
</div>

<video
    bind:this={videoElement}
    on:loadedmetadata={generateBarcode}
    style="display: none;"
    muted
    preload="auto"
></video>

<canvas bind:this={barcodeCanvas} style="display: none;"></canvas>

<style>
    .barcode-generator {
        font-family: sans-serif;
        max-width: 800px;
        margin: 2em auto;
        padding: 1em;
        border: 1px solid #ccc;
        border-radius: 8px;
    }
    input[type="file"] {
        margin-bottom: 1em;
    }
    .progress-bar {
        margin: 1em 0;
    }
    progress {
        width: 100%;
    }
    .result img {
        width: 100%;
        height: auto;
        border: 1px solid #eee;
        margin-top: 1em;
    }
    .download-btn {
        display: inline-block;
        margin-top: 1em;
        padding: 0.8em 1.2em;
        background-color: #007bff;
        color: white;
        text-decoration: none;
        border-radius: 4px;
        font-weight: bold;
    }
    .download-btn:hover {
        background-color: #0056b3;
    }
</style>
</file>

<file path="src/lib/components/CollapsibleHeading.svelte">
<script lang="ts">
  import { slide } from 'svelte/transition';
  import { cubicOut } from 'svelte/easing';

  export let title: string;
  export let isOpen: boolean;
  export let actionButton: { text: string; icon?: string; href?: string } | null = null;
</script>

<!-- <div class="flex items-center justify-between border-t border-gray-200 dark:border-gray-100/10 py-4 "> -->
 <div class="flex items-center justify-between  ">
  <button 
    class="flex items-center w-full gap-2 pb-5"
    onclick={() => isOpen = !isOpen}
  >
    <svg 
      xmlns="http://www.w3.org/2000/svg" 
      width="10" 
      height="10" 
      fill="currentColor" 
      class="text-black/30 dark:text-white -rotate-90 transition-transform duration-200" 
      class:rotate-0={isOpen}
      viewBox="0 0 16 16"
    >
      <path d="M7.247 11.14 2.451 5.658C1.885 5.013 2.345 4 3.204 4h9.592a1 1 0 0 1 .753 1.659l-4.796 5.48a1 1 0 0 1-1.506 0z"/>
    </svg>
    <h3 class="text-sm  font-medium dark:text-neutral-200">{title}</h3>
  </button>
  {#if actionButton}
    {#if actionButton.href}
      <a 
        href={actionButton.href}
        class="text-xs dark:text-neutral-400 hover:text-white transition-colors flex flex-shrink-0 w-auto items-center gap-1"
      >
        {#if actionButton.icon}
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
            <path d={actionButton.icon} />
          </svg>
        {/if}
        {actionButton.text}
      </a>
    {:else}
      <button class="text-xs dark:text-neutral-400 hover:text-white transition-colors flex flex-shrink-0 w-auto items-center gap-1">
        {#if actionButton.icon}
          <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="currentColor" viewBox="0 0 16 16">
            <path d={actionButton.icon} />
          </svg>
        {/if}
        {actionButton.text}
      </button>
    {/if}
  {/if}
</div>

{#if isOpen}
  <div 
    transition:slide={{ 
      duration: 200,
      easing: cubicOut
    }}
  >
    <slot />
  </div>
{/if}
</file>

<file path="src/lib/components/Header.svelte">
<script lang="ts">
  import { theme } from '$lib/stores/theme';

  interface Props {
    ontoggleSidebar?: () => void;
  }

  let { ontoggleSidebar }: Props = $props();

  function toggleTheme() {
    theme.toggle();
  }

  function openMobileSidebar() {
    ontoggleSidebar?.();
  }
</script>

<header class="z-40 text-black dark:text-white border-b-[0.5px] border-gray-200 dark:border-gray-800/20 py-4 pb-3 mx-6 flex justify-between items-center">
  <!-- Mobile menu button - only visible on mobile -->

  <!-- Mobile title with logo - visible on mobile -->
  <div class="lg:hidden flex items-center gap-2" onclick={openMobileSidebar}>
    <img src="/rushes.svg" alt="Rushes Logo" class="h-5 w-5 mr-0" />
    <!-- <span class="text-base font-normal" style="font-size: 14px; line-height: 0px">Rushes</span> -->
  </div>

  <!-- Theme toggle button -->
  <!-- <button
    class="p-2 hover:bg-gray-100 dark:hover:bg-gray-800 rounded transition-colors"
    on:click={toggleTheme}
    aria-label="Toggle theme"
  >
    {#if $theme === 'dark'}
      <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
      </svg>
    {:else}
      <svg class="h-5 w-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
      </svg>
    {/if}
  </button> -->
</header>
</file>

<file path="src/lib/components/LocationPicker.svelte">
<script lang="ts">
	import { browser } from '$app/environment';
	import { onMount, onDestroy } from 'svelte';
	import type mapboxgl from 'mapbox-gl';
	import 'mapbox-gl/dist/mapbox-gl.css';

	interface Props {
		latitude?: number;
		longitude?: number;
		onLocationChange?: (lat: number, lon: number) => void;
	}

	let { latitude, longitude, onLocationChange }: Props = $props();

	let container = $state<HTMLDivElement | null>(null);
	let map: mapboxgl.Map | null = null;
	let marker: mapboxgl.Marker | null = null;
	let mapError = $state<string | null>(null);
	const initialLat = typeof latitude === 'number' ? latitude : null;
	const initialLon = typeof longitude === 'number' ? longitude : null;
	const initialHasCoords =
		initialLat != null &&
		initialLon != null &&
		coordinatesInRange(initialLat, initialLon);
	let currentLat = $state<number | null>(initialHasCoords ? initialLat : null);
	let currentLon = $state<number | null>(initialHasCoords ? initialLon : null);

	const token =
		import.meta.env.PUBLIC_MAPBOX_ACCESS_TOKEN ??
		import.meta.env.VITE_MAPBOX_TOKEN ??
		import.meta.env.VITE_PUBLIC_MAPBOX_ACCESS_TOKEN ??
		'';

	const mapStyle =
		import.meta.env.VITE_MAPBOX_STYLE ??
		import.meta.env.PUBLIC_MAPBOX_STYLE ??
		'mapbox://styles/mapbox/dark-v11';

	let mapboxModule: typeof mapboxgl | null = null;

	function coordinatesInRange(lat: number, lon: number): boolean {
		return (
			Number.isFinite(lat) &&
			Number.isFinite(lon) &&
			Math.abs(lat) <= 90 &&
			Math.abs(lon) <= 180
		);
	}

	function updateMarker(
		lat: number,
		lon: number,
		options: { notify?: boolean; animate?: boolean } = {}
	) {
		const mapInstance = map;
		const mapbox = mapboxModule;
		if (!mapInstance || !mapbox) return;
		if (!coordinatesInRange(lat, lon)) return;

		currentLat = lat;
		currentLon = lon;

		if (marker) {
			marker.setLngLat([lon, lat]);
		} else {
			marker = new mapbox.Marker({ color: '#f59e0b', draggable: true })
				.setLngLat([lon, lat])
				.addTo(mapInstance);

			marker.on('dragend', () => {
				if (!marker) return;
				const lngLat = marker.getLngLat();
				updateMarker(lngLat.lat, lngLat.lng, { animate: false, notify: true });
			});
		}

		const animate = options.animate ?? true;
		const zoom = mapInstance.getZoom ? Math.max(mapInstance.getZoom(), 12) : 12;
		const move = () => {
			if (animate) {
				mapInstance.easeTo({ center: [lon, lat], zoom, duration: 800 });
			} else {
				mapInstance.jumpTo({ center: [lon, lat], zoom });
			}
		};

		if (mapInstance.isStyleLoaded()) {
			move();
		} else {
			mapInstance.once('load', move);
		}

		if (options.notify ?? true) {
			onLocationChange?.(lat, lon);
		}
	}

	onMount(async () => {
		if (!browser || !container) return;
		if (!token) {
			mapError = 'Missing Mapbox access token';
			return;
		}

		try {
			const module = await import('mapbox-gl');
			mapboxModule = module.default as typeof mapboxgl;
			const Mapbox = mapboxModule;

			if (!Mapbox) {
				mapError = 'Unable to load Mapbox library';
				return;
			}

			Mapbox.accessToken = token;
			const lat = typeof latitude === 'number' ? latitude : null;
			const lon = typeof longitude === 'number' ? longitude : null;
			const hasCoords = lat != null && lon != null && coordinatesInRange(lat, lon);
			const startLat = hasCoords && lat != null ? lat : 0;
			const startLon = hasCoords && lon != null ? lon : 0;
			map = new Mapbox.Map({
					container,
					style: mapStyle,
					center: [startLon, startLat],
					zoom: hasCoords ? 12 : 2,
					cooperativeGestures: false
				});

			map.once('load', () => {
					const loadLat = typeof latitude === 'number' ? latitude : null;
					const loadLon = typeof longitude === 'number' ? longitude : null;
					if (loadLat != null && loadLon != null && coordinatesInRange(loadLat, loadLon)) {
						updateMarker(loadLat, loadLon, { notify: false });
					}
				});

			// Add click handler to place/move marker
			map.on('click', (e) => {
				updateMarker(e.lngLat.lat, e.lngLat.lng);
			});

			// Add geolocation control
			const geolocate = new Mapbox.GeolocateControl({
				positionOptions: {
					enableHighAccuracy: true
				},
				trackUserLocation: false,
				showUserHeading: false
			});

			map.addControl(geolocate);

			// Listen for geolocation success
			geolocate.on('geolocate', (e: any) => {
				updateMarker(e.coords.latitude, e.coords.longitude);
			});

			// Add navigation controls
			map.addControl(new Mapbox.NavigationControl(), 'top-right');

		} catch (error) {
			console.error('Failed to initialize map:', error);
			mapError = 'Unable to render the interactive map';
		}
	});

	// Update marker when props change
	$effect(() => {
		const lat = typeof latitude === 'number' ? latitude : null;
		const lon = typeof longitude === 'number' ? longitude : null;

		if (lat != null && lon != null && coordinatesInRange(lat, lon)) {
			currentLat = lat;
			currentLon = lon;

			if (map && mapboxModule) {
				updateMarker(lat, lon, { notify: false });
			}
		} else if (latitude == null || longitude == null) {
			currentLat = null;
			currentLon = null;
			if (marker) {
				marker.remove();
				marker = null;
			}
		}
	});

	onDestroy(() => {
		marker?.remove();
		map?.remove();
		map = null;
		marker = null;
	});
</script>

<div class="location-picker">
	<div bind:this={container} class="map-container" role="presentation"></div>
	{#if mapError}
		<div class="map-error">
			<p>{mapError}</p>
		</div>
	{/if}
	<div class="coordinates">
		{#if currentLat != null && currentLon != null}
			<span class="coord-label">Location:</span>
			<span class="coord-value">{currentLat?.toFixed(6)}, {currentLon?.toFixed(6)}</span>
		{:else}
			<span class="coord-label">Click on the map to set a location</span>
		{/if}
	</div>
</div>

<style>
	.location-picker {
		position: relative;
		width: 100%;
		height: 400px;
		border-radius: 12px;
		overflow: hidden;
		border: 1px solid rgba(148, 163, 184, 0.2);
	}

	.map-container {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
	}

	.map-error {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		display: flex;
		align-items: center;
		justify-content: center;
		background: rgba(15, 23, 42, 0.95);
		color: #fca5a5;
		padding: 1.5rem;
		text-align: center;
		z-index: 10;
	}

	.coordinates {
		position: absolute;
		bottom: 1rem;
		left: 50%;
		transform: translateX(-50%);
		background: rgba(15, 23, 42, 0.95);
		border: 1px solid rgba(148, 163, 184, 0.3);
		border-radius: 9999px;
		padding: 0.5rem 1rem;
		font-size: 0.875rem;
		color: #e2e8f0;
		backdrop-filter: blur(8px);
		display: flex;
		gap: 0.5rem;
		align-items: center;
		z-index: 5;
		pointer-events: none;
	}

	.coord-label {
		color: rgba(226, 232, 240, 0.7);
	}

	.coord-value {
		color: #5eead4;
		font-weight: 500;
		font-variant-numeric: tabular-nums;
	}

	@media (max-width: 640px) {
		.location-picker {
			height: 300px;
		}

		.coordinates {
			font-size: 0.75rem;
			padding: 0.375rem 0.75rem;
		}
	}
</style>
</file>

<file path="src/lib/components/Map.svelte">
<script lang="ts">
	import { browser } from '$app/environment';
	import { onDestroy, onMount } from 'svelte';
	import type mapboxgl from 'mapbox-gl';
	import 'mapbox-gl/dist/mapbox-gl.css';

	interface Location {
		mapLat?: number;
		mapLon?: number;
		latitude?: number;
		longitude?: number;
		coordinates?: [number, number];
		setting?: string;
		name?: string;
		videoTitle?: string;
		videoAuthor?: string;
		videoId?: string;
	}

	interface Props {
		locations?: Location[];
		initialCenterLat?: number;
		initialCenterLon?: number;
		initialZoom?: number;
		activeVideoId?: string | null;
	}
  const props = $props() as Props;

  let locations = $state<Location[]>(props.locations ?? []);
  let initialCenterLat = $state(props.initialCenterLat ?? 0);
  let initialCenterLon = $state(props.initialCenterLon ?? 0);
  let initialZoom = $state(props.initialZoom ?? 2);
  let activeVideoId = $state(props.activeVideoId ?? null);

  $effect(() => {
    locations = props.locations ?? [];
    initialCenterLat = props.initialCenterLat ?? 0;
    initialCenterLon = props.initialCenterLon ?? 0;
    initialZoom = props.initialZoom ?? 2;
    activeVideoId = props.activeVideoId ?? null;
  });

	let container = $state<HTMLDivElement | null>(null);
	let map: mapboxgl.Map | null = null;
	let markers: mapboxgl.Marker[] = [];
	let mapError = $state<string | null>(null);
	let mapReady = $state(false);
	let lastFocusedVideoId = $state<string | null>(null);

	const token =
		import.meta.env.PUBLIC_MAPBOX_ACCESS_TOKEN ??
		import.meta.env.VITE_MAPBOX_TOKEN ??
		import.meta.env.VITE_PUBLIC_MAPBOX_ACCESS_TOKEN ??
		'';

	const mapStyle =
		import.meta.env.VITE_MAPBOX_STYLE ??
		import.meta.env.PUBLIC_MAPBOX_STYLE ??
		'mapbox://styles/mapbox/dark-v11'; // Fallback to public style

	function normaliseCoordinates(loc: Location): [number, number] | null {
		if (typeof loc.mapLon === 'number' && typeof loc.mapLat === 'number') {
			return [loc.mapLon, loc.mapLat];
		}
		if (typeof loc.longitude === 'number' && typeof loc.latitude === 'number') {
			return [loc.longitude, loc.latitude];
		}
		// Coordinates array is already in GeoJSON standard format: [lon, lat]
		if (Array.isArray(loc.coordinates) && loc.coordinates.length === 2) {
			return [loc.coordinates[0], loc.coordinates[1]];
		}
		return null;
	}

	function clearMarkers() {
		markers.forEach((marker) => marker.remove());
		markers = [];
	}

  // Simple HTML sanitization - escapes dangerous characters
  function escapeHtml(text: string): string {
    const map: Record<string, string> = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, (char) => map[char]);
  }

  function syncMarkers(currentLocations: Location[] = []) {
    if (!map) return;
    clearMarkers();
    for (const loc of currentLocations) {
			const coords = normaliseCoordinates(loc);
			if (!coords) continue;
			const [lon, lat] = coords;
			const Mapbox = mapboxModule;
			if (!Mapbox) continue;
			const marker = new Mapbox.Marker({ color: '#f59e0b' })
				.setLngLat([lon, lat]);
			const popupContent: string[] = [];
			// Sanitize all user-provided content
			if (loc.setting || loc.name) {
				popupContent.push(`<strong>${escapeHtml(loc.setting ?? loc.name ?? '')}</strong>`);
			}
			if (loc.videoTitle) {
				popupContent.push(`<div>${escapeHtml(loc.videoTitle)}</div>`);
			}
			if (loc.videoAuthor) {
				popupContent.push(`<small>${escapeHtml(loc.videoAuthor)}</small>`);
			}
			if (popupContent.length > 0) {
				marker.setPopup(new Mapbox.Popup({ offset: 16 }).setHTML(popupContent.join('')));
			}
			marker.addTo(map);
			markers.push(marker);
		}
	}

	let mapboxModule: typeof mapboxgl | null = null;

	function findLocationByVideoId(videoId: string | null): Location | null {
		if (!videoId) return null;
	return (
		locations.find((loc) => loc.videoId === videoId) ?? null
	);
	}

	function focusOnVideo(
	videoId: string | null,
	{ instant = false, force = false }: { instant?: boolean; force?: boolean } = {}
) {
	if (!map || !mapReady || !videoId) return;
	const location = findLocationByVideoId(videoId);
	if (!location) return;
	const coords = normaliseCoordinates(location);
	if (!coords) return;
	const [lon, lat] = coords;
	const targetZoom = Math.max(map.getZoom(), initialZoom, 10);
	if (instant) {
		map.jumpTo({ center: [lon, lat], zoom: targetZoom });
	} else if (force || videoId !== lastFocusedVideoId) {
		map.flyTo({
			center: [lon, lat],
			zoom: targetZoom,
			speed: 0.9,
			curve: 1.4,
			easing: (t) => 1 - Math.pow(1 - t, 3),
			essential: true
		});
	}
	lastFocusedVideoId = videoId;
}

	onMount(async () => {
		if (!browser || !container) return;
		if (!token) {
			mapError = 'Missing Mapbox access token. Set PUBLIC_MAPBOX_ACCESS_TOKEN to enable the map view.';
			return;
		}

		try {
			const module = await import('mapbox-gl');
			mapboxModule = module.default as typeof mapboxgl;
			const Mapbox = mapboxModule;
			if (!Mapbox) {
				mapError = 'Unable to load the Mapbox library.';
				return;
			}
			Mapbox.accessToken = token;
			map = new Mapbox.Map({
				container,
				style: mapStyle,
				center: [initialCenterLon, initialCenterLat],
				zoom: initialZoom,
				cooperativeGestures: true
			});
			map.once('load', () => {
				mapReady = true;
				syncMarkers(locations);
				if (activeVideoId) {
					requestAnimationFrame(() => focusOnVideo(activeVideoId, { force: true }));
				}
			});
		} catch (error) {
			console.error('Failed to initialise map', error);
			mapError = 'Unable to render the interactive map.';
		}
	});

	$effect(() => {
		if (map && mapboxModule) {
			syncMarkers(locations);
		}
	});

	$effect(() => {
		if (!mapReady) return;
		if (!activeVideoId) {
			lastFocusedVideoId = null;
			return;
		}
		focusOnVideo(activeVideoId);
	});

	onDestroy(() => {
		clearMarkers();
		map?.remove();
		map = null;
		mapReady = false;
		lastFocusedVideoId = null;
	});
</script>

<div class="map-wrapper">
	<div bind:this={container} class="map-container" role="presentation"></div>
	{#if mapError}
		<div class="map-fallback">
			<p>{mapError}</p>
			{#if locations.length > 0}
				<ul>
					{#each locations as loc (loc.setting ?? loc.name ?? `${loc.latitude}-${loc.longitude}`)}
						<li>
							<span>{loc.setting ?? loc.name ?? 'Location'}</span>
							{#if (loc.latitude ?? loc.mapLat) != null && (loc.longitude ?? loc.mapLon) != null}
								<small>
									({loc.latitude ?? loc.mapLat}, {loc.longitude ?? loc.mapLon})
								</small>
							{/if}
						</li>
					{/each}
				</ul>
			{/if}
		</div>
	{/if}
</div>

<style>
	.map-wrapper {
		position: relative;
		width: 100%;
		height: 100%;
	}

	.map-container {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		overflow: hidden;
	}

	.map-fallback {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		display: flex;
		flex-direction: column;
		align-items: center;
		justify-content: center;
		padding: 1.5rem;
		text-align: center;
		background: linear-gradient(135deg, rgba(30, 41, 59, 0.9), rgba(15, 23, 42, 0.9));
		color: rgba(248, 250, 252, 0.8);
	}

	.map-fallback ul {
		margin-top: 1rem;
		padding: 0;
		list-style: none;
		width: 100%;
		max-width: 320px;
		text-align: left;
	}

	.map-fallback li {
		display: flex;
		justify-content: space-between;
		padding: 0.25rem 0;
		border-bottom: 1px dashed rgba(148, 163, 184, 0.3);
		font-size: 0.8125rem;
	}

	.map-fallback small {
		opacity: 0.7;
	}
</style>
</file>

<file path="src/lib/components/PersistentVideoPlayer.svelte">
<script lang="ts">
  import { activeVideo } from '$lib/stores/video';
  import { onMount } from 'svelte';
  import { gsap } from 'gsap';
  import VideoInfo from './VideoInfo.svelte';
  import VideoPlayer from './VideoPlayer.svelte';

  interface VideoData {
    video: {
      id: string;
      url: string;
      title: string;
      description: string;
      author: string;
      authorId: string;
      transcript: string;
      keywords: string[];
      locations: any[];
    }
  }

  let videoContainer: HTMLDivElement;
  let isPip = $state(false);
  let { data } = $props<{ data?: VideoData }>();

  function togglePip() {
    isPip = !isPip;
    
    // Animate to PiP mode
    if (isPip) {
      gsap.to(videoContainer, {
        y: window.innerHeight - 180, // offset to bottom
        x: -20,
        width: '280px',
        borderRadius: '8px',
        boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
        duration: 0.5,
        ease: 'power2.out'
      });
    } 
    // Animate to full screen
    else {
      gsap.to(videoContainer, {
        y: 0,
        x: 0,
        width: '100%',
        borderRadius: 0,
        boxShadow: 'none',
        duration: 0.5,
        ease: 'power2.inOut'
      });
    }
  }

  onMount(() => {
    // Set initial position based on isPip state
    if (isPip) {
      gsap.set(videoContainer, {
        y: window.innerHeight - 180, // offset to bottom
        x: window.innerWidth - 400,
        width: '280px',
        borderRadius: '8px',
        boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
      });
    } else {
      gsap.set(videoContainer, {
        y: 0,
        x: 0,
        width: '100%',
        borderRadius: 0,
        boxShadow: 'none'
      });
    }
  });
</script>

<div 
  bind:this={videoContainer}
  class="video-container"
>
  <div class:dashboard-panel={!isPip}>
    <div class="relative aspect-video bg-black">
      {#if $activeVideo?.url}
        <VideoPlayer videoUrl={$activeVideo.url} />
      {/if}
          
      <!-- Video Info -->
      <div class="absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/80 to-transparent text-white">
        <div class="flex items-center justify-between">
          <div class="display-none">
            <h3 class="text-sm font-medium truncate">{$activeVideo?.title}</h3>
            <p class="text-xs text-neutral-300">{$activeVideo?.author}</p>
          </div>
            <!-- PiP Toggle Button -->
      <button
        on:click={togglePip}
        class="absolute top-4 right-4 p-2 bg-black/50 hover:bg-black/70 rounded-full text-white transition-colors"
      >
        {#if isPip}
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"/>
          </svg>
        {:else}
          <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
            <path d="M8 0a8 8 0 1 0 0 16A8 8 0 0 0 8 0M4.5 7.5a.5.5 0 0 1 0 1H3a2 2 0 0 0-2 2v1a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2v-1a2 2 0 0 0-2-2h-1.5a.5.5 0 0 1 0-1h1a.5.5 0 0 1 .5.5v1a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1v-1a.5.5 0 0 1 .5-.5z"/>
          </svg>
        {/if}
      </button>
        </div>
      </div>

    
    </div>

    {#if !isPip && data}
      <VideoInfo {data} />
    {/if}
  </div>
</div>

<style>
  .video-container {
    transform-origin: bottom right;
    position: fixed;
    top: 0;
    right: 0;
  }

  .dashboard-panel {
    border: 1px solid rgba(255, 255, 255, 0.1);
    background-color: rgba(255, 255, 255, 0.04);
    padding: 1.5rem;
  }
</style>
</file>

<file path="src/lib/components/Playing.svelte">
<script lang="ts">
    import { activeVideo } from '$lib/stores/video';
    import { selectedVideo } from '$lib/stores/selectedVideo';
  import { page } from '$app/stores';
  import { onMount } from 'svelte';
  import {gsap}  from "gsap/dist/gsap";
  import {ScrollTrigger} from "gsap/dist/ScrollTrigger";
  import VideoInfo from './VideoInfo.svelte';
  import VideoPlayer from './VideoPlayer.svelte';
  import { afterNavigate, goto } from '$app/navigation';

  
  import type { Video } from '$lib/types/content';
  import { getVideoById as lookupVideo, videosStore } from '$lib/stores/library';

  interface VideoData {
    video: Video;
  }

  let videoContainer = $state<HTMLDivElement>();
  let vidPlayer = $state<HTMLDivElement>();
  let isPip = $state(false);
  let videoData = $state<VideoData | null>(null);

  async function fetchVideoData(id: string) {
    try {
      let video = lookupVideo(id);
      if (!video && id === 'home') {
        video = $videosStore[0];
      }
      if (!video) throw new Error('Video not found');

      videoData = { video };

      // Update active video
      activeVideo.setActive({
        id: video.id,
        url: video.videoUrl ?? video.url ?? '',
        title: video.title,
        author: video.author,
        authorId: video.authorId,
        durationSeconds: video.durationSeconds ?? 0,
        thumbnailUrl: video.thumbnailUrl ?? undefined
      });
    } catch (error) {
      console.error('Error fetching video data:', error);
    }
  }

let manualOverride = false;

function togglePip() {
  const currentPath = $page.url.pathname;
  const isVideoDetailPage = currentPath.startsWith('/videos/') && currentPath !== '/videos';

  // If we're on a video detail page and minimizing (going to PiP), navigate back
  if (isVideoDetailPage && !isPip) {
    // Navigate to previous page or videos list
    goto('/videos');
    return;
  }

  isPip = !isPip;
  manualOverride = true;
  selectedVideo.toggleFullScreen();

  if (isPip && videoContainer) {
    gsap.to(videoContainer, {
      y: window.innerHeight - 180,
      x: -20,
      width: '280px',
      borderRadius: '8px',
      boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
      duration: 0.5,
      ease: 'power2.out'
    });
  } else if (videoContainer) {
    gsap.to(videoContainer, {
      y: 0,
      x: 0,
      width: '100%',
      borderRadius: 0,
      boxShadow: 'none',
      duration: 0.5,
      ease: 'power2.inOut'
    });
  }

  // Clear manual override after a short delay
  setTimeout(() => {
    manualOverride = false;
  }, 1000);
}

  onMount(async () => {
    try {
      if ($selectedVideo.id) {
        let video = lookupVideo($selectedVideo.id);
        if (!video && $selectedVideo.id === 'home') {
          video = $videosStore[0];
        }
        if (video) {
          videoData = { video };
        }
      }
    } catch (e) {
      console.error('Error loading video:', e);
    }
  });

// onMount(async () => {
//    gsap.registerPlugin(ScrollTrigger);
//    const scroller = document.querySelector('.scroll-container');

//   ScrollTrigger.create({
//     trigger: videoContainer,
//     start: "top top",
//     end: "+=250",
//     scrub: true,
//     scroller,
//     onUpdate: (self) => {
//       if (manualOverride) return;

//       const progress = self.progress;

//       const pipScale = gsap.utils.interpolate(1, 0.28, progress); // shrink to ~28%
//       const pipX = gsap.utils.interpolate(0, -20, progress);
//       const pipY = gsap.utils.interpolate(0, window.innerHeight - 180, progress);
//       const borderRadius = gsap.utils.interpolate(0, 8, progress);
//       const boxShadow = progress > 0.9
//         ? '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)'
//         : 'none';

//       gsap.to(vidPlayer, {
//         scale: pipScale,
//         x: pipX,
//         y: pipY,
//         zIndex: 999999,
//         borderRadius,
//         boxShadow,
//         transformOrigin: 'bottom right',
//         duration: 0.2,
//         overwrite: 'auto'
//       });

//     },
//     invalidateOnRefresh: true
//   });
// });

  onMount(() => {
  const handleRouteChange = () => {
    const currentPath = $page.url.pathname;

    const isFullscreenRoute =
      (currentPath.startsWith('/videos/') && currentPath !== '/videos') ||
      currentPath === '/live';

    if ($selectedVideo.id) {
      if (isFullscreenRoute && isPip) {
        togglePip(); 
        isPip = false;
      } else if (!isFullscreenRoute && !isPip) {
        togglePip();
        isPip = true;
      }
    }

  };

  afterNavigate(handleRouteChange);

  // Run it once immediately
  handleRouteChange();
});


  // Watch for selected video changes
  $effect(() => {
    if ($selectedVideo.id) {
      fetchVideoData($selectedVideo.id);
      isPip = !$selectedVideo.isFullScreen;
      
      // Animate based on isFullScreen state
      if (!$selectedVideo.isFullScreen && videoContainer) {
        gsap.to(videoContainer, {
          y: window.innerHeight - 180,
          x: -20,
          width: '280px',
          borderRadius: '8px',
          boxShadow: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
          duration: 0.5,
          ease: 'power2.out'
        });
      } else if (videoContainer) {
        gsap.to(videoContainer, {
          y: 0,
          x: 0,
          width: '100%',
          borderRadius: 0,
          boxShadow: 'none',
          duration: 0.5,
          ease: 'power2.inOut'
        });
      }
    }
  });

  // Watch for page changes
  
</script>

{#if $selectedVideo.id}
  <div 
    bind:this={videoContainer}
    class="video-container scroll-container h-full overflow-y-auto"
    
  >
    <button
      class="relative aspect-video bg-black cursor-pointer w-full text-left"
      onclick={togglePip}
      aria-label="Toggle picture-in-picture mode"
    >
      {#if $activeVideo?.url}
        <div class="vidplayer"  bind:this={vidPlayer}>
            <VideoPlayer videoUrl={$activeVideo.url} />
        </div>
      {/if}
      
      <!-- Video Info -->
      <div class="absolute bottom-0 left-0 right-0 p-4 bg-gradient-to-t from-black/80 to-transparent text-white pointer-events-none">
        <div class="flex items-center justify-between">
          <div class="p-4 flex items-center gap-4">
            <h3 class="text-sm font-medium truncate">{$activeVideo?.title}</h3>
            <p class="text-xs text-neutral-300">{$activeVideo?.author}</p>
          </div>
          <!-- PiP Toggle Button -->
         
        </div>
      </div>
    </button>

    {#if !isPip && videoData}
        <VideoInfo data={videoData} />
   
    {/if}
  </div>
{/if}

<style>
  .video-container {
    transform-origin: bottom right;
    position: fixed;
    top: 0;
    right: 0;
    background: black;
  }

</style>
</file>

<file path="src/lib/components/PlayingDesktopColumn.svelte">
<script lang="ts">
    import { activeVideo } from "$lib/stores/video";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { page } from "$app/stores";
    import { onMount } from "svelte";
    import VideoInfo from "./VideoInfo.svelte";
    import VideoPlayer from "./VideoPlayer.svelte";
    import { afterNavigate, goto } from "$app/navigation";
    import {
        getVideoById as lookupVideo,
        videosStore,
    } from "$lib/stores/library";

    import type { Video } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    let videoData = $state<VideoData | null>(null);
    let isFullscreenRoute = $derived(
        $page.url.pathname.startsWith("/videos/") &&
            $page.url.pathname !== "/videos",
    );

    async function fetchVideoData(id: string) {
        try {
            let video = lookupVideo(id);
            if (!video && id === "home") {
                video = $videosStore[0];
            }
            if (!video) throw new Error("Video not found");

            videoData = { video };

            activeVideo.setActive({
                id: video.id,
                url: video.videoUrl ?? video.url ?? "",
                title: video.title,
                author: video.author,
                authorId: video.authorId,
            });
        } catch (error) {
            console.error("Error fetching video data:", error);
        }
    }

    function expandToFullscreen() {
        if ($selectedVideo.id) {
            selectedVideo.toggleFullScreen();
            goto(`/videos/${$selectedVideo.id}`);
        }
    }

    onMount(() => {
        if ($selectedVideo.id) {
            let video = lookupVideo($selectedVideo.id);
            if (!video && $selectedVideo.id === "home") {
                video = $videosStore[0];
            }
            if (video) {
                videoData = { video };
            }
        }

        afterNavigate(() => {
            // no-op, reactive $derived handles isFullscreenRoute
        });
    });

    $effect(() => {
        if ($selectedVideo.id) {
            fetchVideoData($selectedVideo.id);
        }
    });
</script>

// place files you want to import through the `$lib` alias in this folder.
{#if $selectedVideo.id && !isFullscreenRoute}
    <!-- Desktop-only column next to Sidebar -->
    <div
        class="hidden lg:flex flex-col w-[500px] shrink-0 border-l border-neutral-200 dark:border-neutral-800 bg-white dark:bg-black h-full overflow-scroll top-0"
    >
        <!-- Video at top -->
        <button
            class="relative aspect-video bg-black w-full"
            onclick={expandToFullscreen}
            aria-label="Expand video to fullscreen"
        >
            {#if $activeVideo?.url}
                <div>
                    <VideoPlayer videoUrl={$activeVideo.url} />
                </div>
            {/if}
        </button>

        <!-- Video information underneath -->
        {#if videoData}
            <div class="flex-1 overflow-y-auto">
                <VideoInfo data={videoData} />
            </div>
        {/if}
    </div>
{/if}
</file>

<file path="src/lib/components/VideoCard.svelte">
<script lang="ts">
  import { selectedVideo } from '$lib/stores/selectedVideo';

  export let video: {
    id: string;
    title: string;
    author: string;
    thumbnailUrl: string;
  };

  function handleVideoClick() {
    // If we're already on this video, toggle PiP
    if ($selectedVideo.id === video.id) {
      selectedVideo.toggleFullScreen();
    } else {
      // Otherwise select the new video
      selectedVideo.selectVideo(video.id);
    }
  }
</script>

<div 
  class="group relative aspect-video overflow-hidden rounded-lg bg-neutral-900 cursor-pointer"
  on:click={handleVideoClick}
>
  <img 
    src={video.thumbnailUrl} 
    alt={video.title}
    class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
  />
  <div class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100">
    <div class="absolute bottom-0 left-0 right-0 p-4">
      <h3 class="text-sm font-medium text-white truncate">{video.title}</h3>
      <p class="text-xs text-neutral-300">{video.author}</p>
    </div>
  </div>
</div>
</file>

<file path="src/lib/components/VideoPlayer.svelte">
<script lang="ts">
  import { onMount } from 'svelte';
  import 'hls-video-element';

  const props = $props<{
    videoUrl?: string;
    autoplay?: boolean;
    controls?: boolean;
    muted?: boolean;
    loop?: boolean;
    poster?: string;
  }>();

  let videoUrl = $state(props.videoUrl ?? '');
  let autoplay = $state(props.autoplay ?? false);
  let controls = $state(props.controls ?? true);
  let muted = $state(props.muted ?? false);
  let loop = $state(props.loop ?? false);
  let poster = $state<string | undefined>(props.poster);

  $effect(() => {
    videoUrl = props.videoUrl ?? '';
    autoplay = props.autoplay ?? false;
    controls = props.controls ?? true;
    muted = props.muted ?? false;
    loop = props.loop ?? false;
    poster = props.poster;
  });

const isHls = $derived(videoUrl?.toLowerCase().includes('.m3u8') ?? false);
let videoElement = $state<any>(null);

	onMount(() => {
		if (!videoElement) return;
		if (autoplay) {
			videoElement
				.play()
				.catch(() => {
					// Autoplay may be blocked; leave the video paused.
				});
		}
	});

	$effect(() => {
		if (!videoElement) return;
		if (!videoUrl) {
			videoElement.src = '';
			videoElement.removeAttribute('src');
			videoElement.pause();
			return;
		}

		const targetSrc = videoUrl ?? '';
		const currentSrc = videoElement.getAttribute('src') ?? '';
		if (currentSrc !== targetSrc) {
			if (isHls) {
				(videoElement as unknown as HTMLMediaElement).src = targetSrc;
				videoElement.setAttribute('src', targetSrc);
			} else {
				videoElement.src = targetSrc;
			}

			if (autoplay) {
				videoElement
					.play()
					.catch(() => {});
			} else {
				videoElement.pause();
			}
		}
	});
</script>

{#if videoUrl}
  {#if isHls}
    <hls-video
      bind:this={videoElement}
      class="video-player"
      crossorigin="anonymous"
      {controls}
      {loop}
      {muted}
      playsinline
      poster={poster}
    ></hls-video>
  {:else}
    <video
      bind:this={videoElement}
      class="video-player"
      {controls}
      {loop}
      {muted}
      playsinline
      poster={poster}
    >
      <source src={videoUrl} type="video/mp4" />
      Your browser does not support the video tag.
    </video>
  {/if}
{:else}
  <div class="video-player video-player--empty">
    <p>No video selected</p>
  </div>
{/if}

<style>
	.video-player {
		width: 100%;
		height: 100%;
		display: block;
		object-fit: cover;
		background: black;
	}

	.video-player--empty {
		display: flex;
		align-items: center;
		justify-content: center;
		color: rgba(255, 255, 255, 0.7);
		font-size: 0.875rem;
		background: rgba(17, 24, 39, 0.8);
		padding: 1.5rem;
	}
</style>
</file>

<file path="src/lib/components/VideoTimeline.svelte">
<script lang="ts">
    import { onMount, onDestroy, tick } from "svelte";
    import { browser } from "$app/environment";
    import { activeVideo } from "$lib/stores/video";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { videosStore } from "$lib/stores/library";
    import {
        seekTo,
        updateCurrentTime,
        updateDuration,
        updatePlayingState,
        getPlayerState,
    } from "$lib/stores/playerStore.svelte";
    import {
        generateMockWaveform,
        type WaveformData,
    } from "$lib/utils/waveform";

    let videoEl: HTMLVideoElement | null = null;
    let duration = $state(0);
    let currentTime = $state(0);
    let playing = $state(false);
    let rafId: number | null = null;
    let trackEl: HTMLDivElement | null = null;
    let isDragging = $state(false);
    let isScrubbing = $state(false);
    let isHovering = $state(false);
    let hoverTime = $state(0);
    let hoverX = $state(0);
    let waveformData = $state<WaveformData | null>(null);

    // Store event listeners in component scope to avoid memory leaks
    let currentListeners: {
        onTime: () => void;
        onPlay: () => void;
        onPause: () => void;
        onLoaded: () => void;
    } | null = null;

    const playlist = $derived($videosStore);
    const currentVideoId = $derived($selectedVideo.id);
    const currentIndex = $derived(
        playlist.findIndex((video) => video.id === currentVideoId),
    );
    const currentVideo = $derived(playlist[currentIndex]);

    // Use actual video element duration when available, fall back to database duration
    const effectiveDuration = $derived(
        videoEl && videoEl.duration > 0
            ? Math.floor(videoEl.duration)
            : (currentVideo?.duration ?? 0),
    );

    $effect(() => {
        if (currentVideo) {
            duration = currentVideo.duration ?? 0;
            // Generate waveform when video changes (fewer bars for simpler look)
            waveformData = generateMockWaveform(60, duration);
        } else if (duration > 0) {
            // Fallback: generate waveform even if currentVideo is not available
            waveformData = generateMockWaveform(60, duration);
        }
    });

    function stepQueue(offset: number) {
        if (!playlist.length) return;
        const length = playlist.length;
        const base =
            currentIndex === -1 ? (offset > 0 ? 0 : length - 1) : currentIndex;
        const next = (base + offset + length) % length;
        const target = playlist[next];
        if (target) {
            selectedVideo.selectVideo(target.id);
            activeVideo.setActive({
                id: target.id,
                url: target.videoUrl ?? target.url ?? "",
                title: target.title,
                author: target.author,
                authorId: target.authorId,
                duration: target.duration,
            });
            tick().then(() => {
                videoEl?.play().catch((err) => {
                    console.warn("Autoplay was prevented.", err);
                });
            });
        }
    }

    function goPrevious(event: MouseEvent) {
        event.stopPropagation();
        stepQueue(-1);
    }

    function goNext(event: MouseEvent) {
        event.stopPropagation();
        stepQueue(1);
    }

    // Type definition for HLS video element
    interface HLSVideoElement extends HTMLElement {
        video?: HTMLVideoElement;
        shadowRoot?: ShadowRoot;
    }

    // helper to find the underlying video element in the sidebar player
    function findVideo(): HTMLVideoElement | null {
        // looks for #player-container inside desktop sidebar (it exists in +layout.svelte)
        const container = document.querySelector("#player-container");
        if (!container) return null;

        // 1) direct query for video in light DOM (works if video is not in shadow DOM)
        const directVideo = container.querySelector("video");
        if (directVideo instanceof HTMLVideoElement) return directVideo;

        // 2) try to find a nested hls-video or hls-video-element and read its internal video (best effort)
        const hls =
            container.querySelector("hls-video") ||
            container.querySelector("hls-video-element");
        if (hls) {
            const hlsElement = hls as HLSVideoElement;

            // Try to access the video property if it exists
            if (hlsElement.video instanceof HTMLVideoElement) {
                return hlsElement.video;
            }

            // Attempt to access shadow root
            if (hlsElement.shadowRoot) {
                const shadowVideo =
                    hlsElement.shadowRoot.querySelector("video");
                if (shadowVideo instanceof HTMLVideoElement) {
                    return shadowVideo;
                }
            }
        }

        return null;
    }

    function attachVideo(v: HTMLVideoElement | null) {
        detachVideo();
        if (!v) return;
        videoEl = v;

        // Create listener functions
        const onTime = () => {
            // when not dragging or scrubbing, update currentTime so UI reflects playback
            if (!isDragging && !isScrubbing) {
                const time = videoEl?.currentTime || 0;
                currentTime = time;
                updateCurrentTime(time);
            }
            if (videoEl && videoEl.duration > 0) {
                const dur = Math.floor(videoEl.duration);
                duration = dur;
                updateDuration(dur);
            }
        };

        const onPlay = () => {
            playing = true;
            updatePlayingState(true);
            startRafLoop();
        };

        const onPause = () => {
            playing = false;
            updatePlayingState(false);
            stopRafLoop();
        };

        const onLoaded = () => {
            if (videoEl && videoEl.duration > 0) {
                const dur = Math.floor(videoEl.duration);
                duration = dur;
                updateDuration(dur);
            }
        };

        // Store listeners in component scope
        currentListeners = { onTime, onPlay, onPause, onLoaded };

        videoEl.addEventListener("timeupdate", onTime);
        videoEl.addEventListener("play", onPlay);
        videoEl.addEventListener("pause", onPause);
        videoEl.addEventListener("loadedmetadata", onLoaded);

        // initialize state
        const time = videoEl.currentTime || 0;
        currentTime = time;
        updateCurrentTime(time);
        if (videoEl && videoEl.duration > 0) {
            const dur = Math.floor(videoEl.duration);
            duration = dur;
            updateDuration(dur);
        }
        playing = !videoEl.paused;
        updatePlayingState(playing);

        if (playing) startRafLoop();
    }

    function detachVideo() {
        if (!videoEl || !currentListeners) return;

        videoEl.removeEventListener("timeupdate", currentListeners.onTime);
        videoEl.removeEventListener("play", currentListeners.onPlay);
        videoEl.removeEventListener("pause", currentListeners.onPause);
        videoEl.removeEventListener(
            "loadedmetadata",
            currentListeners.onLoaded,
        );

        stopRafLoop();
        currentListeners = null;
        videoEl = null;
    }

    function startRafLoop() {
        if (rafId != null) return;
        const loop = () => {
            if (videoEl && !isDragging && !isScrubbing) {
                const time = videoEl.currentTime;
                currentTime = time;
                updateCurrentTime(time);
                const dur = videoEl.duration
                    ? Math.floor(videoEl.duration)
                    : duration;
                duration = dur;
                updateDuration(dur);
            }
            rafId = requestAnimationFrame(loop);
        };
        rafId = requestAnimationFrame(loop);
    }

    function stopRafLoop() {
        if (rafId != null) {
            cancelAnimationFrame(rafId);
            rafId = null;
        }
    }

    function togglePlay() {
        if (!videoEl) return;
        if (videoEl.paused) videoEl.play().catch(() => {});
        else videoEl.pause();
    }

    function onSeekInput(e: Event) {
        if (!videoEl) return;
        const input = e.target as HTMLInputElement;
        const val = parseFloat(input.value) || 0;
        currentTime = val;
    }

    function onSeekChange(e: Event) {
        if (!videoEl) return;
        const input = e.target as HTMLInputElement;
        const val = parseFloat(input.value) || 0;
        videoEl.currentTime = val;
    }

    // Calculate time from mouse position
    function calculateTimeFromPosition(e: MouseEvent): number {
        if (!trackEl) return 0;
        const rect = trackEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, x / rect.width));
        return effectiveDuration * pct;
    }

    // Click to seek
    function onTrackClick(e: MouseEvent) {
        if (!trackEl) return;
        const newTime = calculateTimeFromPosition(e);
        seekTo(newTime);
        currentTime = newTime;
    }

    // Mouse down to start scrubbing
    function onTrackMouseDown(e: MouseEvent) {
        if (!browser || e.button !== 0) return; // Only left click in browser
        isScrubbing = true;
        const newTime = calculateTimeFromPosition(e);
        seekTo(newTime);
        currentTime = newTime;

        // Add global mouse event listeners
        window.addEventListener("mousemove", onTrackMouseMove);
        window.addEventListener("mouseup", onTrackMouseUp);
    }

    // Mouse move while scrubbing
    function onTrackMouseMove(e: MouseEvent) {
        if (!isScrubbing || !trackEl) return;
        const newTime = calculateTimeFromPosition(e);
        seekTo(newTime);
        currentTime = newTime;
    }

    // Mouse up to stop scrubbing
    function onTrackMouseUp() {
        if (!browser || !isScrubbing) return;
        isScrubbing = false;

        // Remove global mouse event listeners
        window.removeEventListener("mousemove", onTrackMouseMove);
        window.removeEventListener("mouseup", onTrackMouseUp);
    }

    // Handle mouse enter on timeline
    function onTrackMouseEnter() {
        isHovering = true;
    }

    // Handle mouse leave on timeline
    function onTrackMouseLeave() {
        isHovering = false;
    }

    // Handle mouse move for hover preview
    function onTrackHover(e: MouseEvent) {
        if (!trackEl) return;
        const rect = trackEl.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const pct = Math.max(0, Math.min(1, x / rect.width));
        hoverTime = effectiveDuration * pct;
        hoverX = pct * 100;
    }

    function formatTime(t: number) {
        if (!isFinite(t) || t <= 0) return "0:00";
        const min = Math.floor(t / 60);
        const sec = Math.floor(t % 60);
        return `${min}:${sec.toString().padStart(2, "0")}`;
    }

    let observer: MutationObserver | null = null;

    onMount(() => {
        // initial find
        attachVideo(findVideo());

        // Watch for DOM changes only in the player container, not the entire document
        const container = document.querySelector("#player-container");
        if (container) {
            observer = new MutationObserver(() => {
                const found = findVideo();
                if (found !== videoEl) {
                    attachVideo(found);
                }
            });
            // Only observe the specific container, not subtree to reduce overhead
            observer.observe(container, { childList: true, subtree: false });
        }
    });

    onDestroy(() => {
        detachVideo();
        if (observer) {
            observer.disconnect();
            observer = null;
        }
        // Clean up scrubbing event listeners (only in browser)
        if (browser) {
            window.removeEventListener("mousemove", onTrackMouseMove);
            window.removeEventListener("mouseup", onTrackMouseUp);
        }
    });
</script>

<div class="px-8">
    <div class="flex items-center">
        <div class="flex-1 relative">
            <!-- visual track with playhead overlay -->
            <div
                bind:this={trackEl}
                class="relative cursor-pointer py-3 group"
                on:mousedown={onTrackMouseDown}
                on:mouseenter={onTrackMouseEnter}
                on:mouseleave={onTrackMouseLeave}
                on:mousemove={onTrackHover}
                role="slider"
                aria-label="Video timeline"
                aria-valuemin="0"
                aria-valuemax={effectiveDuration}
                aria-valuenow={currentTime}
                tabindex="0"
            >
                <!-- Waveform visualization -->
                {#if waveformData && waveformData.peaks.length > 0}
                    <div
                        class="absolute left-0 right-0 top-1/2 -translate-y-1/2 flex items-center gap-[2px] h-8"
                    >
                        {#each waveformData.peaks as peak, i}
                            {@const barWidth = 100 / waveformData.peaks.length}
                            {@const barHeight = Math.max(peak * 100, 20)}
                            {@const isPlayed =
                                i / waveformData.peaks.length <=
                                currentTime / effectiveDuration}
                            <div
                                class="flex-1 self-center rounded-sm transition-all duration-100"
                                style="height: {barHeight}%; background-color: {isPlayed
                                    ? 'rgb(233, 149, 12)'
                                    : 'rgba(156, 163, 175, 0.4)'}; min-width: 2px;"
                            ></div>
                        {/each}
                    </div>
                {:else}
                    <!-- Fallback to simple bar if no waveform -->
                    <div
                        class="absolute left-0 right-0 top-1/2 -translate-y-1/2 h-2 bg-gray-700/50 dark:bg-gray-600/50 rounded-full transition-all duration-200 {isHovering
                            ? 'h-3'
                            : 'h-2'}"
                    ></div>
                    <div
                        class="absolute left-0 top-1/2 -translate-y-1/2 h-2 rounded-full transition-all duration-200 {isHovering
                            ? 'h-3'
                            : 'h-2'}"
                        style="width: {effectiveDuration
                            ? (currentTime / effectiveDuration) * 100
                            : 0}%; background: rgb(233, 149, 12)"
                    ></div>
                {/if}

                <!-- Hover preview indicator -->
                {#if isHovering && !isScrubbing}
                    <div
                        class="absolute inset-y-0 -translate-x-1/2 transform pointer-events-none flex items-center"
                        style="left: {hoverX}%"
                    >
                        <div
                            class="w-px h-full bg-[rgb(233,149,12)] shadow-[0_0_8px_rgba(233,149,12,0.45)]"
                        ></div>
                        <div
                            class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 px-2 py-1 rounded-sm bg-gray-900/90 text-white text-[10px] tracking-tight shadow-lg backdrop-blur-sm"
                        >
                            {formatTime(hoverTime)}
                        </div>
                    </div>
                {/if}

                <!-- Playhead indicator -->
                <div
                    class="absolute top-1/2 -translate-x-1/2 -translate-y-1/2 w-3 h-3 bg-white border-2 border-orange-500 rounded-full shadow-lg pointer-events-none transition-transform duration-200 {isScrubbing ||
                    isHovering
                        ? 'scale-125'
                        : 'scale-100'} transform"
                    style="left: {effectiveDuration
                        ? (currentTime / effectiveDuration) * 100
                        : 0}%;"
                ></div>
            </div>

            <!-- accessible range input (keeps in sync) -->
            <input
                type="range"
                min="0"
                max={effectiveDuration || 0}
                step="0.1"
                value={currentTime}
                on:input={onSeekInput}
                on:change={onSeekChange}
                class="timeline-accessible-range"
                on:mousedown={() => (isDragging = true)}
                on:mouseup={() => (isDragging = false)}
            />
        </div>

        <div
            class="text-xs tabular-nums text-gray-700 dark:text-gray-200 w-10 bg text-right"
        >
            {formatTime(Math.max(0, effectiveDuration - (currentTime || 0)))}
        </div>
    </div>
</div>

<style>
    /* small tweaks for the inline playhead and track */
    :global(.dark) .bg-gray-200 {
        background-color: rgba(255, 255, 255, 0.06);
    }
    input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 0;
        height: 0;
    }
    input[type="range"]::-moz-range-thumb {
        width: 0;
        height: 0;
        border: none;
    }
    .timeline-accessible-range {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        opacity: 0;
        pointer-events: none;
        background: transparent;
    }
    .timeline-accessible-range:focus-visible {
        opacity: 1;
        pointer-events: auto;
        outline: 2px solid rgb(233, 149, 12);
        outline-offset: 4px;
    }
    .timeline-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 36px;
        height: 36px;
        border-radius: 9999px;
        border: none;
        background: rgba(255, 255, 255, 0.1);
        color: white;
        transition:
            background 0.2s ease,
            transform 0.2s ease;
    }

    .timeline-button:hover {
        transform: scale(1.05);
        background: rgba(255, 255, 255, 0.2);
    }

    .timeline-button svg {
        width: 18px;
        height: 18px;
        fill: currentColor;
    }
</style>
</file>

<file path="src/lib/data/comments.ts">
import type { Comment } from '$lib/types/content';

export const comments: Comment[] = [
	{
		id: 1,
		user: 'Sarah Chen',
		avatar: 'https://i.pravatar.cc/150?img=1',
		content:
			'The lighting in this scene is particularly striking. The way the shadows fall creates a dramatic contrast.',
		timestamp: '2 hours ago',
		likes: 12
	},
	{
		id: 2,
		user: 'Michael Rodriguez',
		avatar: 'https://i.pravatar.cc/150?img=2',
		content:
			'I notice the subtle camera movement here - it adds a lot of depth to the composition.',
		timestamp: '5 hours ago',
		likes: 8
	},
	{
		id: 3,
		user: 'Emma Thompson',
		avatar: 'https://i.pravatar.cc/150?img=3',
		content: 'The color grading in this shot really enhances the mood. Great work!',
		timestamp: '1 day ago',
		likes: 15
	}
];

export function getCommentsByVideoId(_videoId: string): Comment[] {
	return comments;
}
</file>

<file path="src/lib/server/db/index.ts">
// src/lib/db/index.ts

import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

// This function will be called by your layout
export function getDb(connectionString: string) {
	const client = postgres(connectionString);
	return drizzle(client, { schema });
}
</file>

<file path="src/lib/server/db/schema.ts">
import {
	pgTable,
	pgSchema,
	text,
	integer,
	doublePrecision,
	primaryKey,
	uniqueIndex,
	index,
	serial,
	timestamp,
	uuid
} from 'drizzle-orm/pg-core';

const authSchema = pgSchema('auth');

export const authUsers = authSchema.table('users', {
	id: uuid('id').primaryKey()
});

export const users = pgTable(
	'users',
	{
		id: serial('id').primaryKey(),
		slug: text('slug').notNull(),
		name: text('name').notNull(),
		avatar: text('avatar'),
		bio: text('bio'),
		authId: uuid('auth_id').references(() => authUsers.id, { onDelete: 'set null' }),
		createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
	},
	(table) => ({
		slugIdx: uniqueIndex('users_slug_unique').on(table.slug),
		authIdx: uniqueIndex('users_auth_id_unique').on(table.authId)
	})
);

export const videos = pgTable(
	'videos',
	{
		id: text('id').primaryKey(),
		title: text('title').notNull(),
		description: text('description').notNull(),
		userId: integer('user_id')
			.notNull()
			.references(() => users.id, { onDelete: 'cascade' }),
		videoUrl: text('video_url'),
		thumbnailUrl: text('thumbnail_url'),
		duration: integer('duration').notNull().default(0),
		uploadedAt: timestamp('uploaded_at', { withTimezone: true }),
		views: integer('views').notNull().default(0),
		likes: integer('likes').notNull().default(0),
		latitude: doublePrecision('latitude'),
		longitude: doublePrecision('longitude'),
		transcript: text('transcript'),
		createdAt: timestamp('created_at', { withTimezone: true }).defaultNow()
	},
	(table) => ({
		userIdx: index('videos_user_idx').on(table.userId)
	})
);

export const tags = pgTable(
	'tags',
	{
		id: serial('id').primaryKey(),
		name: text('name').notNull()
	},
	(table) => ({
		nameIdx: uniqueIndex('tags_name_unique').on(table.name)
	})
);

export const videoTags = pgTable(
	'video_tags',
	{
		videoId: text('video_id')
			.notNull()
			.references(() => videos.id, { onDelete: 'cascade' }),
		tagId: integer('tag_id')
			.notNull()
			.references(() => tags.id, { onDelete: 'cascade' })
	},
	(table) => ({
		pk: primaryKey({ columns: [table.videoId, table.tagId] })
	})
);

export const userFollows = pgTable(
	'user_follows',
	{
		followerId: integer('follower_id')
			.notNull()
			.references(() => users.id, { onDelete: 'cascade' }),
		followingId: integer('following_id')
			.notNull()
			.references(() => users.id, { onDelete: 'cascade' })
	},
	(table) => ({
		pk: primaryKey({ columns: [table.followerId, table.followingId] })
	})
);

export type UserInsert = typeof users.$inferInsert;
export type UserSelect = typeof users.$inferSelect;
export type VideoInsert = typeof videos.$inferInsert;
export type VideoSelect = typeof videos.$inferSelect;
export type TagInsert = typeof tags.$inferInsert;
export type TagSelect = typeof tags.$inferSelect;

import { relations } from 'drizzle-orm';

// A user can have many videos, and be a follower/followee
export const usersRelations = relations(users, ({ many }) => ({
	videos: many(videos),
	// This part was missing:
	followers: many(userFollows, { relationName: 'followers' }),
	following: many(userFollows, { relationName: 'following' })
}));

// A video belongs to one user and can have many tags
export const videosRelations = relations(videos, ({ one, many }) => ({
	user: one(users, {
		fields: [videos.userId],
		references: [users.id]
	}),
	videoTags: many(videoTags)
}));

// A tag can be on many videos
export const tagsRelations = relations(tags, ({ many }) => ({
	videoTags: many(videoTags)
}));

// --- Many-to-Many Join Table Relations ---

// videoTags (joins videos and tags)
export const videoTagsRelations = relations(videoTags, ({ one }) => ({
	video: one(videos, {
		fields: [videoTags.videoId],
		references: [videos.id]
	}),
	tag: one(tags, {
		fields: [videoTags.tagId],
		references: [tags.id]
	})
}));

// userFollows (joins users to users)
export const userFollowsRelations = relations(userFollows, ({ one }) => ({
	follower: one(users, {
		fields: [userFollows.followerId],
		references: [users.id],
		relationName: 'followers' // 'followers' tracks who is following a user
	}),
	following: one(users, {
		fields: [userFollows.followingId],
		references: [users.id],
		relationName: 'following' // 'following' tracks who a user is following
	})
}));
</file>

<file path="src/lib/server/db/users.ts">
// src/lib/server/db/users.ts

import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';
import * as schema from './schema';
import { users, videos, userFollows } from './schema';
import type { User, UserVideoSummary } from '$lib/types/content';
import { eq } from 'drizzle-orm';
import type { User as SupabaseAuthUser } from '@supabase/supabase-js';

// Define the type for your database instance
type DrizzleDb = PostgresJsDatabase<typeof schema>;

const DEFAULT_AVATAR = 'https://i.pravatar.cc/150?img=15';
const DEFAULT_THUMBNAIL = 'https://placehold.co/400x225?text=Video';

function slugify(value: string): string {
    return value
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .replace(/-{2,}/g, '-');
}

// --- Internal Helper Functions ---

function summariseVideos(rows: Array<{
    id: string;
    title: string;
    thumbnailUrl: string | null;
    duration: number | null;
    userId: number;
}>): Map<number, UserVideoSummary[]> {
    const map = new Map<number, UserVideoSummary[]>();
    for (const row of rows) {
        const entry = map.get(row.userId) ?? [];
        entry.push({
            id: row.id,
            title: row.title,
            thumbnail: row.thumbnailUrl ?? DEFAULT_THUMBNAIL,
            duration: row.duration ?? 0
        });
        map.set(row.userId, entry);
    }
    return map;
}

function computeFollowMaps(rows: Array<{ followerId: number; followingId: number }>) {
    const followers = new Map<number, Set<number>>();
    const following = new Map<number, Set<number>>();

    for (const row of rows) {
        const followersSet = followers.get(row.followingId) ?? new Set<number>();
        followersSet.add(row.followerId);
        followers.set(row.followingId, followersSet);

        const followingSet = following.get(row.followerId) ?? new Set<number>();
        followingSet.add(row.followingId);
        following.set(row.followerId, followingSet);
    }

    return { followers, following };
}

function formatUser(row: typeof users.$inferSelect, options: {
    videos: UserVideoSummary[];
    followers: number;
    following: number;
}): User {
    const { videos, followers, following } = options;
    return {
        id: row.slug,
        name: row.name,
        avatar: row.avatar ?? DEFAULT_AVATAR,
        bio: row.bio ?? '',
        stats: {
            videos: videos.length,
            followers,
            following
        },
        videos,
        recentVideos: videos.slice(0, 3),
        subscribers: followers,
        joinedAt:
            row.createdAt instanceof Date
                ? row.createdAt.toISOString()
                : row.createdAt ?? undefined
    };
}

// --- Exported Database Functions ---

export async function getAllUsers(db: DrizzleDb): Promise<User[]> {
    const userRows = await db.select().from(users).execute();
    const videoRows = await db
        .select({
            id: videos.id,
            title: videos.title,
            thumbnailUrl: videos.thumbnailUrl,
            duration: videos.duration,
            userId: videos.userId
        })
        .from(videos)
        .execute();
    const followRows = await db.select().from(userFollows).execute();

    const videosByUser = summariseVideos(videoRows);
    const { followers, following } = computeFollowMaps(followRows);

    return userRows.map((row) =>
        formatUser(row, {
            videos: videosByUser.get(row.id) ?? [],
            followers: followers.get(row.id)?.size ?? 0,
            following: following.get(row.id)?.size ?? 0
        })
    );
}

export async function getUserBySlug(db: DrizzleDb, slug: string): Promise<User | null> {
    const rows = await db.select().from(users).where(eq(users.slug, slug)).limit(1).execute();
    if (!rows.length) return null;

    const user = rows[0];
    const userVideosRows = await db
        .select({
            id: videos.id,
            title: videos.title,
            thumbnailUrl: videos.thumbnailUrl,
            duration: videos.duration,
            userId: videos.userId
        })
        .from(videos)
        .where(eq(videos.userId, user.id))
        .execute();

    const followerRows = await db
        .select({
            followerId: userFollows.followerId
        })
        .from(userFollows)
        .where(eq(userFollows.followingId, user.id))
        .execute();

    const followingRows = await db
        .select({
            followingId: userFollows.followingId
        })
        .from(userFollows)
        .where(eq(userFollows.followerId, user.id))
        .execute();

    const followersSet = new Set<number>();
    const followingSet = new Set<number>();

    for (const follower of followerRows) {
        if (typeof follower.followerId === 'number') {
            followersSet.add(follower.followerId);
        }
    }

    for (const followee of followingRows) {
        if (typeof followee.followingId === 'number') {
            followingSet.add(followee.followingId);
        }
    }

    return formatUser(user, {
        videos: summariseVideos(userVideosRows).get(user.id) ?? [],
        followers: followersSet.size,
        following: followingSet.size
    });
}

type DbUser = typeof users.$inferSelect;

export async function ensureUserForAuth(db: DrizzleDb, authUser: SupabaseAuthUser): Promise<DbUser> {
    const authId = authUser.id;
    const [existing] = await db
        .select()
        .from(users)
        .where(eq(users.authId, authId))
        .limit(1)
        .execute();

    if (existing) {
        return existing;
    }

    const fallbackSegment = authId.slice(0, 8);
    const preferredName =
        typeof authUser.user_metadata?.name === 'string' && authUser.user_metadata.name.trim().length > 0
            ? authUser.user_metadata.name.trim()
            : authUser.email ?? `Creator ${fallbackSegment}`;

    const baseSlug = (() => {
        const fromMetadata =
            typeof authUser.user_metadata?.slug === 'string' ? authUser.user_metadata.slug.trim() : '';
        const candidateSource = fromMetadata || preferredName || fallbackSegment;
        const generated = slugify(candidateSource);
        return generated.length > 0 ? generated : `user-${fallbackSegment}`;
    })();

    let slugCandidate = baseSlug;
    let attempt = 0;
    while (true) {
        const [conflict] = await db
            .select({ id: users.id })
            .from(users)
            .where(eq(users.slug, slugCandidate))
            .limit(1)
            .execute();

        if (!conflict) {
            break;
        }

        attempt += 1;
        slugCandidate = `${baseSlug}-${attempt}`;
    }

    try {
        const [created] = await db
            .insert(users)
            .values({
                slug: slugCandidate,
                name: preferredName,
                avatar: null,
                bio: null,
                authId
            })
            .returning();

        if (created) {
            return created;
        }
    } catch (error) {
        const [conflict] = await db
            .select()
            .from(users)
            .where(eq(users.authId, authId))
            .limit(1)
            .execute();
        if (conflict) {
            return conflict;
        }
        throw error;
    }

    throw new Error('Failed to ensure creator record for authenticated user.');
}
</file>

<file path="src/lib/server/db/videos.ts">
// src/lib/server/db/videos.ts

import type { PostgresJsDatabase } from 'drizzle-orm/postgres-js';
import * as schema from './schema';
import { users, videos, videoTags, tags } from './schema';
import { desc, eq, inArray, getTableColumns } from 'drizzle-orm';
import type { Video } from '$lib/types/content';

// Define the type for your database instance
type DrizzleDb = PostgresJsDatabase<typeof schema>;

const videoColumns = getTableColumns(videos);

type SelectedVideoRow = typeof videos.$inferSelect & {
	userName: string;
	userSlug: string;
	userAvatar: string | null;
};

// --- Internal Helper Function ---

function mapRowToVideo(row: SelectedVideoRow) {
	const coordinates =
		typeof row.latitude === 'number' && typeof row.longitude === 'number'
			? [
					{
						name: row.title,
						coordinates: [row.longitude, row.latitude] as [number, number], // GeoJSON standard: [lon, lat]
						latitude: row.latitude,
						longitude: row.longitude,
						mapLat: row.latitude,
						mapLon: row.longitude,
						isExterior: 1,
						isDay: 1,
						isGuess: false,
						startTime: 0,
						endTime: 0
					}
				]
			: [];

	const uploadedAt =
		row.uploadedAt instanceof Date ? row.uploadedAt.toISOString() : row.uploadedAt ?? undefined;
	const createdAt =
		row.createdAt instanceof Date ? row.createdAt.toISOString() : row.createdAt ?? undefined;

	return {
		id: row.id,
		title: row.title,
		description: row.description,
		author: row.userName,
		authorId: row.userSlug,
		duration: row.duration ?? 0,
		uploadedAt,
		uploadDate: uploadedAt,
		url: row.videoUrl ?? undefined,
		videoUrl: row.videoUrl ?? undefined,
		thumbnailUrl: row.thumbnailUrl ?? undefined,
		locations: coordinates,
		transcript: row.transcript ?? 'Transcript not available.',
	keywords: [] as string[],
		views: row.views ?? 0,
		likes: row.likes ?? 0,
		timestamp: uploadedAt ?? createdAt
	} satisfies Video;
}

// --- Exported Database Functions ---

export async function getAllVideos(db: DrizzleDb): Promise<Video[]> {
	const rows = (await db
		.select({
			...videoColumns,
			userName: users.name,
			userSlug: users.slug,
			userAvatar: users.avatar
		})
		.from(videos)
		.innerJoin(users, eq(videos.userId, users.id))
		.orderBy(desc(videos.createdAt))
		.execute()) as SelectedVideoRow[];

	const videoIds = rows
		.map((row) => row.id)
		.filter((id): id is string => typeof id === 'string' && id.length > 0);

	const tagRows =
		videoIds.length > 0
			? await db
					.select({
						videoId: videoTags.videoId,
						tag: tags.name
					})
					.from(videoTags)
					.innerJoin(tags, eq(videoTags.tagId, tags.id))
					.where(inArray(videoTags.videoId, videoIds))
					.execute()
			: [];

	const tagsByVideo = new Map<string, string[]>();
	for (const tagRow of tagRows) {
		const list = tagsByVideo.get(tagRow.videoId) ?? [];
		if (typeof tagRow.tag === 'string') {
			list.push(tagRow.tag);
			tagsByVideo.set(tagRow.videoId, list);
		}
	}

	return rows.map((row) => {
		const mapped = mapRowToVideo(row);
		mapped.keywords = tagsByVideo.get(row.id) ?? [];
		return mapped;
	});
}

export async function getVideoById(db: DrizzleDb, id: string): Promise<Video | null> {
	const rows = (await db
		.select({
			...videoColumns,
			userName: users.name,
			userSlug: users.slug,
			userAvatar: users.avatar
		})
		.from(videos)
		.innerJoin(users, eq(videos.userId, users.id))
		.where(eq(videos.id, id))
		.limit(1)
		.execute()) as SelectedVideoRow[];

	if (!rows.length) return null;

	const videoTagsRows = await db
		.select({
			videoId: videoTags.videoId,
			tag: tags.name
		})
		.from(videoTags)
		.innerJoin(tags, eq(videoTags.tagId, tags.id))
		.where(eq(videoTags.videoId, id))
		.execute();

	const video = mapRowToVideo(rows[0] as SelectedVideoRow);
	video.keywords = videoTagsRows.map((row) => row.tag ?? '').filter(Boolean);
	return video;
}

export async function getVideosByUserId(db: DrizzleDb, userId: number): Promise<Video[]> {
	const rows = (await db
		.select({
			...videoColumns,
			userName: users.name,
			userSlug: users.slug,
			userAvatar: users.avatar
		})
		.from(videos)
		.innerJoin(users, eq(videos.userId, users.id))
		.where(eq(videos.userId, userId))
		.orderBy(desc(videos.createdAt))
		.execute()) as SelectedVideoRow[];

	const videoIds = rows
		.map((row) => row.id)
		.filter((videoId): videoId is string => typeof videoId === 'string' && videoId.length > 0);

	const tagRows =
		videoIds.length > 0
			? await db
					.select({
						videoId: videoTags.videoId,
						tag: tags.name
					})
					.from(videoTags)
					.innerJoin(tags, eq(videoTags.tagId, tags.id))
					.where(inArray(videoTags.videoId, videoIds))
					.execute()
			: [];

	const tagsByVideo = new Map<string, string[]>();
	for (const tagRow of tagRows) {
		const list = tagsByVideo.get(tagRow.videoId) ?? [];
		if (typeof tagRow.tag === 'string') {
			list.push(tagRow.tag);
			tagsByVideo.set(tagRow.videoId, list);
		}
	}

	return rows.map((row) => {
		const mapped = mapRowToVideo(row);
		mapped.keywords = tagsByVideo.get(row.id) ?? [];
		return mapped;
	});
}
</file>

<file path="src/lib/stores/appStore.ts">
import { browser } from '$app/environment';
import { writable } from 'svelte/store';
import { gsap } from 'gsap/dist/gsap';
import Flip from 'gsap/dist/Flip';

interface UiState {
	isExpanded: boolean;
}

const store = writable<UiState>({ isExpanded: false });

type LayoutClass = 'fullscreen' | 'sidebar';

let flipRegistered = false;

function getScrollContainer() {
	return document.querySelector('#scroll-content') as HTMLElement | null;
}

function getSidebarDetails() {
	return document.querySelector('#sidebar-details') as HTMLElement | null;
}

function setScrollContainerMode(layout: LayoutClass) {
	const scroller = getScrollContainer();
	if (!scroller) return;
	scroller.classList.add('overflow-y-auto');
	scroller.dataset.layout = layout;
}

function ensureFlipRegistered() {
	if (!flipRegistered) {
		gsap.registerPlugin(Flip);
		flipRegistered = true;
	}
}

function getCurrentLayout(container: HTMLElement): LayoutClass | null {
	if (container.classList.contains('fullscreen')) return 'fullscreen';
	if (container.classList.contains('sidebar')) return 'sidebar';
	return null;
}

function updateLayoutClass(isExpanded: boolean) {
	if (!browser) return;
	const container = document.getElementById('player-container');
	if (!container) return;

	ensureFlipRegistered();

	const nextLayout: LayoutClass = isExpanded ? 'fullscreen' : 'sidebar';
	const previousLayout = getCurrentLayout(container);

	const scroller = getScrollContainer();
	const details = getSidebarDetails();
	const flipTargets = details ? [container, details] : container;

	if (previousLayout === nextLayout) {
		container.classList.remove('fullscreen', 'sidebar');
		container.classList.add(nextLayout);
		if (scroller) {
			setScrollContainerMode(nextLayout);
		}
		return;
	}

	const state = Flip.getState(flipTargets);

	let restoreScroll: (() => void) | null = null;
	if (scroller) {
		const { overflow, overflowX, overflowY } = scroller.style;
		scroller.classList.remove('overflow-y-auto');
		scroller.style.overflow = 'visible';
		let restored = false;
		restoreScroll = () => {
			if (restored) return;
			restored = true;
			scroller.style.overflow = overflow;
			scroller.style.overflowX = overflowX;
			scroller.style.overflowY = overflowY;
			setScrollContainerMode(nextLayout);
		};
	}

	container.classList.remove('fullscreen', 'sidebar');
	container.classList.add(nextLayout);

	const finalize = () => {
		if (restoreScroll) restoreScroll();
		else setScrollContainerMode(nextLayout);
	};

	Flip.from(state, {
		absolute: true,
		duration: 0.38,
		ease: 'power2.inOut',
		onComplete: finalize,
		onInterrupt: finalize
	});
}

export const actions = {
	toggleMode() {
		store.update((current) => {
			const next = { ...current, isExpanded: !current.isExpanded };
			updateLayoutClass(next.isExpanded);
			return next;
		});
	},
	setExpanded(value: boolean) {
		store.update((current) => {
			if (current.isExpanded === value) return current;
			const next = { ...current, isExpanded: value };
			updateLayoutClass(next.isExpanded);
			return next;
		});
	}
};

export const uiState = {
	subscribe: store.subscribe,
	set(value: UiState) {
		store.set(value);
		updateLayoutClass(value.isExpanded);
	},
	update(updater: (state: UiState) => UiState) {
		store.update((state) => {
			const next = updater(state);
			updateLayoutClass(next.isExpanded);
			return next;
		});
	}
};
</file>

<file path="src/lib/stores/auth.ts">
import { writable } from 'svelte/store';

export interface AuthUser {
	id: string;
	name: string;
	email: string;
	avatarUrl?: string;
}

interface AuthState {
	user: AuthUser | null;
}

function createAuthStore() {
	const { subscribe, set, update } = writable<AuthState>({ user: null });

	return {
		subscribe,
		login(user: AuthUser) {
			set({ user });
		},
		logout() {
			set({ user: null });
		},
		updateUser(updater: (user: AuthUser) => AuthUser) {
			update((state) => {
				if (!state.user) return state;
				return { user: updater(state.user) };
			});
		}
	};
}

export const authStore = createAuthStore();
</file>

<file path="src/lib/stores/library.ts">
import { derived, get, writable } from 'svelte/store';
import type { Video, User } from '$lib/types/content';

export const videosStore = writable<Video[]>([]);
export const usersStore = writable<User[]>([]);

export const videosByIdStore = derived(videosStore, ($videos) => {
	const map = new Map<string, Video>();
	for (const video of $videos) {
		map.set(video.id, video);
	}
	return map;
});

export const usersByIdStore = derived(usersStore, ($users) => {
	const map = new Map<string, User>();
	for (const user of $users) {
		map.set(user.id, user);
	}
	return map;
});

export function initialiseLibrary(videos: Video[], users: User[]) {
	videosStore.set(videos);
	usersStore.set(users);
}

export function getVideoById(id: string): Video | undefined {
	return get(videosByIdStore).get(id);
}

export function getUserById(id: string): User | undefined {
	return get(usersByIdStore).get(id);
}
</file>

<file path="src/lib/stores/playerStore.svelte.ts">
/**
 * Central player state store using Svelte 5 runes
 * Manages video playback state and seeking operations
 */

let currentTime = $state(0);
let duration = $state(0);
let isPlaying = $state(false);
let seekRequested = $state<number | null>(null);

/**
 * Request a seek to a specific time in the video
 * This will trigger the video player to update its position
 */
export function seekTo(time: number) {
	if (time < 0 || !isFinite(time)) return;
	seekRequested = time;
	currentTime = time;
}

/**
 * Update the current playback time
 * Should be called by the video player as it plays
 */
export function updateCurrentTime(time: number) {
	currentTime = time;
	// Clear seek request after it's been applied
	if (seekRequested !== null && Math.abs(seekRequested - time) < 0.5) {
		seekRequested = null;
	}
}

/**
 * Update the video duration
 * Should be called when video metadata is loaded
 */
export function updateDuration(dur: number) {
	duration = dur;
}

/**
 * Update the playing state
 */
export function updatePlayingState(playing: boolean) {
	isPlaying = playing;
}

/**
 * Clear seek request flag
 * Used internally after seek has been applied
 */
export function clearSeekRequest() {
	seekRequested = null;
}

/**
 * Get the current player state
 * These are reactive getters using Svelte 5 runes
 */
export function getPlayerState() {
	return {
		get currentTime() {
			return currentTime;
		},
		get duration() {
			return duration;
		},
		get isPlaying() {
			return isPlaying;
		},
		get seekRequested() {
			return seekRequested;
		}
	};
}
</file>

<file path="src/lib/stores/selectedVideo.ts">
import { writable } from 'svelte/store';

export type QueueContextType = 'keyword' | 'date' | 'user' | null;

export interface QueueContext {
	type: QueueContextType;
	label: string;
	videoIds: string[];
}

export interface SelectedVideoState {
	id: string | null;
	queue: string[];
	isFullScreen: boolean;
	history: string[];
	queueContext: QueueContext | null;
	originalQueue: string[];
	defaultLiveQueue: string[];
}

const initialState: SelectedVideoState = {
	id: null,
	queue: [],
	isFullScreen: false,
	history: [],
	queueContext: null,
	originalQueue: [],
	defaultLiveQueue: []
};

function resolveNext(state: SelectedVideoState): string | null {
	if (!state.id || state.queue.length === 0) return null;

	const index = state.queue.indexOf(state.id);
	if (index === -1) return state.queue[0] ?? null;
	if (index === state.queue.length - 1) return state.queue[0] ?? null;
	return state.queue[index + 1] ?? null;
}

function resolvePrevious(state: SelectedVideoState): string | null {
	if (!state.id || state.queue.length === 0) return null;

	const index = state.queue.indexOf(state.id);
	if (index === -1) return state.queue[state.queue.length - 1] ?? null;
	if (index === 0) return state.queue[state.queue.length - 1] ?? null;
	return state.queue[index - 1] ?? null;
}

function createSelectedVideoStore() {
	const store = writable<SelectedVideoState>({ ...initialState });
	let snapshot = initialState;

	store.subscribe((value) => {
		snapshot = value;
	});

	function setQueue(videoIds: string[]) {
		store.update((current) => ({
			...current,
			queue: [...videoIds],
			// If we're setting the queue and there's no active queue context, update default live queue
			defaultLiveQueue: !current.queueContext ? [...videoIds] : current.defaultLiveQueue
		}));
	}

	function selectVideo(id: string | null) {
		store.update((current) => {
			if (current.id === id) return current;
			const history = current.id ? [...current.history, current.id] : [...current.history];
			return {
				...current,
				id,
				isFullScreen: false,
				history
			};
		});
	}

	function playNext() {
		const next = resolveNext(snapshot);
		if (next) {
			selectVideo(next);
		} else {
			// If no next video in current queue and we have a queue context,
			// restore the original queue
			if (snapshot.queueContext) {
				clearQueueContext();
			}
		}
	}

	function playPrevious() {
		const previous = resolvePrevious(snapshot);
		if (previous) {
			selectVideo(previous);
		}
	}

	function toggleFullScreen(force?: boolean) {
		store.update((current) => {
			const nextValue = typeof force === 'boolean' ? force : !current.isFullScreen;
			if (current.isFullScreen === nextValue) return current;
			return { ...current, isFullScreen: nextValue };
		});
	}

	function setFullScreen(value: boolean) {
		store.update((current) => {
			if (current.isFullScreen === value) return current;
			return { ...current, isFullScreen: value };
		});
	}

	function setTemporaryQueue(videoIds: string[], context: QueueContext) {
		store.update((current) => {
			// Always use the default live queue as the original queue to restore to
			// If defaultLiveQueue is empty, use current.queue as fallback
			const defaultQueue = current.defaultLiveQueue.length > 0 
				? current.defaultLiveQueue 
				: current.queue;
			
			// Set the temporary queue
			const firstVideoId = videoIds[0] ?? null;
			
			return {
				...current,
				queue: [...videoIds],
				queueContext: context,
				originalQueue: [...defaultQueue],
				id: firstVideoId
			};
		});
	}

	function clearQueueContext() {
		store.update((current) => {
			// Always restore to the default live queue (full video library)
			// Prefer originalQueue if it was saved, otherwise use defaultLiveQueue, fallback to current.queue
			const restoreQueue = current.originalQueue.length > 0 
				? current.originalQueue 
				: (current.defaultLiveQueue.length > 0 ? current.defaultLiveQueue : current.queue);
			
			// Restore the queue and set ID to "home" to trigger live playback computation
			// The layout will compute the correct live video based on current timestamp
			return {
				...current,
				queue: [...restoreQueue],
				queueContext: null,
				originalQueue: [],
				id: "home"
			};
		});
	}

	function reset() {
		store.set({ ...initialState });
	}

	return {
		subscribe: store.subscribe,
		selectVideo,
		setQueue,
		setTemporaryQueue,
		clearQueueContext,
		playNext,
		playPrevious,
		toggleFullScreen,
		setFullScreen,
		reset,
		get id() {
			return snapshot.id;
		},
		get queue() {
			return [...snapshot.queue];
		},
		get isFullScreen() {
			return snapshot.isFullScreen;
		},
		get history() {
			return [...snapshot.history];
		},
		get queueContext() {
			return snapshot.queueContext;
		},
		get nextVideoId() {
			return resolveNext(snapshot);
		},
		get previousVideoId() {
			return resolvePrevious(snapshot);
		}
	};
}

export const selectedVideo = createSelectedVideoStore();
</file>

<file path="src/lib/stores/theme.ts">
import { browser } from '$app/environment';
import { writable } from 'svelte/store';

type Theme = 'light' | 'dark';

const STORAGE_KEY = 'rushes-theme';
const store = writable<Theme>('light');

function applyTheme(next: Theme) {
	if (!browser) return;
	const root = document.documentElement;
	root.classList.toggle('dark', next === 'dark');
	root.dataset.theme = next;
	try {
		localStorage.setItem(STORAGE_KEY, next);
	} catch (error) {
		console.warn('Unable to persist theme preference', error);
	}
}

function detectPreferredTheme(): Theme {
	if (!browser) return 'light';
	const stored = (() => {
		try {
			const value = localStorage.getItem(STORAGE_KEY);
			return value === 'dark' || value === 'light' ? value : null;
		} catch {
			return null;
		}
	})();
	if (stored) return stored;
	return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
}

export const theme = {
	subscribe: store.subscribe,
	/**
	 * Synchronise the theme store with persisted preference and system defaults.
	 */
	init() {
		const initial = detectPreferredTheme();
		store.set(initial);
		applyTheme(initial);
	},
	set(value: Theme) {
		store.set(value);
		applyTheme(value);
	},
	toggle() {
		store.update((current) => {
			const next: Theme = current === 'dark' ? 'light' : 'dark';
			applyTheme(next);
			return next;
		});
	}
};

export type ThemeStore = typeof theme;
</file>

<file path="src/lib/stores/video.ts">
import { writable } from 'svelte/store';

export interface ActiveVideoState {
	id: string;
	url: string;
	title: string;
	author: string;
	authorId?: string;
	thumbnailUrl?: string;
	durationSeconds?: number;
}

function createActiveVideoStore() {
	const store = writable<ActiveVideoState | null>(null);

	return {
		subscribe: store.subscribe,
		setActive(video: ActiveVideoState | null) {
			store.set(video);
		},
		clear() {
			store.set(null);
		}
	};
}

export const activeVideo = createActiveVideoStore();
</file>

<file path="src/lib/types/content.ts">
export interface Location {
	setting?: string;
	environment?: string;
	startTime?: number;
	endTime?: number;
	isExterior?: number;
	isDay?: number;
	longitude?: number;
	latitude?: number;
	mapLat?: number;
	mapLon?: number;
	isGuess?: boolean;
	id?: number;
	name?: string;
	coordinates?: [number, number];
}

export interface Video {
	id: string;
	title: string;
	description: string;
	author: string;
	authorId: string;
	duration?: number;
	uploadedAt?: string;
	url?: string;
	videoUrl?: string;
	thumbnailUrl?: string;
	locations?: Location[];
	keywords?: string[];
	transcript?: string;
	views?: number;
	likes?: number;
	gcs_uri?: string;
	source_url?: string;
	timestamp?: string;
	raw_response_json?: unknown;
	uploadDate?: string;
}

export interface UserVideoSummary {
	id: string;
	title: string;
	thumbnail: string;
	duration?: number;
}

export interface UserStats {
	videos: number;
	followers: number;
	following: number;
}

export interface User {
	id: string;
	name: string;
	avatar: string;
	bio: string;
	stats: UserStats;
	videos: UserVideoSummary[];
	email?: string;
	subscribers?: number;
	joinedAt?: string;
	verified?: boolean;
	recentVideos?: UserVideoSummary[];
}

export interface Comment {
	id: number;
	user: string;
	avatar: string;
	content: string;
	timestamp: string;
	likes: number;
}
</file>

<file path="src/lib/types/dashboard.ts">
export type DashboardComponentKey =
	| 'videos'
	| 'profile'
	| 'activity'
	| 'sounds'
	| 'members'
	| 'keywords'
	| 'locations';

export type DashboardItem = {
	id: number;
	component: DashboardComponentKey;
	[key: string]: unknown;
};

export type SortDirection = 'asc' | 'desc';
export type TableKey = 'videos' | 'sounds' | 'members' | 'keywords';

export interface TableColumn {
	key: string;
	label: string;
	align?: 'left' | 'right';
}

export interface TableState {
	key: TableKey;
	label: string;
	sortKey: string;
	sortDirection: SortDirection;
	defaultSort: { key: string; direction: SortDirection };
	columns: TableColumn[];
}

export interface LatestLocationPin {
	id: string;
	videoId: string;
	videoTitle: string;
	videoAuthor?: string;
	uploadedLabel: string;
	timestampValue: number;
	lat: number;
	lon: number;
	setting?: string;
	thumbnailUrl?: string;
}

export interface LocationCenter {
	lat: number;
	lon: number;
	zoom: number;
}
</file>

<file path="src/lib/utils/waveform.ts">
/**
 * Waveform generation utility for HLS audio streams
 * Uses Web Audio API to analyze audio and generate waveform data
 */

export interface WaveformData {
  peaks: number[];
  duration: number;
}

/**
 * Generate waveform data from an HLS video URL
 * Extracts audio and analyzes it using Web Audio API
 */
export async function generateWaveform(
  videoUrl: string,
  samplesPerSecond: number = 10
): Promise<WaveformData | null> {
  try {
    // Create an audio element to load the HLS stream
    const audio = new Audio();
    audio.crossOrigin = 'anonymous';
    audio.src = videoUrl;

    // Wait for metadata to load
    await new Promise<void>((resolve, reject) => {
      audio.addEventListener('loadedmetadata', () => resolve(), { once: true });
      audio.addEventListener('error', reject, { once: true });
      audio.load();
    });

    const duration = audio.duration;
    if (!duration || !isFinite(duration)) {
      throw new Error('Invalid audio duration');
    }

    // Create audio context
    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    const source = audioContext.createMediaElementSource(audio);
    const analyser = audioContext.createAnalyser();

    // Configure analyser
    analyser.fftSize = 2048;
    source.connect(analyser);
    // Don't connect to destination to avoid playing audio

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    const totalSamples = Math.floor(duration * samplesPerSecond);
    const peaks: number[] = new Array(totalSamples).fill(0);
    const sampleDuration = duration / totalSamples;

    let currentSample = 0;

    // Play the audio (muted) and collect samples
    audio.muted = true;
    audio.play();

    return new Promise<WaveformData>((resolve, reject) => {
      const collectData = () => {
        const currentTime = audio.currentTime;
        const sampleIndex = Math.floor(currentTime / sampleDuration);

        if (sampleIndex < totalSamples) {
          // Get frequency data
          analyser.getByteFrequencyData(dataArray);

          // Calculate RMS (root mean square) for this sample
          let sum = 0;
          for (let i = 0; i < bufferLength; i++) {
            sum += dataArray[i] * dataArray[i];
          }
          const rms = Math.sqrt(sum / bufferLength);

          // Normalize to 0-1 range
          peaks[sampleIndex] = Math.max(peaks[sampleIndex], rms / 255);
        }

        if (currentTime < duration) {
          requestAnimationFrame(collectData);
        } else {
          // Cleanup
          audio.pause();
          audio.src = '';
          audioContext.close();

          resolve({
            peaks,
            duration
          });
        }
      };

      audio.addEventListener('error', () => {
        audioContext.close();
        reject(new Error('Failed to load audio'));
      });

      requestAnimationFrame(collectData);
    });
  } catch (error) {
    console.error('Waveform generation error:', error);
    return null;
  }
}

/**
 * Simplified waveform generation for faster loading
 * Uses fewer samples and simplified analysis
 */
export async function generateSimplifiedWaveform(
  videoElement: HTMLVideoElement,
  samples: number = 100
): Promise<WaveformData | null> {
  try {
    if (!videoElement.src) return null;

    const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();
    const source = audioContext.createMediaElementSource(videoElement);
    const analyser = audioContext.createAnalyser();

    analyser.fftSize = 256;
    analyser.smoothingTimeConstant = 0.8;

    source.connect(analyser);
    analyser.connect(audioContext.destination);

    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    const peaks: number[] = [];

    // Generate mock waveform for now (replace with real-time analysis)
    for (let i = 0; i < samples; i++) {
      analyser.getByteFrequencyData(dataArray);
      let sum = 0;
      for (let j = 0; j < bufferLength; j++) {
        sum += dataArray[j];
      }
      const average = sum / bufferLength / 255;
      peaks.push(average || Math.random() * 0.3 + 0.1);
    }

    return {
      peaks,
      duration: videoElement.duration
    };
  } catch (error) {
    console.error('Simplified waveform generation error:', error);
    return null;
  }
}

/**
 * Generate a mock waveform for testing/fallback
 * Creates a natural-looking random waveform
 */
export function generateMockWaveform(samples: number = 100, duration: number = 0): WaveformData {
  const peaks: number[] = [];

  for (let i = 0; i < samples; i++) {
    // Create more natural variation using sine waves and randomness
    const position = i / samples;
    const lowFreq = Math.sin(position * Math.PI * 2) * 0.3;
    const midFreq = Math.sin(position * Math.PI * 8) * 0.2;
    const noise = Math.random() * 0.2;

    const peak = Math.abs(lowFreq + midFreq + noise);
    peaks.push(Math.min(peak + 0.1, 1)); // Ensure minimum visibility
  }

  return {
    peaks,
    duration
  };
}
</file>

<file path="src/lib/workers/videoMetadata.worker.ts">
/// <reference lib="webworker" />

declare const self: DedicatedWorkerGlobalScope;

type IncomingMessage =
	| {
			type: 'extract-metadata';
			buffer: ArrayBuffer;
			lastModified?: number;
	  };

interface MetadataResult {
	date?: string;
	latitude?: number;
	longitude?: number;
	source?: string;
}

interface CoordinateMatch {
	lat: number;
	lon: number;
	source: string;
}

const decoder = new TextDecoder('utf-8', { fatal: false, ignoreBOM: true });
const MAX_SAMPLE_BYTES = 8 * 1024 * 1024; // Scan 8MB from start and end

self.onmessage = (event: MessageEvent<IncomingMessage>) => {
	const message = event.data;
	if (!message) return;

	if (message.type === 'extract-metadata') {
		try {
			const metadata = extractMetadata(message.buffer, message.lastModified);
			self.postMessage({ type: 'metadata-result', metadata });
		} catch (error) {
			const message =
				error instanceof Error ? error.message : 'Unknown metadata extraction error';
			self.postMessage({ type: 'error', error: message });
		}
	}
};

function extractMetadata(buffer: ArrayBuffer, lastModified?: number): MetadataResult {
	const bytes = new Uint8Array(buffer);
	const sampledText = buildSampledText(bytes);
	const metadata: MetadataResult = {};

	const date = findDate(sampledText) ?? (lastModified ? new Date(lastModified).toISOString() : undefined);
	if (date) {
		metadata.date = date;
	}

	const coords = findCoordinates(sampledText);
	if (coords) {
		metadata.latitude = coords.lat;
		metadata.longitude = coords.lon;
		metadata.source = coords.source;
	}

	return metadata;
}

function buildSampledText(bytes: Uint8Array): string {
	if (bytes.length === 0) return '';

	const segments: string[] = [];
	const headLength = Math.min(bytes.length, MAX_SAMPLE_BYTES);
	segments.push(
		decoder.decode(bytes.subarray(0, headLength)).replace(/\u0000/g, ' ')
	);

	if (bytes.length > MAX_SAMPLE_BYTES) {
		const tailStart = Math.max(0, bytes.length - MAX_SAMPLE_BYTES);
		segments.push(
			decoder.decode(bytes.subarray(tailStart)).replace(/\u0000/g, ' ')
		);
	}

	return segments.join('\n');
}

function findDate(text: string): string | undefined {
	const patterns: RegExp[] = [
		/com\.apple\.quicktime\.creationdate[^0-9]*([0-9]{4}[-:][0-9]{2}[-:][0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2}(?:\.\d+)?(?:Z|[+-][0-9]{2}:?[0-9]{2})?)?)/i,
		/creation_time[^0-9]*([0-9]{4}[-:][0-9]{2}[-:][0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2}(?:\.\d+)?(?:Z|[+-][0-9]{2}:?[0-9]{2})?)?)/i,
		/date_recorded[^0-9]*([0-9]{4}[-:][0-9]{2}[-:][0-9]{2}(?:[ T][0-9]{2}:[0-9]{2}:[0-9]{2})?)/i
	];

	for (const pattern of patterns) {
		const match = text.match(pattern);
		if (match && match[1]) {
			const iso = toIso(match[1]);
			if (iso) return iso;
		}
	}
	return undefined;
}

function toIso(value: string): string | undefined {
	const trimmed = value.trim();
	if (!trimmed) return undefined;

	const normalised = trimmed.replace(/(\d{4}):(\d{2}):(\d{2})/, '$1-$2-$3');
	const withT = normalised.includes('T')
		? normalised
		: normalised.replace(' ', 'T');

	const date = new Date(withT);
	if (!Number.isNaN(date.getTime())) {
		return date.toISOString();
	}

	// Attempt to coerce missing timezone (assume UTC)
	if (/^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/.test(withT)) {
		const utc = new Date(`${withT}Z`);
		if (!Number.isNaN(utc.getTime())) {
			return utc.toISOString();
		}
	}

	if (/^\d{4}-\d{2}-\d{2}$/.test(withT)) {
		return `${withT}T00:00:00.000Z`;
	}

	return undefined;
}

function findCoordinates(text: string): CoordinateMatch | null {
	const candidates = [
		{ term: 'com.apple.quicktime.location.iso6709', window: 160 },
		{ term: 'com.apple.quicktime.location', window: 160 },
		{ term: 'com.apple.quicktime.latitude', window: 200 },
		{ term: 'com.apple.quicktime.longitude', window: 200 },
		{ term: 'ISO6709', window: 160 },
		{ term: '©xyz', window: 120 },
		{ term: 'gps', window: 200 },
		{ term: 'location', window: 200 }
	];

	for (const candidate of candidates) {
		const coords = scanForTerm(text, candidate.term, candidate.window);
		if (coords) return coords;
	}

	const generalIso = scanIsoSequences(text);
	if (generalIso) return generalIso;

	const latLonPair = scanLatLonPairs(text);
	if (latLonPair) return latLonPair;

	return null;
}

function scanForTerm(text: string, term: string, window: number): CoordinateMatch | null {
	const lowerText = text.toLowerCase();
	const lowerTerm = term.toLowerCase();
	let index = lowerText.indexOf(lowerTerm);

	while (index !== -1) {
		const snippet = text.slice(index, Math.min(text.length, index + lowerTerm.length + window));
		const coords = parseCoordinates(snippet);
		if (coords) {
			return { ...coords, source: term };
		}
		index = lowerText.indexOf(lowerTerm, index + lowerTerm.length);
	}

	return null;
}

function scanIsoSequences(text: string): CoordinateMatch | null {
	const isoPattern =
		/([+-]\d{1,3}(?:\.\d+)?)([+-]\d{1,3}(?:\.\d+)?)(?:[+-]\d{1,3}(?:\.\d+)?\/?)?/g;

	let match: RegExpExecArray | null;
	// eslint-disable-next-line no-cond-assign
	while ((match = isoPattern.exec(text))) {
		const coords = parseIsoMatch(match);
		if (coords) {
			return { ...coords, source: 'iso-sequence' };
		}
	}
	return null;
}

function scanLatLonPairs(text: string): CoordinateMatch | null {
	const latPattern = /(latitude|gps_latitude)[^+\-0-9]*([+\-]?\d{1,3}(?:\.\d+)?)/i;
	const lonPattern = /(longitude|gps_longitude)[^+\-0-9]*([+\-]?\d{1,3}(?:\.\d+)?)/i;

	const latMatch = text.match(latPattern);
	const lonMatch = text.match(lonPattern);

	if (latMatch && lonMatch) {
		const lat = Number.parseFloat(latMatch[2]);
		const lon = Number.parseFloat(lonMatch[2]);
		if (isValidCoordinate(lat, lon)) {
			return { lat, lon, source: `${latMatch[1]}/${lonMatch[1]}` };
		}
	}

	return null;
}

function parseCoordinates(snippet: string): Omit<CoordinateMatch, 'source'> | null {
	const iso = parseIsoLike(snippet);
	if (iso) {
		return iso;
	}
	return null;
}

function parseIsoLike(value: string): Omit<CoordinateMatch, 'source'> | null {
	const isoMatch = value.match(/([+-]\d{1,3}(?:\.\d+)?)([+-]\d{1,3}(?:\.\d+)?)/);
	if (isoMatch) {
		const coords = parseIsoMatch(isoMatch);
		if (coords) return coords;
	}

	const delimited = value.match(/([+\-]?\d{1,3}(?:\.\d+)?)[,\s\/]+([+\-]?\d{1,3}(?:\.\d+)?)/);
	if (delimited) {
		const lat = Number.parseFloat(delimited[1]);
		const lon = Number.parseFloat(delimited[2]);
		if (isValidCoordinate(lat, lon)) {
			return { lat, lon };
		}
	}

	return null;
}

function parseIsoMatch(match: RegExpMatchArray): Omit<CoordinateMatch, 'source'> | null {
	if (match.length < 3) return null;
	const lat = Number.parseFloat(match[1]);
	const lon = Number.parseFloat(match[2]);
	if (!isValidCoordinate(lat, lon)) return null;
	return { lat, lon };
}

function isValidCoordinate(lat: number, lon: number): boolean {
	return (
		Number.isFinite(lat) &&
		Number.isFinite(lon) &&
		Math.abs(lat) <= 90 &&
		Math.abs(lon) <= 180
	);
}

export {};
</file>

<file path="src/lib/index.ts">
// place files you want to import through the `$lib` alias in this folder.
</file>

<file path="src/routes/browse/[slug]/+page.svelte">
<script lang="ts">
    import { page } from "$app/stores";
    import { browser } from "$app/environment";
    import { videosStore } from "$lib/stores/library";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import type { QueueContext } from "$lib/stores/selectedVideo";
    import { trackDirectLoad } from "$lib/utils/direct-load";

    const videos = $derived($videosStore);
    const slug = $derived($page.params.slug);

    // Convert slug back to keyword by matching against all keywords
    const keyword = $derived.by(() => {
        const videoList = videos;
        const allKeywordsSet = new Set<string>();
        videoList.forEach((video) => {
            if (video.keywords) {
                video.keywords.forEach((k: string) => allKeywordsSet.add(k));
            }
        });

        const currentSlug = slug;
        // Try to find exact match first (case-insensitive)
        for (const kw of allKeywordsSet) {
            if (
                kw
                    .toLowerCase()
                    .replace(/[^a-z0-9]+/g, "-")
                    .replace(/^-+|-+$/g, "") === currentSlug
            ) {
                return kw;
            }
        }
        return null;
    });

    // Get videos that have this keyword
    const filteredVideos = $derived.by(() => {
        const kw = keyword;
        if (!kw) return [];
        const videoList = videos;
        return videoList.filter(
            (video) => video.keywords && video.keywords.includes(kw),
        );
    });

    // Convert keyword to slug (for consistency)
    function keywordToSlug(kw: string): string {
        return kw
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/^-+|-+$/g, "");
    }

    function handlePlayAll() {
        if (filteredVideos.length === 0) return;
        const videoIds = filteredVideos.map((v) => v.id);
        const kw = keyword;
        if (!kw) return;
        const context: QueueContext = {
            type: "keyword",
            label: kw,
            videoIds
        };
        selectedVideo.setTemporaryQueue(videoIds, context);
    }

    // Track if auto-play has been triggered (prevent duplicate triggers)
    let autoPlayTriggered = $state(false);
    let wasDirectLoad = $state(false);

    trackDirectLoad((value) => {
        wasDirectLoad = value;
    });
    
    // Auto-play on direct page load (not internal navigation)
    // Use $effect to ensure stores are ready
    $effect(() => {
        if (!browser) return;
        if (autoPlayTriggered) return;
        if (!wasDirectLoad) return; // Only for direct loads
        
        // Wait for videos store to be populated
        const allVideos = videos;
        const videosLoaded = allVideos.length > 0;
        if (!videosLoaded) return;
        
        // Wait for keyword to be found and videos filtered
        const kw = keyword;
        const filtered = filteredVideos;
        if (!kw || filtered.length === 0) return;
        
        const hasQueueContext = !!$selectedVideo.queueContext;
        
        // Only auto-play if:
        // 1. No queue context (not interrupting playback)
        // 2. We have filtered videos
        // 3. This was a direct load
        if (!hasQueueContext && filtered.length > 0) {
            autoPlayTriggered = true;
            
            // Small delay to ensure everything is ready
            setTimeout(() => {
                if (filteredVideos.length > 0) {
                    handlePlayAll();
                }
            }, 300);
        }
    });
</script>

<div class="min-h-screen p-8">
    <div class="max-w-7xl mx-auto">
        {#if keyword}
            <header class="mb-8">
                <div class="flex items-center gap-3 mb-2">
                    <a
                        href="/browse"
                        class="text-white/60 hover:text-white text-sm transition-colors"
                    >
                        ← Back to Browse
                    </a>
                </div>
                <div class="flex items-center justify-between mb-2">
                    <div>
                        <h1 class="text-3xl font-bold text-white mb-2">{keyword}</h1>
                        <p class="text-white/60 text-sm">
                            {filteredVideos.length} video{filteredVideos.length === 1
                                ? ""
                                : "s"} tagged with this keyword
                        </p>
                    </div>
                    {#if filteredVideos.length > 0}
                        <button
                            onclick={handlePlayAll}
                            class="px-4 py-2 bg-orange-500/20 text-orange-400 border border-orange-500/40 rounded-lg hover:bg-orange-500/30 transition-colors font-medium text-sm flex items-center gap-2"
                        >
                            <svg
                                xmlns="http://www.w3.org/2000/svg"
                                width="18"
                                height="18"
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="2"
                                    d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
                                />
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="2"
                                    d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                                />
                            </svg>
                            Play All
                        </button>
                    {/if}
                </div>
            </header>

            {#if filteredVideos.length > 0}
                <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
                    {#each filteredVideos as video (video.id)}
                        {@const vid = video}
                        <a
                            href={`/videos/${vid.id}`}
                            onclick={(e) => {
                                e.preventDefault();
                                selectedVideo.selectVideo(vid.id);
                            }}
                            class="block"
                        >
                            <div
                                class="group relative aspect-video overflow-hidden rounded-lg bg-neutral-900 cursor-pointer"
                            >
                                <img
                                    src={vid.thumbnailUrl ?? "https://placehold.co/400x225?text=Video"}
                                    alt={vid.title}
                                    class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                                    loading="lazy"
                                />
                                <div
                                    class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100"
                                >
                                    <div class="absolute bottom-0 left-0 right-0 p-4">
                                        <h3
                                            class="text-sm font-medium text-white truncate"
                                        >
                                            {vid.title}
                                        </h3>
                                        <p class="text-xs text-neutral-300">
                                            {vid.author}
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </a>
                    {/each}
                </div>
            {:else}
                <div
                    class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                >
                    <p class="text-white/60">
                        No videos found with this keyword.
                    </p>
                </div>
            {/if}
        {:else}
            <div class="max-w-7xl mx-auto">
                <header class="mb-8">
                    <a
                        href="/browse"
                        class="text-white/60 hover:text-white text-sm transition-colors"
                    >
                        ← Back to Browse
                    </a>
                    <h1 class="text-3xl font-bold text-white mb-2 mt-4">
                        Keyword Not Found
                    </h1>
                </header>
                <div
                    class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                >
                    <p class="text-white/60">
                        The keyword you're looking for doesn't exist.
                    </p>
                </div>
            </div>
        {/if}
    </div>
</div>
</file>

<file path="src/routes/browse/+page.svelte">
<script lang="ts">
    import { videosStore, usersStore } from "$lib/stores/library";
    import { selectedVideo } from "$lib/stores/selectedVideo";

    const videos = $derived($videosStore);
    const users = $derived($usersStore);
    let activeTab = $state<"keywords" | "date" | "users" | "search">("keywords");
    let searchQuery = $state("");

    // ===== KEYWORDS LOGIC =====
    // Extract all unique keywords from videos
    const allKeywords = $derived.by(() => {
        const keywordSet = new Set<string>();
        videos.forEach((video) => {
            if (video.keywords) {
                video.keywords.forEach((keyword: string) => {
                    keywordSet.add(keyword);
                });
            }
        });
        return Array.from(keywordSet).sort();
    });

    // Group keywords by first letter
    const keywordsByLetter = $derived.by(() => {
        const grouped: Record<string, string[]> = {};
        const keywords = allKeywords;
        keywords.forEach((keyword: string) => {
            const firstLetter = keyword.charAt(0).toUpperCase();
            if (!/[A-Z]/.test(firstLetter)) {
                // If not a letter, group under "#"
                if (!grouped["#"]) grouped["#"] = [];
                grouped["#"].push(keyword);
            } else {
                if (!grouped[firstLetter]) grouped[firstLetter] = [];
                grouped[firstLetter].push(keyword);
            }
        });
        return grouped;
    });

    // Get all letters that have keywords
    const letters = $derived.by(() => {
        const grouped = keywordsByLetter;
        const allLetters = Object.keys(grouped).sort();
        // Put # at the end
        const hashIndex = allLetters.indexOf("#");
        if (hashIndex > -1) {
            allLetters.splice(hashIndex, 1);
            allLetters.push("#");
        }
        return allLetters;
    });

    // Convert keyword to URL slug
    function keywordToSlug(keyword: string): string {
        return keyword
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/^-+|-+$/g, "");
    }

    // Calculate number of columns based on available letters
    const keywordColumns = $derived.by(() => {
        const letterCount = letters.length;
        if (letterCount <= 3) return 1;
        if (letterCount <= 6) return 2;
        if (letterCount <= 12) return 3;
        return 4;
    });

    // Distribute letters across columns
    const lettersByColumn = $derived.by(() => {
        const cols = keywordColumns;
        const letterList = letters;
        const result: string[][] = Array.from({ length: cols }, () => []);
        letterList.forEach((letter: string, index: number) => {
            result[index % cols].push(letter);
        });
        return result;
    });

    // ===== DATE LOGIC =====
    // Extract all unique dates from videos
    const allDates = $derived.by(() => {
        const dateSet = new Set<string>();
        const videoList = videos;
        videoList.forEach((video) => {
            const dateStr = video.uploadDate || video.timestamp || video.uploadedAt;
            if (dateStr) {
                try {
                    const date = new Date(dateStr);
                    if (!isNaN(date.getTime())) {
                        // Format as YYYY-MM-DD
                        const year = date.getFullYear();
                        const month = String(date.getMonth() + 1).padStart(2, "0");
                        const day = String(date.getDate()).padStart(2, "0");
                        dateSet.add(`${year}-${month}-${day}`);
                    }
                } catch {
                    // Invalid date, skip
                }
            }
        });
        return Array.from(dateSet).sort().reverse(); // Most recent first
    });

    // Set of dates that have videos (for quick lookup)
    const datesWithVideos = $derived.by(() => {
        return new Set(allDates);
    });

    // Group dates by year > month > day
    const datesByYear = $derived.by(() => {
        const datesList = allDates;
        const grouped: Record<
            number,
            Record<number, Record<number, string>>
        > = {};

        datesList.forEach((dateStr: string) => {
            const [yearStr, monthStr, dayStr] = dateStr.split("-");
            const year = parseInt(yearStr, 10);
            const month = parseInt(monthStr, 10);
            const day = parseInt(dayStr, 10);

            if (!grouped[year]) grouped[year] = {};
            if (!grouped[year][month]) grouped[year][month] = {};
            grouped[year][month][day] = dateStr;
        });

        return grouped;
    });

    // Get sorted years
    const years = $derived.by(() => {
        return Object.keys(datesByYear)
            .map(Number)
            .sort((a, b) => b - a); // Most recent first
    });

    // Current year being viewed (initialize to current year, will be set properly when years are available)
    let currentYear = $state<number>(new Date().getFullYear());
    
    // Update currentYear to the most recent year with videos when available
    $effect(() => {
        if (years.length > 0 && !years.includes(currentYear)) {
            currentYear = years[0];
        }
    });

    // Check if a date has videos
    function hasVideos(year: number, month: number, day: number): boolean {
        const dateStr = getDateStr(year, month, day);
        return datesWithVideos.has(dateStr);
    }

    // Get calendar days for a month (returns array of day numbers, with null for days outside the month)
    function getCalendarDays(year: number, month: number): (number | null)[] {
        const firstDay = new Date(year, month - 1, 1);
        const lastDay = new Date(year, month, 0);
        const daysInMonth = lastDay.getDate();
        const startingDayOfWeek = firstDay.getDay(); // 0 = Sunday, 1 = Monday, etc.

        const days: (number | null)[] = [];

        // Add empty cells for days before the first day of the month
        for (let i = 0; i < startingDayOfWeek; i++) {
            days.push(null);
        }

        // Add all days of the month
        for (let day = 1; day <= daysInMonth; day++) {
            days.push(day);
        }

        return days;
    }


    // Get date string for year/month/day
    function getDateStr(year: number, month: number, day: number): string {
        return `${year}-${String(month).padStart(2, "0")}-${String(day).padStart(2, "0")}`;
    }

    // Format date for display
    function formatDate(year: number, month: number, day: number): string {
        const dayStr = String(day).padStart(2, "0");
        const monthStr = String(month).padStart(2, "0");
        return `${dayStr}/${monthStr}/${year}`;
    }

    function formatMonth(month: number): string {
        const monthNames = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ];
        return monthNames[month - 1] || String(month);
    }

    // Get months that have videos for the current year
    const monthsWithVideos = $derived.by(() => {
        const year = currentYear;
        const yearData = datesByYear[year];
        if (!yearData) return [];
        
        return Object.keys(yearData)
            .map(Number)
            .sort((a, b) => a - b); // Sort chronologically
    });


    // ===== USERS LOGIC =====
    // Get all users sorted alphabetically
    const allUsers = $derived.by(() => {
        const userList = users;
        return [...userList].sort((a, b) => a.name.localeCompare(b.name));
    });

    // Group users by first letter
    const usersByLetter = $derived.by(() => {
        const grouped: Record<string, Array<(typeof users)[number]>> = {};
        const userList = allUsers;
        userList.forEach((user) => {
            const firstLetter = user.name.charAt(0).toUpperCase();
            if (!/[A-Z]/.test(firstLetter)) {
                // If not a letter, group under "#"
                if (!grouped["#"]) grouped["#"] = [];
                grouped["#"].push(user);
            } else {
                if (!grouped[firstLetter]) grouped[firstLetter] = [];
                grouped[firstLetter].push(user);
            }
        });
        return grouped;
    });

    // Get all letters that have users
    const userLetters = $derived.by(() => {
        const grouped = usersByLetter;
        const allLetters = Object.keys(grouped).sort();
        // Put # at the end
        const hashIndex = allLetters.indexOf("#");
        if (hashIndex > -1) {
            allLetters.splice(hashIndex, 1);
            allLetters.push("#");
        }
        return allLetters;
    });

    // Calculate number of columns based on available letters
    const userColumns = $derived.by(() => {
        const letterCount = userLetters.length;
        if (letterCount <= 3) return 1;
        if (letterCount <= 6) return 2;
        if (letterCount <= 12) return 3;
        return 4;
    });

    // Distribute letters across columns
    const userLettersByColumn = $derived.by(() => {
        const cols = userColumns;
        const letterList = userLetters;
        const result: string[][] = Array.from({ length: cols }, () => []);
        letterList.forEach((letter: string, index: number) => {
            result[index % cols].push(letter);
        });
        return result;
    });

    // ===== SEARCH LOGIC =====
    // Natural language search across multiple fields
    const searchResults = $derived.by(() => {
        const query = searchQuery.trim().toLowerCase();
        if (!query) return [];

        const videoList = videos;
        const queryTerms = query.split(/\s+/).filter((term) => term.length > 0);

        return videoList.filter((video) => {
            // Search in title
            const titleMatch = video.title.toLowerCase().includes(query) ||
                queryTerms.every((term) => video.title.toLowerCase().includes(term));

            // Search in description
            const descMatch = video.description?.toLowerCase().includes(query) ||
                (video.description && queryTerms.every((term) => video.description.toLowerCase().includes(term))) ||
                false;

            // Search in keywords
            const keywordMatch = video.keywords?.some((keyword) =>
                keyword.toLowerCase().includes(query) ||
                queryTerms.some((term) => keyword.toLowerCase().includes(term))
            ) || false;

            // Search in author
            const authorMatch = video.author?.toLowerCase().includes(query) ||
                (video.author && queryTerms.every((term) => video.author.toLowerCase().includes(term))) ||
                false;

            // Search in transcript
            const transcriptMatch = video.transcript?.toLowerCase().includes(query) ||
                (video.transcript && queryTerms.some((term) => video.transcript?.toLowerCase().includes(term))) ||
                false;

            return titleMatch || descMatch || keywordMatch || authorMatch || transcriptMatch;
        });
    });

    // Sort search results by relevance (title matches first, then other fields)
    const sortedSearchResults = $derived.by(() => {
        const query = searchQuery.trim().toLowerCase();
        if (!query) return [];
        const results = searchResults;

        return [...results].sort((a, b) => {
            const aTitleMatch = a.title.toLowerCase().includes(query);
            const bTitleMatch = b.title.toLowerCase().includes(query);

            // Prioritize title matches
            if (aTitleMatch && !bTitleMatch) return -1;
            if (!aTitleMatch && bTitleMatch) return 1;

            // Then by date (most recent first)
            const aDate = a.uploadDate || a.timestamp || a.uploadedAt;
            const bDate = b.uploadDate || b.timestamp || b.uploadedAt;
            if (aDate && bDate) {
                return new Date(bDate).getTime() - new Date(aDate).getTime();
            }
            return 0;
        });
    });
</script>

<div class="min-h-screen p-8">
    <div class="max-w-7xl mx-auto">
        <header class="mb-8">
            <h1 class="text-3xl font-bold text-white mb-4">
                {activeTab === "keywords"
                    ? "Keywords"
                    : activeTab === "date"
                      ? "Dates"
                      : activeTab === "users"
                        ? "Users"
                        : "Search"}
            </h1>

            <!-- Tab Switcher -->
            <div class="flex gap-2 border-b border-white/10 mb-6">
                <button
                    onclick={() => (activeTab = "keywords")}
                    class="px-4 py-2 text-sm font-medium transition-colors border-b-2 {activeTab ===
                    "keywords"
                        ? "border-white text-white"
                        : "border-transparent text-white/60 hover:text-white"} "
                >
                    Keywords
                </button>
                <button
                    onclick={() => (activeTab = "date")}
                    class="px-4 py-2 text-sm font-medium transition-colors border-b-2 {activeTab ===
                    "date"
                        ? "border-white text-white"
                        : "border-transparent text-white/60 hover:text-white"} "
                >
                    Dates
                </button>
                <button
                    onclick={() => (activeTab = "users")}
                    class="px-4 py-2 text-sm font-medium transition-colors border-b-2 {activeTab ===
                    "users"
                        ? "border-white text-white"
                        : "border-transparent text-white/60 hover:text-white"} "
                >
                    Users
                </button>
                <button
                    onclick={() => (activeTab = "search")}
                    class="px-4 py-2 text-sm font-medium transition-colors border-b-2 {activeTab ===
                    "search"
                        ? "border-white text-white"
                        : "border-transparent text-white/60 hover:text-white"} "
                >
                    Search
                </button>
            </div>

            <p class="text-white/60 text-sm">
                {activeTab === "keywords"
                    ? "Browse all keywords organized alphabetically"
                    : activeTab === "date"
                      ? "Browse videos organized by year, month, and day"
                      : activeTab === "users"
                        ? "Browse all users organized alphabetically"
                        : "Search videos by title, description, keywords, author, or transcript"}
            </p>
        </header>

        {#if activeTab === "keywords"}
            {#if allKeywords.length > 0}
                <div
                    class="grid gap-8 mt-8"
                    style="grid-template-columns: repeat({keywordColumns}, 1fr);"
                >
                    {#each lettersByColumn as columnLetters}
                        <div class="space-y-6">
                            {#each columnLetters as letter}
                                {@const keywordList = keywordsByLetter[letter] || []}
                                <section>
                                    <h2
                                        class="text-xl font-semibold text-white/90 mb-3 pb-2 border-b border-white/10"
                                    >
                                        {letter === "#" ? "Symbols" : letter}
                                    </h2>
                                    <ul class="space-y-1">
                                        {#each keywordList as keyword}
                                            <li>
                                                <a
                                                    href="/browse/{keywordToSlug(keyword)}"
                                                    class="block py-1.5 px-2 text-sm text-white/70 hover:text-white hover:bg-white/5 rounded transition-colors"
                                                >
                                                    {keyword}
                                                </a>
                                            </li>
                                        {/each}
                                    </ul>
                                </section>
                            {/each}
                        </div>
                    {/each}
                </div>
            {:else}
                <div
                    class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                >
                    <p class="text-white/60">No keywords available yet.</p>
                </div>
            {/if}
        {:else if activeTab === "date"}
            <!-- Calendar View -->
            <div class="mt-8">
                <!-- Year Navigation Header -->
                <div class="flex items-center gap-3 mb-6 pb-2 border-b border-white/10">
                    <button
                        onclick={() => currentYear--}
                        class="p-1 hover:bg-white/10 transition-colors rounded"
                        aria-label="Previous year"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="16"
                            height="16"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                            class="text-white/70 hover:text-white"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M15 19l-7-7 7-7"
                            />
                        </svg>
                    </button>
                    <h2 class="text-xl font-semibold text-white/90">
                        {currentYear}
                    </h2>
                    <button
                        onclick={() => currentYear++}
                        class="p-1 hover:bg-white/10 transition-colors rounded"
                        aria-label="Next year"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="16"
                            height="16"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                            class="text-white/70 hover:text-white"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M9 5l7 7-7 7"
                            />
                        </svg>
                    </button>
                </div>

                <!-- Calendar Grid -->
                {#if monthsWithVideos.length > 0}
                    <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
                        {#each monthsWithVideos as month}
                            {@const monthName = formatMonth(month)}
                            {@const calendarDays = getCalendarDays(currentYear, month)}
                            {@const monthSlug = `${currentYear}-${String(month).padStart(2, "0")}`}
                            {@const monthIndex = monthsWithVideos.indexOf(month)}
                            {@const totalMonths = monthsWithVideos.length}
                            {@const isLastItem = monthIndex === totalMonths - 1}
                            {@const showBorderMd = !isLastItem && (monthIndex + 1) % 2 !== 0}
                            {@const showBorderLg = !isLastItem && (monthIndex + 1) % 3 !== 0}
                            {@const showBorderXl = !isLastItem && (monthIndex + 1) % 4 !== 0}
                            <div class="p-4 {showBorderMd ? 'md:border-r' : ''} {showBorderLg ? 'lg:border-r' : ''} {showBorderXl ? 'xl:border-r' : ''} border-white/10">
                            <h3 class="text-lg font-semibold text-white/90 mb-3 pb-2 border-b border-white/10">
                                <a
                                    href="/date/{monthSlug}"
                                    class="hover:text-white transition-colors"
                                >
                                    {monthName}
                                </a>
                            </h3>
                            
                            <!-- Calendar Header (Day names) -->
                            <div class="grid grid-cols-7 gap-1 mb-2">
                                {#each ["S", "M", "T", "W", "T", "F", "S"] as dayName}
                                    <div class="text-xs text-center text-white/50 font-medium py-1">
                                        {dayName}
                                    </div>
                                {/each}
                            </div>

                            <!-- Calendar Days Grid -->
                            <div class="grid grid-cols-7 gap-1">
                                {#each calendarDays as day}
                                    {#if day === null}
                                        <div class="aspect-square"></div>
                                    {:else}
                                        {@const dateStr = getDateStr(currentYear, month, day)}
                                        {@const hasVideo = hasVideos(currentYear, month, day)}
                                        <a
                                            href="/date/{dateStr}"
                                            class="aspect-square flex items-center justify-center text-sm transition-colors {hasVideo
                                                ? "bg-orange-500/20 text-orange-400 border border-orange-500/40 hover:bg-orange-500/30"
                                                : "text-white/40 hover:text-white/60 hover:bg-white/5"} "
                                            title={hasVideo ? `Videos available on ${formatDate(currentYear, month, day)}` : formatDate(currentYear, month, day)}
                                        >
                                            {day}
                                        </a>
                                    {/if}
                                {/each}
                            </div>
                        </div>
                    {/each}
                </div>
                {:else}
                    <div
                        class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                    >
                        <p class="text-white/60">No videos available for {currentYear}.</p>
                    </div>
                {/if}
            </div>
        {:else if activeTab === "users"}
            <!-- Users View -->
            {#if allUsers.length > 0}
                <div
                    class="grid gap-8 mt-8"
                    style="grid-template-columns: repeat({userColumns}, 1fr);"
                >
                    {#each userLettersByColumn as columnLetters}
                        <div class="space-y-6">
                            {#each columnLetters as letter}
                                {@const userList = usersByLetter[letter] || []}
                                <section>
                                    <h2
                                        class="text-xl font-semibold text-white/90 mb-3 pb-2 border-b border-white/10"
                                    >
                                        {letter === "#" ? "Symbols" : letter}
                                    </h2>
                                    <ul class="space-y-1">
                                        {#each userList as user}
                                            <li>
                                                <a
                                                    href="/users/{user.id}"
                                                    class="block py-1.5 px-2 text-sm text-white/70 hover:text-white hover:bg-white/5 rounded transition-colors flex items-center gap-2"
                                                >
                                                    {#if user.avatar}
                                                        <img
                                                            src={user.avatar}
                                                            alt={user.name}
                                                            class="w-6 h-6 rounded-full object-cover"
                                                        />
                                                    {/if}
                                                    <span>{user.name}</span>
                                                </a>
                                            </li>
                                        {/each}
                                    </ul>
                                </section>
                            {/each}
                        </div>
                    {/each}
                </div>
            {:else}
                <div
                    class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                >
                    <p class="text-white/60">No users available yet.</p>
                </div>
            {/if}
        {:else if activeTab === "search"}
            <!-- Search View -->
            <div class="mt-8">
                <!-- Search Input -->
                <div class="mb-8">
                    <div class="relative">
                        <input
                            type="text"
                            bind:value={searchQuery}
                            placeholder="Search videos by title, description, keywords, author, or transcript..."
                            class="w-full px-4 py-3 pl-12 bg-white/5 border border-white/10 rounded-lg text-white placeholder-white/40 focus:outline-none focus:ring-2 focus:ring-white/20 focus:border-white/30 transition-all"
                            autofocus
                        />
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="20"
                            height="20"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                            class="absolute left-4 top-1/2 -translate-y-1/2 text-white/40"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"
                            />
                        </svg>
                        {#if searchQuery}
                            <button
                                onclick={() => (searchQuery = "")}
                                class="absolute right-4 top-1/2 -translate-y-1/2 text-white/40 hover:text-white transition-colors"
                                aria-label="Clear search"
                            >
                                <svg
                                    xmlns="http://www.w3.org/2000/svg"
                                    width="20"
                                    height="20"
                                    fill="none"
                                    stroke="currentColor"
                                    viewBox="0 0 24 24"
                                >
                                    <path
                                        stroke-linecap="round"
                                        stroke-linejoin="round"
                                        stroke-width="2"
                                        d="M6 18L18 6M6 6l12 12"
                                    />
                                </svg>
                            </button>
                        {/if}
                    </div>
                </div>

                <!-- Search Results -->
                {#if searchQuery.trim()}
                    {#if sortedSearchResults.length > 0}
                        <div class="mb-4 text-sm text-white/60">
                            Found {sortedSearchResults.length} result{sortedSearchResults.length === 1
                                ? ""
                                : "s"} for "{searchQuery}"
                        </div>
                        <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
                            {#each sortedSearchResults as video (video.id)}
                                {@const vid = video}
                                <a
                                    href={`/videos/${vid.id}`}
                                    onclick={(e) => {
                                        e.preventDefault();
                                        selectedVideo.selectVideo(vid.id);
                                    }}
                                    class="block"
                                >
                                    <div
                                        class="group relative aspect-video overflow-hidden rounded-lg bg-neutral-900 cursor-pointer"
                                    >
                                        <img
                                            src={vid.thumbnailUrl ??
                                                "https://placehold.co/400x225?text=Video"}
                                            alt={vid.title}
                                            class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                                            loading="lazy"
                                        />
                                        <div
                                            class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100"
                                        >
                                            <div class="absolute bottom-0 left-0 right-0 p-4">
                                                <h3
                                                    class="text-sm font-medium text-white truncate mb-1"
                                                >
                                                    {vid.title}
                                                </h3>
                                                <p class="text-xs text-neutral-300 mb-1">
                                                    {vid.author}
                                                </p>
                                                {#if vid.description}
                                                    <p
                                                        class="text-xs text-neutral-400 line-clamp-2 mt-1"
                                                    >
                                                        {vid.description}
                                                    </p>
                                                {/if}
                                            </div>
                                        </div>
                                    </div>
                                </a>
                            {/each}
                        </div>
                    {:else}
                        <div
                            class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                        >
                            <p class="text-white/60 mb-2">
                                No videos found for "{searchQuery}"
                            </p>
                            <p class="text-sm text-white/40">
                                Try searching with different keywords or terms
                            </p>
                        </div>
                    {/if}
                {:else}
                    <div
                        class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                    >
                        <p class="text-white/60 mb-2">
                            Enter a search query to find videos
                        </p>
                        <p class="text-sm text-white/40">
                            Search across titles, descriptions, keywords, authors, and transcripts
                        </p>
                    </div>
                {/if}
            </div>
        {/if}
    </div>
</div>
</file>

<file path="src/routes/date/[slug]/+page.svelte">
<script lang="ts">
    import { page } from "$app/stores";
    import { browser } from "$app/environment";
    import { videosStore } from "$lib/stores/library";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import type { QueueContext } from "$lib/stores/selectedVideo";
    import { trackDirectLoad } from "$lib/utils/direct-load";

    const videos = $derived($videosStore);
    const slug = $derived($page.params.slug);

    // Parse the date slug - handles YYYY, YYYY-MM, or YYYY-MM-DD format
    const parsedDate = $derived.by(() => {
        const dateStr = slug;
        if (!dateStr) return null;

        // Try YYYY-MM-DD format (day)
        const dayMatch = dateStr.match(/^(\d{4})-(\d{2})-(\d{2})$/);
        if (dayMatch) {
            const [, yearStr, monthStr, dayStr] = dayMatch;
            const year = parseInt(yearStr, 10);
            const month = parseInt(monthStr, 10);
            const day = parseInt(dayStr, 10);

            // Validate date
            const date = new Date(year, month - 1, day);
            if (
                date.getFullYear() === year &&
                date.getMonth() === month - 1 &&
                date.getDate() === day
            ) {
                return { type: "day" as const, year, month, day };
            }
            return null;
        }

        // Try YYYY-MM format (month)
        const monthMatch = dateStr.match(/^(\d{4})-(\d{2})$/);
        if (monthMatch) {
            const [, yearStr, monthStr] = monthMatch;
            const year = parseInt(yearStr, 10);
            const month = parseInt(monthStr, 10);

            // Validate month (1-12)
            if (month >= 1 && month <= 12) {
                return { type: "month" as const, year, month };
            }
            return null;
        }

        // Try YYYY format (year)
        const yearMatch = dateStr.match(/^(\d{4})$/);
        if (yearMatch) {
            const [, yearStr] = yearMatch;
            const year = parseInt(yearStr, 10);
            // Validate year (reasonable range)
            if (year >= 1900 && year <= 2100) {
                return { type: "year" as const, year };
            }
            return null;
        }

        return null;
    });

    // Get videos based on the date type
    const filteredVideos = $derived.by(() => {
        const date = parsedDate;
        if (!date) return [];

        const videoList = videos;
        return videoList.filter((video) => {
            const videoDateStr = video.uploadDate || video.timestamp || video.uploadedAt;
            if (!videoDateStr) return false;

            try {
                const videoDate = new Date(videoDateStr);
                if (isNaN(videoDate.getTime())) return false;

                const videoYear = videoDate.getFullYear();
                const videoMonth = videoDate.getMonth() + 1;
                const videoDay = videoDate.getDate();

                if (date.type === "day") {
                    return (
                        videoYear === date.year &&
                        videoMonth === date.month &&
                        videoDay === date.day
                    );
                } else if (date.type === "month") {
                    return videoYear === date.year && videoMonth === date.month;
                } else if (date.type === "year") {
                    return videoYear === date.year;
                }
                return false;
            } catch {
                return false;
            }
        });
    });

    // Format date for display
    function formatDay(year: number, month: number, day: number): string {
        const monthNames = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ];
        return `${monthNames[month - 1]} ${day}, ${year}`;
    }

    function formatMonth(year: number, month: number): string {
        const monthNames = [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ];
        return `${monthNames[month - 1]} ${year}`;
    }

    function getDateTitle(): string {
        const date = parsedDate;
        if (!date) return "Invalid Date";
        if (date.type === "day") {
            return formatDay(date.year, date.month, date.day);
        } else if (date.type === "month") {
            return formatMonth(date.year, date.month);
        } else if (date.type === "year") {
            return String(date.year);
        }
        return "Invalid Date";
    }

    function getDateDescription(): string {
        const date = parsedDate;
        if (!date) return "";
        const count = filteredVideos.length;
        if (date.type === "day") {
            return `${count} video${count === 1 ? "" : "s"} from this day`;
        } else if (date.type === "month") {
            return `${count} video${count === 1 ? "" : "s"} from this month`;
        } else if (date.type === "year") {
            return `${count} video${count === 1 ? "" : "s"} from this year`;
        }
        return "";
    }

    function handlePlayAll() {
        if (filteredVideos.length === 0) return;
        const videoIds = filteredVideos.map((v) => v.id);
        const context: QueueContext = {
            type: "date",
            label: getDateTitle(),
            videoIds
        };
        selectedVideo.setTemporaryQueue(videoIds, context);
    }

    // Track if auto-play has been triggered (prevent duplicate triggers)
    let autoPlayTriggered = $state(false);
    let wasDirectLoad = $state(false);

    trackDirectLoad((value) => {
        wasDirectLoad = value;
    });
    
    // Auto-play on direct page load (not internal navigation)
    // Use $effect to ensure stores are ready
    $effect(() => {
        if (!browser) return;
        if (autoPlayTriggered) return;
        if (!wasDirectLoad) return; // Only for direct loads
        
        const videos = filteredVideos;
        const hasQueueContext = !!$selectedVideo.queueContext;
        
        // Wait for videos to be loaded and stores initialized
        if (videos.length === 0) return;
        
        // Only auto-play if:
        // 1. No queue context (not interrupting playback)
        // 2. We have videos
        // 3. This was a direct load
        if (!hasQueueContext && videos.length > 0) {
            autoPlayTriggered = true;
            
            // Small delay to ensure everything is ready
            setTimeout(() => {
                if (filteredVideos.length > 0) {
                    handlePlayAll();
                }
            }, 300);
        }
    });
</script>

<div class="min-h-screen p-8">
    <div class="max-w-7xl mx-auto">
        {#if parsedDate}
            <header class="mb-8">
                <div class="flex items-center gap-3 mb-2">
                    <a
                        href="/browse"
                        class="text-white/60 hover:text-white text-sm transition-colors"
                    >
                        ← Back to Browse
                    </a>
                </div>
                <div class="flex items-center justify-between mb-2">
                    <div>
                        <h1 class="text-3xl font-bold text-white mb-2">
                            {getDateTitle()}
                        </h1>
                        <p class="text-white/60 text-sm">
                            {getDateDescription()}
                        </p>
                    </div>
                    {#if filteredVideos.length > 0}
                        <button
                            onclick={handlePlayAll}
                            class="px-4 py-2 bg-orange-500/20 text-orange-400 border border-orange-500/40 rounded-lg hover:bg-orange-500/30 transition-colors font-medium text-sm flex items-center gap-2"
                        >
                            <svg
                                xmlns="http://www.w3.org/2000/svg"
                                width="18"
                                height="18"
                                fill="none"
                                stroke="currentColor"
                                viewBox="0 0 24 24"
                            >
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="2"
                                    d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
                                />
                                <path
                                    stroke-linecap="round"
                                    stroke-linejoin="round"
                                    stroke-width="2"
                                    d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                                />
                            </svg>
                            Play All
                        </button>
                    {/if}
                </div>
            </header>

            {#if filteredVideos.length > 0}
                <div class="grid gap-4 sm:grid-cols-2 lg:grid-cols-3 xl:grid-cols-4">
                    {#each filteredVideos as video (video.id)}
                        {@const vid = video}
                        <a
                            href={`/videos/${vid.id}`}
                            onclick={(e) => {
                                e.preventDefault();
                                selectedVideo.selectVideo(vid.id);
                            }}
                            class="block"
                        >
                            <div
                                class="group relative aspect-video overflow-hidden rounded-lg bg-neutral-900 cursor-pointer"
                            >
                                <img
                                    src={vid.thumbnailUrl ??
                                        "https://placehold.co/400x225?text=Video"}
                                    alt={vid.title}
                                    class="h-full w-full object-cover transition-transform duration-300 group-hover:scale-105"
                                    loading="lazy"
                                />
                                <div
                                    class="absolute inset-0 bg-gradient-to-t from-black/80 via-black/20 to-transparent opacity-0 transition-opacity duration-300 group-hover:opacity-100"
                                >
                                    <div class="absolute bottom-0 left-0 right-0 p-4">
                                        <h3
                                            class="text-sm font-medium text-white truncate"
                                        >
                                            {vid.title}
                                        </h3>
                                        <p class="text-xs text-neutral-300">
                                            {vid.author}
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </a>
                    {/each}
                </div>
            {:else}
                <div
                    class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                >
                    <p class="text-white/60">
                        No videos found for this {parsedDate?.type || "period"}.
                    </p>
                </div>
            {/if}
        {:else}
            <div class="max-w-7xl mx-auto">
                <header class="mb-8">
                    <a
                        href="/browse"
                        class="text-white/60 hover:text-white text-sm transition-colors"
                    >
                        ← Back to Browse
                    </a>
                    <h1 class="text-3xl font-bold text-white mb-2 mt-4">
                        Invalid Date
                    </h1>
                </header>
                <div
                    class="rounded-lg border border-white/10 bg-white/5 p-12 text-center"
                >
                    <p class="text-white/60">
                        The date you're looking for is invalid.
                    </p>
                </div>
            </div>
        {/if}
    </div>
</div>
</file>

<file path="src/routes/live/+page.svelte">
<script lang="ts">
    import { onMount } from "svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";

    onMount(() => {
        // Ensure the player transitions into fullscreen layout
        selectedVideo.setFullScreen(true);
    });
</script>

<section class="live-wrapper">
    <div class="live-card">
        <span class="live-indicator">EN DIRECT</span>
        <h1>Flux en direct</h1>
        <p>
            La lecture principale occupe désormais tout l'écran. Sélectionnez un
            clip ou laissez la file s'enchaîner automatiquement pour alimenter
            le direct.
        </p>
    </div>
</section>

<style>
    .live-wrapper {
        min-height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        padding: 4rem 1.5rem;
        background: black;
    }

    .live-card {
        max-width: 560px;
        display: grid;
        gap: 1.25rem;
        padding: 2.5rem;
        border-radius: 1.5rem;
        border: 1px solid rgba(148, 163, 184, 0.25);
        background: rgba(15, 23, 42, 0.65);
        box-shadow: 0 40px 120px -60px rgba(30, 64, 175, 0.6);
        text-align: center;
        color: #e2e8f0;
    }

    .live-indicator {
        justify-self: center;
        padding: 0.4rem 1rem;
        border-radius: 999px;
        background: linear-gradient(135deg, #ef4444, #f97316);
        color: #0f172a;
        font-size: 0.75rem;
        font-weight: 600;
        letter-spacing: 0.3em;
    }

    h1 {
        margin: 0;
        font-size: 2rem;
        font-weight: 600;
        letter-spacing: 0.1em;
        text-transform: uppercase;
    }

    p {
        margin: 0;
        font-size: 0.95rem;
        line-height: 1.6;
        color: rgba(226, 232, 240, 0.82);
    }

    @media (max-width: 640px) {
        .live-wrapper {
            padding: 2.5rem 1rem;
        }

        .live-card {
            padding: 2rem;
        }

        h1 {
            font-size: 1.6rem;
        }
    }
</style>
</file>

<file path="src/routes/map/+page.svelte">
<script lang="ts">
  import Map from '$lib/components/Map.svelte';
  import { page } from '$app/stores';
  import { videosStore } from '$lib/stores/library';
  import { selectedVideo } from '$lib/stores/selectedVideo';

  const videos = $derived($videosStore);

  const locations = $derived(
    videos.flatMap((video) =>
      video.locations?.map((loc) => ({
        ...loc,
        videoId: video.id,
        videoTitle: video.title,
        videoAuthor: video.author
      })) ?? []
    )
  );

  const lat = $derived(parseFloat($page.url.searchParams.get('lat') ?? '20'));
  const lon = $derived(parseFloat($page.url.searchParams.get('lon') ?? '0'));
  const zoom = $derived(parseInt($page.url.searchParams.get('zoom') ?? '2', 10));

  const filteredLocations = $derived(
    lat && lon
      ? locations.filter(
          (loc) =>
            Array.isArray(loc.coordinates) &&
            Math.abs(loc.coordinates[0] - lat) < 0.1 &&
            Math.abs(loc.coordinates[1] - lon) < 0.1
        )
      : locations
  );

  const activeVideoId = $derived($selectedVideo.id);

  // Toolbar UI state (visual only)
  let searchValue = $state('');
</script>


  <div class="relative w-full h-full w-full overflow-hidden">
 
      <Map
        locations={filteredLocations}
        initialCenterLon={lon}
        initialCenterLat={lat}
        initialZoom={zoom}
        activeVideoId={activeVideoId}
      />

      <aside class="map-toolbar" aria-label="Map tools">
        <div class="toolbar-row">
          <label class="sr-only" for="map-search">Search map</label>
          <div class="toolbar-item search">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="11" cy="11" r="7" />
                <line x1="20" y1="20" x2="16.65" y2="16.65" />
              </svg>
            </span>
            <input
              id="map-search"
              class="toolbar-input"
              type="search"
              placeholder="Search map"
              bind:value={searchValue}
            />
          </div>

          <button type="button" class="toolbar-item" aria-label="Filters">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="M4 6h16" />
                <path d="M7 12h10" />
                <path d="M10 18h4" />
              </svg>
            </span>
          </button>

          <button type="button" class="toolbar-item" aria-label="Timeline">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <circle cx="12" cy="12" r="10" />
                <polyline points="12 6 12 12 16 14" />
              </svg>
            </span>
          </button>

          <button type="button" class="toolbar-item" aria-label="Keywords">
            <span class="toolbar-icon" aria-hidden="true">
              <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
                <path d="m3 7 5 5-5 5" />
                <path d="m13 7 5 5-5 5" />
              </svg>
            </span>
          </button>
        </div>
      </aside>


    <!-- Mobile Menu Overlay Button -->
    <!-- <div class="pointer-events-none absolute top-4 left-4 md:hidden">
      <button
        class="pointer-events-auto rounded-lg bg-white/90 dark:bg-gray-800/90 p-2 shadow-lg border border-gray-200 dark:border-gray-700 backdrop-blur"
        aria-label="Open navigation menu"
        onclick={() => {
          const event = new CustomEvent('toggle-sidebar');
          window.dispatchEvent(event);
        }}
      >
        <svg class="h-5 w-5 text-gray-600 dark:text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
        </svg>
      </button>
    </div> -->

    <!-- Map Controls -->
    <!-- <div class="pointer-events-none absolute top-4 right-4 flex flex-col gap-2">
      <div class="pointer-events-auto rounded-lg bg-white/90 dark:bg-gray-900/90 p-3 shadow-lg border border-gray-200 dark:border-gray-700 backdrop-blur">
        <div class="text-sm font-medium text-gray-900 dark:text-white">
          {filteredLocations.length} locations
        </div>
        <div class="text-xs text-gray-500 dark:text-gray-400">
          {videos.length} videos archived
        </div>
      </div>

      <a
        href="/videos"
        class="pointer-events-auto rounded-lg bg-blue-600 px-3 py-2 text-sm font-medium text-white hover:bg-blue-500 transition-colors shadow-lg"
      >
        Browse Videos
      </a>
    </div> -->

</div>

<style>
  :global(body) {
    font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
  }

  .map-page {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .map-toolbar {
    position: absolute;
    top: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    width: min(960px, calc(100% - 3rem));
    padding: 0.85rem 1rem;
    border-radius: 18px;
    background: rgba(15, 18, 24, 0.78);
    backdrop-filter: blur(18px);
    border: 1px solid rgba(255, 255, 255, 0.14);
    box-shadow:
      0 24px 70px -35px rgba(15, 23, 42, 0.6),
      inset 0 0 0 0.5px rgba(255, 255, 255, 0.12);
    color: #e9eef6;
    z-index: 20;
    pointer-events: auto;
  }

  .toolbar-row {
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .toolbar-item {
    display: inline-flex;
    align-items: center;
    gap: 0.55rem;
    padding: 0.5rem 0.7rem;
    border-radius: 12px;
    background: rgba(13, 17, 23, 0.45);
    border: 1px solid rgba(255, 255, 255, 0.08);
    min-height: 42px;
    color: inherit;
    transition: border-color 0.2s ease, background 0.2s ease;
  }

  .toolbar-item:hover,
  .toolbar-item:focus-visible {
    border-color: rgba(255, 255, 255, 0.22);
    background: rgba(15, 18, 24, 0.6);
    outline: none;
  }

  .toolbar-item.search {
    flex: 1 1 260px;
  }

  .toolbar-icon {
    display: inline-flex;
    width: 18px;
    height: 18px;
    opacity: 0.85;
  }

  .toolbar-icon svg {
    width: 100%;
    height: 100%;
    stroke: currentColor;
  }

  .toolbar-input {
    flex: 1;
    min-width: 0;
    border: none;
    background: transparent;
    color: inherit;
    font-size: 0.92rem;
  }

  .toolbar-input::placeholder {
    color: rgba(233, 238, 246, 0.55);
  }

  .toolbar-input:focus {
    outline: none;
  }

  .sr-only {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    white-space: nowrap;
    border: 0;
  }

  @media (max-width: 720px) {
    .map-toolbar {
      top: 1rem;
      width: calc(100% - 2rem);
      padding: 0.75rem;
    }

    .toolbar-item {
      flex: 1 1 100%;
    }
  }
</style>
</file>

<file path="src/routes/users/[id]/+page.svelte">
<script lang="ts">
  import { getUserById as lookupUser, videosStore } from '$lib/stores/library';
  import { page } from '$app/stores';
  import { browser } from '$app/environment';
  import { selectedVideo } from "$lib/stores/selectedVideo";
  import type { QueueContext } from "$lib/stores/selectedVideo";
  import { trackDirectLoad } from '$lib/utils/direct-load';

  let { data } = $props();

  // Get user data from the centralized database
  const userId = $page.params.id ?? '';
  const user = lookupUser(userId) || {
    id: userId,
    name: "Unknown User",
    avatar: "https://i.pravatar.cc/150?img=4",
    bio: "User not found",
    stats: {
      videos: 0,
      followers: 0,
      following: 0
    },
    videos: [],
    recentVideos: []
  };

  // Get all videos from this user
  const userVideos = $derived.by(() => {
    const videos = $videosStore;
    return videos.filter((video) => video.authorId === userId);
  });

  function handlePlayAll() {
    if (userVideos.length === 0) return;
    const videoIds = userVideos.map((v) => v.id);
    const context: QueueContext = {
      type: "user",
      label: user.name,
      videoIds
    };
    selectedVideo.setTemporaryQueue(videoIds, context);
  }

  // Track if auto-play has been triggered (prevent duplicate triggers)
  let autoPlayTriggered = $state(false);
  let wasDirectLoad = $state(false);
  
  trackDirectLoad((value) => {
    wasDirectLoad = value;
  });
  
  // Auto-play on direct page load (not internal navigation)
  // Use $effect to ensure stores are ready
  $effect(() => {
    if (!browser) return;
    if (autoPlayTriggered) return;
    if (!wasDirectLoad) return; // Only for direct loads
    
    const videos = userVideos;
    const hasQueueContext = !!$selectedVideo.queueContext;
    
    // Wait for videos to be loaded and stores initialized
    if (videos.length === 0) return;
    
    // Only auto-play if:
    // 1. No queue context (not interrupting playback)
    // 2. We have videos
    // 3. This was a direct load
    if (!hasQueueContext && videos.length > 0) {
      autoPlayTriggered = true;
      
      // Small delay to ensure everything is ready
      setTimeout(() => {
        if (userVideos.length > 0) {
          handlePlayAll();
        }
      }, 300);
    }
  });
</script>

<div class=" ">
  <!-- Profile Header -->
  <div class="flex items-start gap-6 mb-8">
    <img 
      src={user.avatar} 
      alt={user.name} 
      class="w-24 h-24 rounded-full"
    />
    <div class="flex-1">
      <div class="flex items-center justify-between mb-2">
        <h1 class="text-2xl font-medium dark:text-neutral-200">{user.name}</h1>
        {#if userVideos.length > 0}
          <button
            onclick={handlePlayAll}
            class="px-4 py-2 bg-orange-500/20 text-orange-400 border border-orange-500/40 rounded-lg hover:bg-orange-500/30 transition-colors font-medium text-sm flex items-center gap-2"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              width="18"
              height="18"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"
              />
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
              />
            </svg>
            Play All
          </button>
        {/if}
      </div>
      <p class="text-sm text-neutral-600 dark:text-neutral-400 mb-4">{user.bio}</p>
      <div class="flex gap-6">
        <div>
          <span class="font-medium dark:text-neutral-200">{user.stats.videos}</span>
          <span class="text-sm text-neutral-600 dark:text-neutral-400 ml-1">videos</span>
        </div>
        <div>
          <span class="font-medium dark:text-neutral-200">{user.stats.followers}</span>
          <span class="text-sm text-neutral-600 dark:text-neutral-400 ml-1">followers</span>
        </div>
        <div>
          <span class="font-medium dark:text-neutral-200">{user.stats.following}</span>
          <span class="text-sm text-neutral-600 dark:text-neutral-400 ml-1">following</span>
        </div>
      </div>
    </div>
  </div>

  <!-- Recent Videos -->
  <h2 class="text-lg font-medium dark:text-neutral-200 mb-4">Recent Videos</h2>
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
    {#each user.recentVideos || [] as video}
      <a href="/videos/{video.id}" class="group">
        <div class="relative aspect-video rounded-lg overflow-hidden bg-white/10">
          <img
            src={video.thumbnail}
            alt={video.title}
            class="w-full h-full object-cover group-hover:scale-105 transition-transform duration-200"
          />
          <div class="absolute bottom-0 left-0 right-0 p-2 bg-gradient-to-t from-black/80 to-transparent">
            <p class="text-sm text-white">{video.title}</p>
            <p class="text-xs text-neutral-400">{video.duration}</p>
          </div>
        </div>
      </a>
    {/each}
  </div>
</div>
</file>

<file path="src/routes/users/+page.svelte">
<script lang="ts">
    import { browser } from "$app/environment";
    import { goto } from "$app/navigation";
    import { usersStore } from "$lib/stores/library";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { onMount } from "svelte";

    const users = $derived($usersStore);
    let container = $state<HTMLElement | null>(null);
    let gsapModule: any = null;

    onMount(() => {
        selectedVideo.selectVideo("home");
    });

    async function ensureGsap() {
        if (!browser) return null;
        if (!gsapModule) {
            const { default: gsap } = await import("gsap");
            gsapModule = gsap;
        }
        return gsapModule;
    }

    $effect(() => {
        const host = container;
        if (!host) return;
        ensureGsap().then((gsap) => {
            if (!gsap) return;
            gsap.fromTo(
                host.querySelectorAll("[data-user-card]"),
                { opacity: 0, y: 18 },
                {
                    opacity: 1,
                    y: 0,
                    duration: 0.5,
                    stagger: 0.05,
                    ease: "power2.out",
                },
            );
        });
    });

    function openProfile(id: string) {
        goto(`/users/${id}`);
    }
</script>

<svelte:head>
    <title>Creators — Rushes Directory</title>
    <meta
        name="description"
        content="Browse the Rushes collective, discover filmmakers and dive into their rushes."
    />
</svelte:head>

<div class="mx-auto w-full max-w-[1200px] pb-24">
    <header class="flex flex-col gap-2 pb-8">
        <p class="text-xs uppercase tracking-[0.45em] text-slate-500">
            Directory
        </p>
        <h1
            class="text-3xl font-semibold text-white"
            style="font-family: 'Space Grotesk', 'Inter', sans-serif;"
        >
            Rushes collective
        </h1>
        <p class="max-w-xl text-sm text-slate-400">
            Meet the filmmakers weaving the Rushes archive. Select a profile to
            view their rushes, locations and shared notes.
        </p>
    </header>

    <div class="grid gap-6 md:grid-cols-2" bind:this={container}>
        {#each users as user (user.id)}
            <button
                class="group flex flex-col gap-4 rounded-4xl border border-white/10 bg-white/[0.04] p-6 text-left shadow-[0_45px_140px_-80px_rgba(12,18,38,0.92)] backdrop-blur-3xl transition-transform duration-300 hover:-translate-y-1 hover:shadow-[0_55px_160px_-90px_rgba(99,102,241,0.65)]"
                onclick={() => openProfile(user.id)}
                data-user-card
            >
                <div class="flex items-center gap-4">
                    <img
                        src={user.avatar}
                        alt={user.name}
                        class="h-16 w-16 rounded-3xl border border-white/10 object-cover"
                    />
                    <div>
                        <h2
                            class="text-xl font-semibold text-white"
                            style="font-family: 'Space Grotesk', 'Inter', sans-serif;"
                        >
                            {user.name}
                        </h2>
                        <p
                            class="mt-1 text-xs uppercase tracking-[0.35em] text-slate-500"
                        >
                            {user.stats.videos} rushes
                        </p>
                    </div>
                </div>
                <p class="text-sm text-slate-300">{user.bio}</p>
                <div
                    class="grid grid-cols-3 gap-3 rounded-3xl border border-white/10 bg-white/[0.03] p-4 text-center text-xs uppercase tracking-[0.3em] text-slate-400"
                >
                    <div>
                        <p class="text-[11px] text-slate-500">Followers</p>
                        <p class="mt-1 text-base text-white">
                            {user.stats.followers}
                        </p>
                    </div>
                    <div>
                        <p class="text-[11px] text-slate-500">Following</p>
                        <p class="mt-1 text-base text-white">
                            {user.stats.following}
                        </p>
                    </div>
                    <div>
                        <p class="text-[11px] text-slate-500">Videos</p>
                        <p class="mt-1 text-base text-white">
                            {user.stats.videos}
                        </p>
                    </div>
                </div>
            </button>
        {/each}
    </div>
</div>

<style>
    .rounded-4xl {
        border-radius: 2rem;
    }
</style>
</file>

<file path="src/routes/videos/[id]/+page.svelte">
<script lang="ts">
  import { page } from '$app/stores';
  import { selectedVideo } from '$lib/stores/selectedVideo';
  import { onMount } from 'svelte';

  onMount(() => {
    // Set the video based on the URL
    const videoId = $page.params.id;
    if (videoId) {
      // First select the video
      selectedVideo.selectVideo(videoId);
      // Then ensure it's in full screen mode
      if (!$selectedVideo.isFullScreen) {
        selectedVideo.toggleFullScreen();
      }
    }
  });
</script>

<div class=" bg-neutral-950">
  <!-- Video info will be shown in the Playing component -->
</div>
</file>

<file path="src/routes/videos/+page.svelte">
<script lang="ts">
	import { goto } from "$app/navigation";
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { slide } from "svelte/transition";
	import {
		dndzone,
		type DndEvent,
		SHADOW_ITEM_MARKER_PROPERTY_NAME,
	} from "svelte-dnd-action";
	import DashboardPanel from "$lib/components/dashboard/DashboardPanel.svelte";
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		SortDirection,
		TableColumn,
		TableKey,
		TableState,
	} from "$lib/types/dashboard";
import { videosStore, usersStore } from "$lib/stores/library";

	const boardDndType = "dashboard-panels";
	const boardDropTargetClasses = ["dashboard-drop-target"];
	const boardFlipDurationMs = 200;

	const videos = $derived($videosStore);
	const users = $derived($usersStore);

	// State for draggable items in each column
	let itemsLeft = $state<DashboardItem[]>([{ id: 1, component: "videos" }, { id: 2, component: "sounds" }]);

let itemsRight = $state<DashboardItem[]>([
	{ id: 5, component: "profile" },
	{ id: 6, component: "activity" },
	{ id: 7, component: "locations" },
	{ id: 3, component: "members" },
	{ id: 4, component: "keywords" },
]);

	const sectionLabels: Record<DashboardComponentKey, string> = {
		videos: "Queue overview",
		profile: "Profile summary",
		activity: "Live activity",
		sounds: "Sounds",
		members: "Members",
		keywords: "Keywords",
		locations: "Latest locations",
	};

	function getSectionLabel(item: DashboardItem) {
		return sectionLabels[item.component] ?? "Dashboard section";
	}

	function updateLeftColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsLeft = event.detail.items as DashboardItem[];
	}

	function updateRightColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsRight = event.detail.items as DashboardItem[];
	}

	const liveActivity = $state([
		{
			id: "act-1",
			user: "Inès Duarte",
			action: "liked",
			content: "Canal Footbridge Atmos",
			type: "like",
			time: "2m ago",
		},
		{
			id: "act-2",
			user: "Luca Van Eyck",
			action: "commented on",
			content: "Metro Brakes – Line 6",
			type: "comment",
			time: "5m ago",
		},
		{
			id: "act-3",
			user: "Aya Kakei",
			action: "liked",
			content: "Night Rain On Skylight",
			type: "like",
			time: "1h ago",
		},
		{
			id: "act-4",
			user: "Tom Schurr",
			action: "commented on",
			content: "Textile Rustle Layers",
			type: "comment",
			time: "3h ago",
		},
	]);

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	let collapsed = $state<Record<DashboardComponentKey, boolean>>({
		videos: false,
		profile: false,
		activity: false,
		sounds: false,
		members: false,
		keywords: false,
		locations: false,
	});

	function toggleCollapse(component: DashboardComponentKey) {
		collapsed[component] = !collapsed[component];
	}

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	const initialTableState: Record<TableKey, TableState> = {
		videos: {
			key: "videos",
			label: "Queue",
			sortKey: "uploaded",
			sortDirection: "desc",
			defaultSort: { key: "uploaded", direction: "desc" },
			columns: [] as TableColumn[],
		},
		sounds: {
			key: "sounds",
			label: "Sounds",
			sortKey: "captured",
			sortDirection: "desc",
			defaultSort: { key: "captured", direction: "desc" },
			columns: [
				{ key: "title", label: "CLIP" },
				{ key: "recordist", label: "CAPTURED_BY" },
				{ key: "captured", label: "CAPTURED", align: "right" },
				{ key: "duration", label: "DURATION", align: "right" },
			] as TableColumn[],
		},
		members: {
			key: "members",
			label: "MEMBERS",
			sortKey: "name",
			sortDirection: "asc",
			defaultSort: { key: "name", direction: "asc" },
			columns: [
				{ key: "name", label: "NAME" },
				{ key: "videos", label: "VIDEOS", align: "right" },
				{ key: "followers", label: "FOLLOWERS", align: "right" },
				{ key: "following", label: "FOLLOWING", align: "right" },
				{ key: "joined", label: "JOINED", align: "right" },
			] as TableColumn[],
		},
		keywords: {
			key: "keywords",
			label: "KEYWORDS",
			sortKey: "keyword",
			sortDirection: "asc",
			defaultSort: { key: "keyword", direction: "asc" },
			columns: [
				{ key: "keyword", label: "TERM" },
				{ key: "usage", label: "USAGE", align: "right" },
				{ key: "related", label: "RELATED_PROJECTS" },
			] as TableColumn[],
		},
	};

	let tableState = $state<Record<TableKey, TableState>>({
		...initialTableState,
	});

	function formatDate(iso?: string) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		return date.toISOString().split("T")[0];
	}

	function parseDuration(value?: string) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [h, m, s] = parts;
			return h * 3600 + m * 60 + s;
		}
		if (parts.length === 2) {
			const [m, s] = parts;
			return m * 60 + s;
		}
		return parts[0];
	}

	function formatViews(views?: number) {
		if (typeof views !== "number" || Number.isNaN(views)) return "—";
		if (views >= 1_000_000) return `${(views / 1_000_000).toFixed(1)}M`;
		if (views >= 1_000) return `${(views / 1_000).toFixed(1)}K`;
		return `${views}`;
	}

	function formatStat(num: number) {
		if (num >= 1000) return `${(num / 1000).toFixed(1)}k`;
		return num.toString();
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return 0;
	}

	function getLocationCoordinates(
		location: any,
	): { lat: number; lon: number } | null {
		if (
			typeof location?.mapLat === "number" &&
			typeof location?.mapLon === "number"
		) {
			return { lat: location.mapLat, lon: location.mapLon };
		}
		if (
			typeof location?.latitude === "number" &&
			typeof location?.longitude === "number"
		) {
			return { lat: location.latitude, lon: location.longitude };
		}
		if (
			Array.isArray(location?.coordinates) &&
			location.coordinates.length === 2
		) {
			const [lat, lon] = location.coordinates;
			if (typeof lat === "number" && typeof lon === "number") {
				return { lat, lon };
			}
		}
		return null;
	}

	function getKeywordsSummary() {
		const keywordMap = new Map<
			string,
			{ usage: number; related: Set<string> }
		>();
		for (const video of videos) {
			for (const key of video.keywords ?? []) {
				const entry = keywordMap.get(key) ?? {
					usage: 0,
					related: new Set<string>(),
				};
				entry.usage += 1;
				entry.related.add(video.title);
				keywordMap.set(key, entry);
			}
		}
		return Array.from(keywordMap.entries()).map(([keyword, info]) => ({
			keyword,
			usage: info.usage,
			related: Array.from(info.related).join(", "),
		}));
	}

	const tableData = $derived({
		videos: videos.map((video) => {
			const iso = video.timestamp ?? video.uploadDate ?? null;
			const uploadedLabel = iso
				? formatDate(iso)
				: (video.uploadedAt ?? "—");
			return {
				id: video.id,
				title: video.title,
				author: video.author,
				duration: video.duration ?? "0:00",
				durationValue: video.duration,
				uploaded: uploadedLabel,
				uploadedValue: iso ? Date.parse(iso) : Number.NEGATIVE_INFINITY,
				views: formatViews(video.views),
				viewsValue:
					typeof video.views === "number" ? video.views : null,
				original: video,
			};
		}),
		sounds: soundLibrary.map((clip) => ({
			id: clip.id,
			title: clip.title,
			location: clip.location,
			recordist: clip.recordist,
			project: clip.relatedProject,
			captured: formatDate(clip.capturedOn),
			capturedValue: Date.parse(clip.capturedOn),
			duration: clip.duration,
			durationValue: clip.duration,
		})),
		members: users.map((user) => ({
			id: user.id,
			name: user.name,
			videos: user.stats?.videos ?? 0,
			followers: user.stats?.followers ?? 0,
			following: user.stats?.following ?? 0,
			joined: user.joinedAt ? formatDate(user.joinedAt) : "—",
			joinedValue: user.joinedAt
				? Date.parse(user.joinedAt)
				: Number.NEGATIVE_INFINITY,
		})),
		keywords: getKeywordsSummary(),
	});

	const totalRuntimeSeconds = $derived(
		tableData.videos.reduce(
			(total, video) =>
				total +
				(typeof video.durationValue === "number"
					? video.durationValue
					: 0),
			0,
		),
	);
	const uniqueContributors = $derived(
		new Set(
			tableData.videos
				.map((video) => video.author)
				.filter((author) => Boolean(author)),
		).size,
	);
	const lastUploadedTimestamp = $derived(
		tableData.videos.reduce((latest, video) => {
			if (Number.isFinite(video.uploadedValue)) {
				return Math.max(latest, video.uploadedValue);
			}
			return latest;
		}, Number.NEGATIVE_INFINITY),
	);

	const lastUpdated = $derived(
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—",
	);
	const averageDurationLabel = $derived(() => {
		if (tableData.videos.length === 0) return "0m";
		const averageSeconds = Math.round(
			totalRuntimeSeconds / tableData.videos.length,
		);
		return formatRuntime(averageSeconds);
	});

	const latestLocations = $derived(
		((): LatestLocationPin[] => {
			const pins: LatestLocationPin[] = [];
			for (const video of videos) {
				const locations = video.locations ?? [];
				if (!Array.isArray(locations) || locations.length === 0) continue;
				const timestampValue = getVideoTimestampValue(video);
				const isoCandidate =
					typeof (video.timestamp ?? video.uploadDate) === "string"
						? (video.timestamp ?? video.uploadDate)
						: null;
				const uploadedLabel =
					isoCandidate && !Number.isNaN(Date.parse(isoCandidate))
						? formatDate(isoCandidate)
						: typeof video.uploadedAt === "string"
							? video.uploadedAt
							: "—";
				locations.forEach((location, index) => {
					const coords = getLocationCoordinates(location);
					if (!coords) return;
					pins.push({
						id: `${video.id}-${index}`,
						videoId: video.id,
						videoTitle: video.title,
						videoAuthor: video.author,
						uploadedLabel,
						timestampValue,
						lat: coords.lat,
						lon: coords.lon,
						setting: location.setting ?? location.name,
						thumbnailUrl: video.thumbnailUrl,
					});
				});
			}
			return pins
				.sort((a, b) => b.timestampValue - a.timestampValue)
				.slice(0, 6);
		})(),
	);

	const locationCenter = $derived(
		((): LocationCenter => {
			if (latestLocations.length === 0) {
				return { lat: 20, lon: 0, zoom: 1.6 };
			}
			const totals = latestLocations.reduce(
				(acc, loc) => {
					acc.lat += loc.lat;
					acc.lon += loc.lon;
					return acc;
				},
				{ lat: 0, lon: 0 },
			);
			const lat = totals.lat / latestLocations.length;
			const lon = totals.lon / latestLocations.length;
			const zoom =
				latestLocations.length === 1
					? 5.5
					: latestLocations.length <= 3
						? 3.2
						: 2.4;
			return { lat, lon, zoom };
		})(),
	);

	const heroMetrics = $derived([
		{
			label: "VIDEOS",
			value: tableData.videos.length.toString().padStart(2, "0"),
		},
		{
			label: "CURATORS",
			value: uniqueContributors.toString().padStart(2, "0"),
		},
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	]);

	const totalLikes = $derived(
		tableData.videos.reduce(
			(sum, video) => sum + (video.original.likes ?? 0),
			0,
		),
	);

	const profileStats = $derived({
		videos: tableData.videos.length,
		sounds: tableData.sounds.length,
		duration: formatRuntime(totalRuntimeSeconds),
		likes: totalLikes,
	});

	function getSortValue(
		row: any,
		tableKey: TableKey,
		key: string,
	): string | number {
		if (tableKey === "videos") {
			switch (key) {
				case "title":
					return row.title;
				case "author":
					return row.author;
				case "duration":
					return row.durationValue;
				case "uploaded":
					return row.uploadedValue;
				case "views":
					return row.viewsValue ?? -1;
				default:
					return "";
			}
		}
		if (tableKey === "sounds") {
			switch (key) {
				case "title":
					return row.title;
				case "recordist":
					return row.recordist;
				case "project":
					return row.project;
				case "captured":
					return row.capturedValue;
				case "duration":
					return row.durationValue;
				default:
					return "";
			}
		}
		if (tableKey === "members") {
			switch (key) {
				case "name":
					return row.name;
				case "videos":
					return row.videos;
				case "followers":
					return row.followers;
				case "following":
					return row.following;
				case "joined":
					return row.joinedValue;
				default:
					return "";
			}
		}
		if (tableKey === "keywords") {
			switch (key) {
				case "keyword":
					return row.keyword;
				case "usage":
					return row.usage;
				case "related":
					return row.related;
				default:
					return "";
			}
		}
		return "";
	}

	function sortRows(tableKey: TableKey) {
		const state = tableState[tableKey];
		if (!state) return [];
		const rows = [...(tableData[tableKey] as any[])];
		const direction = state.sortDirection === "asc" ? 1 : -1;

		return rows.sort((a, b) => {
			const aValue = getSortValue(a, tableKey, state.sortKey);
			const bValue = getSortValue(b, tableKey, state.sortKey);
			if (typeof aValue === "number" && typeof bValue === "number") {
				return (aValue - bValue) * direction;
			}
			const aStr = `${aValue ?? ""}`.toLowerCase();
			const bStr = `${bValue ?? ""}`.toLowerCase();
			return (
				aStr.localeCompare(bStr, undefined, {
					numeric: true,
					sensitivity: "base",
				}) * direction
			);
		});
	}

	function toggleSort(tableKey: TableKey, columnKey: string) {
		const current = tableState[tableKey];
		if (!current) return;
		if (current.sortKey === columnKey) {
			current.sortDirection =
				current.sortDirection === "asc" ? "desc" : "asc";
		} else {
			current.sortKey = columnKey;
			current.sortDirection = "asc";
		}
	}

	function openVideo(video: any, event?: MouseEvent) {
		if (event) {
			if (
				event.metaKey ||
				event.ctrlKey ||
				event.shiftKey ||
				event.button !== 0
			)
				return;
			event.preventDefault();
		}
		selectedVideo.selectVideo(video.id);
		actions.setExpanded(false);
		goto("/");
	}

	function handleVideoRowKey(event: KeyboardEvent, video: any) {
		if (event.key === "Enter" || event.key === " ") {
			event.preventDefault();
			openVideo(video);
		}
	}

	const sortedVideoRows = $derived(sortRows("videos"));
	const sortedSoundRows = $derived(sortRows("sounds"));
	const sortedMemberRows = $derived(sortRows("members"));
	const sortedKeywordRows = $derived(sortRows("keywords"));
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta
		name="description"
		content="Terminal overview of the Rushes archive."
	/>
</svelte:head>

<div
	class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200"
>
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<div
				class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"
			></div>
			<div
				class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"
			></div>
			<div
				class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-end md:justify-between"
			>
				<div class="min-w-0 space-y-3">
					<p
						class="text-[11px] uppercase tracking-[0.35em] text-slate-500"
					>
						Rushes.fm
					</p>
					<!-- <h1 class="text-2xl font-semibold text-white">
						Channel Overview
					</h1> -->
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						RUSHES.BE est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire d’expérimentation visuelle.

					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div
							class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner"
						>
							<p
								class="text-[10px] uppercase tracking-[0.3em] text-slate-500"
							>
								{metric.label}
							</p>
							<p class="mt-2 text-lg font-semibold text-white">
								{metric.value}
							</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<div class="grid gap-8 lg:grid-cols-2">
			<div
				class="column-container space-y-8"
				aria-label="Primary dashboard column"
				use:dndzone={{
					items: itemsLeft,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				onconsider={updateLeftColumn}
				onfinalize={updateLeftColumn}
			>
				{#each itemsLeft as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>

			<div
				class="column-container space-y-8"
				aria-label="Secondary dashboard column"
				use:dndzone={{
					items: itemsRight,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				onconsider={updateRightColumn}
				onfinalize={updateRightColumn}
			>
				{#each itemsRight as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>
		</div>
	</div>
</div>

<style>
	.column-container {
		transition:
			background-color 0.2s ease,
			border-color 0.2s ease;
		border-radius: 0.5rem;
		border: 1px solid transparent;
		min-height: min-content;
	}
	:global(.dashboard-drop-target) {
		background-color: rgba(56, 189, 248, 0.05);
		border-color: rgba(56, 189, 248, 0.2);
	}
	.draggable-item[data-is-dnd-shadow-item-hint="true"] {
		opacity: 0.65;
	}
</style>
</file>

<file path="src/routes/videos/+page.svelte.backup">
<script lang="ts">
	import { goto } from "$app/navigation";
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { slide } from "svelte/transition";
	import {
		dndzone,
		type DndEvent,
		SHADOW_ITEM_MARKER_PROPERTY_NAME,
	} from "svelte-dnd-action";
	import DashboardPanel from "$lib/components/dashboard/DashboardPanel.svelte";
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		SortDirection,
		TableColumn,
		TableKey,
		TableState,
	} from "$lib/types/dashboard";
import { videosStore, usersStore } from "$lib/stores/library";

	const boardDndType = "dashboard-panels";
	const boardDropTargetClasses = ["dashboard-drop-target"];
	const boardFlipDurationMs = 200;

	const videos = $derived($videosStore);
	const users = $derived($usersStore);

	// State for draggable items in each column
	let itemsLeft = $state<DashboardItem[]>([{ id: 1, component: "videos" }, { id: 2, component: "sounds" }]);

	let itemsRight = $state<DashboardItem[]>([
		{ id: 5, component: "profile" },
		{ id: 6, component: "activity" },
		{ id: 7, component: "locations" },
		{ id: 3, component: "members" },
		{ id: 4, component: "keywords" },
	]);

	const sectionLabels: Record<DashboardComponentKey, string> = {
		videos: "Queue overview",
		profile: "Profile summary",
		activity: "Live activity",
		sounds: "Sounds",
		members: "Members",
		keywords: "Keywords",
		locations: "Latest locations",
	};

	function getSectionLabel(item: DashboardItem) {
		return sectionLabels[item.component] ?? "Dashboard section";
	}

	function updateLeftColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsLeft = event.detail.items as DashboardItem[];
	}

	function updateRightColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsRight = event.detail.items as DashboardItem[];
	}

	const liveActivity = $state([
		{
			id: "act-1",
			user: "Inès Duarte",
			action: "liked",
			content: "Canal Footbridge Atmos",
			type: "like",
			time: "2m ago",
		},
		{
			id: "act-2",
			user: "Luca Van Eyck",
			action: "commented on",
			content: "Metro Brakes – Line 6",
			type: "comment",
			time: "5m ago",
		},
		{
			id: "act-3",
			user: "Aya Kakei",
			action: "liked",
			content: "Night Rain On Skylight",
			type: "like",
			time: "1h ago",
		},
		{
			id: "act-4",
			user: "Tom Schurr",
			action: "commented on",
			content: "Textile Rustle Layers",
			type: "comment",
			time: "3h ago",
		},
	]);

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	let collapsed = $state({
		videos: false,
		sounds: false,
		members: false,
		keywords: false,
		activity: false,
		locations: false,
	});

	function toggleCollapse(component: DashboardComponentKey) {
		collapsed[component] = !collapsed[component];
	}

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let tableState = $state({
		videos: {
			key: "videos",
			label: "Queue",
			sortKey: "uploaded",
			sortDirection: "desc",
			defaultSort: { key: "uploaded", direction: "desc" },
			columns: [],
		},
		sounds: {
			key: "sounds",
			label: "Sounds",
			sortKey: "captured",
			sortDirection: "desc",
			defaultSort: { key: "captured", direction: "desc" },
			columns: [
				{ key: "title", label: "CLIP" },
				{ key: "recordist", label: "CAPTURED_BY" },
				{ key: "captured", label: "CAPTURED", align: "right" },
				{ key: "duration", label: "DURATION", align: "right" },
			],
		},
		members: {
			key: "members",
			label: "MEMBERS",
			sortKey: "name",
			sortDirection: "asc",
			defaultSort: { key: "name", direction: "asc" },
			columns: [
				{ key: "name", label: "NAME" },
				{ key: "videos", label: "VIDEOS", align: "right" },
				{ key: "followers", label: "FOLLOWERS", align: "right" },
				{ key: "following", label: "FOLLOWING", align: "right" },
				{ key: "joined", label: "JOINED", align: "right" },
			],
		},
		keywords: {
			key: "keywords",
			label: "KEYWORDS",
			sortKey: "keyword",
			sortDirection: "asc",
			defaultSort: { key: "keyword", direction: "asc" },
			columns: [
				{ key: "keyword", label: "TERM" },
				{ key: "usage", label: "USAGE", align: "right" },
				{ key: "related", label: "RELATED_PROJECTS" },
			],
		},
	});

	function formatDate(iso?: string) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		return date.toISOString().split("T")[0];
	}

	function parseDuration(value?: string) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [h, m, s] = parts;
			return h * 3600 + m * 60 + s;
		}
		if (parts.length === 2) {
			const [m, s] = parts;
			return m * 60 + s;
		}
		return parts[0];
	}

	function formatViews(views?: number) {
		if (typeof views !== "number" || Number.isNaN(views)) return "—";
		if (views >= 1_000_000) return `${(views / 1_000_000).toFixed(1)}M`;
		if (views >= 1_000) return `${(views / 1_000).toFixed(1)}K`;
		return `${views}`;
	}

	function formatStat(num: number) {
		if (num >= 1000) return `${(num / 1000).toFixed(1)}k`;
		return num.toString();
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return 0;
	}

	function getLocationCoordinates(
		location: any,
	): { lat: number; lon: number } | null {
		if (
			typeof location?.mapLat === "number" &&
			typeof location?.mapLon === "number"
		) {
			return { lat: location.mapLat, lon: location.mapLon };
		}
		if (
			typeof location?.latitude === "number" &&
			typeof location?.longitude === "number"
		) {
			return { lat: location.latitude, lon: location.longitude };
		}
		if (
			Array.isArray(location?.coordinates) &&
			location.coordinates.length === 2
		) {
			const [lat, lon] = location.coordinates;
			if (typeof lat === "number" && typeof lon === "number") {
				return { lat, lon };
			}
		}
		return null;
	}

	function getKeywordsSummary() {
		const keywordMap = new Map<
			string,
			{ usage: number; related: Set<string> }
		>();
		for (const video of videos) {
			for (const key of video.keywords ?? []) {
				const entry = keywordMap.get(key) ?? {
					usage: 0,
					related: new Set<string>(),
				};
				entry.usage += 1;
				entry.related.add(video.title);
				keywordMap.set(key, entry);
			}
		}
		return Array.from(keywordMap.entries()).map(([keyword, info]) => ({
			keyword,
			usage: info.usage,
			related: Array.from(info.related).join(", "),
		}));
	}

	const tableData = $derived({
		videos: videos.map((video) => {
			const iso = video.timestamp ?? video.uploadDate ?? null;
			const uploadedLabel = iso
				? formatDate(iso)
				: (video.uploadedAt ?? "—");
			return {
				id: video.id,
				title: video.title,
				author: video.author,
				duration: video.duration ?? "0:00",
				durationValue: video.duration,
				uploaded: uploadedLabel,
				uploadedValue: iso ? Date.parse(iso) : Number.NEGATIVE_INFINITY,
				views: formatViews(video.views),
				viewsValue:
					typeof video.views === "number" ? video.views : null,
				original: video,
			};
		}),
		sounds: soundLibrary.map((clip) => ({
			id: clip.id,
			title: clip.title,
			location: clip.location,
			recordist: clip.recordist,
			project: clip.relatedProject,
			captured: formatDate(clip.capturedOn),
			capturedValue: Date.parse(clip.capturedOn),
			duration: clip.duration,
			durationValue: clip.duration,
		})),
		members: users.map((user) => ({
			id: user.id,
			name: user.name,
			videos: user.stats?.videos ?? 0,
			followers: user.stats?.followers ?? 0,
			following: user.stats?.following ?? 0,
			joined: user.joinedAt ? formatDate(user.joinedAt) : "—",
			joinedValue: user.joinedAt
				? Date.parse(user.joinedAt)
				: Number.NEGATIVE_INFINITY,
		})),
		keywords: getKeywordsSummary(),
	});

	const totalRuntimeSeconds = $derived(
		tableData.videos.reduce(
			(total, video) =>
				total +
				(typeof video.durationValue === "number"
					? video.durationValue
					: 0),
			0,
		),
	);
	const uniqueContributors = $derived(
		new Set(
			tableData.videos
				.map((video) => video.author)
				.filter((author) => Boolean(author)),
		).size,
	);
	const lastUploadedTimestamp = $derived(
		tableData.videos.reduce((latest, video) => {
			if (Number.isFinite(video.uploadedValue)) {
				return Math.max(latest, video.uploadedValue);
			}
			return latest;
		}, Number.NEGATIVE_INFINITY),
	);

	const lastUpdated = $derived(
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—",
	);
	const averageDurationLabel = $derived(() => {
		if (tableData.videos.length === 0) return "0m";
		const averageSeconds = Math.round(
			totalRuntimeSeconds / tableData.videos.length,
		);
		return formatRuntime(averageSeconds);
	});

	const latestLocations = $derived<LatestLocationPin[]>(() => {
		const pins: LatestLocationPin[] = [];
		for (const video of videos) {
			const locations = video.locations ?? [];
			if (!Array.isArray(locations) || locations.length === 0) continue;
			const timestampValue = getVideoTimestampValue(video);
			const isoCandidate =
				typeof (video.timestamp ?? video.uploadDate) === "string"
					? (video.timestamp ?? video.uploadDate)
					: null;
			const uploadedLabel =
				isoCandidate && !Number.isNaN(Date.parse(isoCandidate))
					? formatDate(isoCandidate)
					: typeof video.uploadedAt === "string"
						? video.uploadedAt
						: "—";
			locations.forEach((location, index) => {
				const coords = getLocationCoordinates(location);
				if (!coords) return;
				pins.push({
					id: `${video.id}-${index}`,
					videoId: video.id,
					videoTitle: video.title,
					videoAuthor: video.author,
					uploadedLabel,
					timestampValue,
					lat: coords.lat,
					lon: coords.lon,
					setting: location.setting ?? location.name,
					thumbnailUrl: video.thumbnailUrl,
				});
			});
		}
		return pins
			.sort((a, b) => b.timestampValue - a.timestampValue)
			.slice(0, 6);
	});

	const locationCenter = $derived<LocationCenter>(() => {
		if (latestLocations.length === 0) {
			return { lat: 20, lon: 0, zoom: 1.6 };
		}
		const totals = latestLocations.reduce(
			(acc, loc) => {
				acc.lat += loc.lat;
				acc.lon += loc.lon;
				return acc;
			},
			{ lat: 0, lon: 0 },
		);
		const lat = totals.lat / latestLocations.length;
		const lon = totals.lon / latestLocations.length;
		const zoom =
			latestLocations.length === 1
				? 5.5
				: latestLocations.length <= 3
					? 3.2
					: 2.4;
		return { lat, lon, zoom };
	});

	const heroMetrics = $derived([
		{
			label: "VIDEOS",
			value: tableData.videos.length.toString().padStart(2, "0"),
		},
		{
			label: "CURATORS",
			value: uniqueContributors.toString().padStart(2, "0"),
		},
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	]);

	const totalLikes = $derived(
		tableData.videos.reduce(
			(sum, video) => sum + (video.original.likes ?? 0),
			0,
		),
	);

	const profileStats = $derived({
		videos: tableData.videos.length,
		sounds: tableData.sounds.length,
		duration: formatRuntime(totalRuntimeSeconds),
		likes: totalLikes,
	});

	function getSortValue(
		row: any,
		tableKey: TableKey,
		key: string,
	): string | number {
		if (tableKey === "videos") {
			switch (key) {
				case "title":
					return row.title;
				case "author":
					return row.author;
				case "duration":
					return row.durationValue;
				case "uploaded":
					return row.uploadedValue;
				case "views":
					return row.viewsValue ?? -1;
				default:
					return "";
			}
		}
		if (tableKey === "sounds") {
			switch (key) {
				case "title":
					return row.title;
				case "recordist":
					return row.recordist;
				case "project":
					return row.project;
				case "captured":
					return row.capturedValue;
				case "duration":
					return row.durationValue;
				default:
					return "";
			}
		}
		if (tableKey === "members") {
			switch (key) {
				case "name":
					return row.name;
				case "videos":
					return row.videos;
				case "followers":
					return row.followers;
				case "following":
					return row.following;
				case "joined":
					return row.joinedValue;
				default:
					return "";
			}
		}
		if (tableKey === "keywords") {
			switch (key) {
				case "keyword":
					return row.keyword;
				case "usage":
					return row.usage;
				case "related":
					return row.related;
				default:
					return "";
			}
		}
		return "";
	}

	function sortRows(tableKey: TableKey) {
		const state = tableState[tableKey];
		if (!state) return [];
		const rows = [...(tableData[tableKey] as any[])];
		const direction = state.sortDirection === "asc" ? 1 : -1;

		return rows.sort((a, b) => {
			const aValue = getSortValue(a, tableKey, state.sortKey);
			const bValue = getSortValue(b, tableKey, state.sortKey);
			if (typeof aValue === "number" && typeof bValue === "number") {
				return (aValue - bValue) * direction;
			}
			const aStr = `${aValue ?? ""}`.toLowerCase();
			const bStr = `${bValue ?? ""}`.toLowerCase();
			return (
				aStr.localeCompare(bStr, undefined, {
					numeric: true,
					sensitivity: "base",
				}) * direction
			);
		});
	}

	function toggleSort(tableKey: TableKey, columnKey: string) {
		const current = tableState[tableKey];
		if (!current) return;
		if (current.sortKey === columnKey) {
			current.sortDirection =
				current.sortDirection === "asc" ? "desc" : "asc";
		} else {
			current.sortKey = columnKey;
			current.sortDirection = "asc";
		}
	}

	function openVideo(video: any, event?: MouseEvent) {
		if (event) {
			if (
				event.metaKey ||
				event.ctrlKey ||
				event.shiftKey ||
				event.button !== 0
			)
				return;
			event.preventDefault();
		}
		selectedVideo.selectVideo(video.id);
		actions.setExpanded(true);
		goto("/");
	}

	function handleVideoRowKey(event: KeyboardEvent, video: any) {
		if (event.key === "Enter" || event.key === " ") {
			event.preventDefault();
			openVideo(video);
		}
	}

	const sortedVideoRows = $derived(sortRows("videos"));
	const sortedSoundRows = $derived(sortRows("sounds"));
	const sortedMemberRows = $derived(sortRows("members"));
	const sortedKeywordRows = $derived(sortRows("keywords"));
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta
		name="description"
		content="Terminal overview of the Rushes archive."
	/>
</svelte:head>

<div
	class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200"
>
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<div
				class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"
			></div>
			<div
				class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"
			></div>
			<div
				class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-end md:justify-between"
			>
				<div class="min-w-0 space-y-3">
					<p
						class="text-[11px] uppercase tracking-[0.35em] text-slate-500"
					>
						Rushes.fm
					</p>
					<!-- <h1 class="text-2xl font-semibold text-white">
						Channel Overview
					</h1> -->
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						RUSHES.BE est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire d’expérimentation visuelle.

					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div
							class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner"
						>
							<p
								class="text-[10px] uppercase tracking-[0.3em] text-slate-500"
							>
								{metric.label}
							</p>
							<p class="mt-2 text-lg font-semibold text-white">
								{metric.value}
							</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<div class="grid gap-8 lg:grid-cols-2">
			<div
				class="column-container space-y-8"
				aria-label="Primary dashboard column"
				use:dndzone={{
					items: itemsLeft,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateLeftColumn}
				on:finalize={updateLeftColumn}
			>
				{#each itemsLeft as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>

			<div
				class="column-container space-y-8"
				aria-label="Secondary dashboard column"
				use:dndzone={{
					items: itemsRight,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateRightColumn}
				on:finalize={updateRightColumn}
			>
				{#each itemsRight as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>
		</div>
	</div>
</div>

<style>
	.column-container {
		transition:
			background-color 0.2s ease,
			border-color 0.2s ease;
		border-radius: 0.5rem;
		border: 1px solid transparent;
		min-height: min-content;
	}
	:global(.dashboard-drop-target) {
		background-color: rgba(56, 189, 248, 0.05);
		border-color: rgba(56, 189, 248, 0.2);
	}
	.draggable-item[data-is-dnd-shadow-item-hint="true"] {
		opacity: 0.65;
	}
</style>
</file>

<file path="src/routes/+layout.server.ts">
// src/routes/+layout.server.ts

import type { LayoutServerLoad } from './$types';
import { getAllVideos } from '$lib/server/db/videos';
import { getAllUsers } from '$lib/server/db/users';
import { getDb } from '$lib/server/db'; // <-- Import your factory function

const DATABASE_TIMEOUT_MS = 10000;

export const load: LayoutServerLoad = async ({ platform }) => {
	console.log('--- LAYOUT SERVER LOAD START ---');

	const databaseUrl = platform?.env?.DATABASE_URL;
	if (!databaseUrl) {
		console.error('Failed to load: DATABASE_URL binding not found.');
		return { videos: [], users: [], error: 'Database not configured.' };
	}

	// 1. Create the db instance from the binding
	const db = getDb(databaseUrl);

	console.log('Attempting to fetch videos and users...');

	try {
		// 2. Pass the db instance to your imported functions
		const [videos, users] = (await Promise.race([
			Promise.all([
				getAllVideos(db), // <-- Use the imported function
				getAllUsers(db) // <-- Use the imported function
			]),
			new Promise((_, reject) =>
				setTimeout(() => reject(new Error('Database query timeout')), DATABASE_TIMEOUT_MS)
			)
		])) as [Awaited<ReturnType<typeof getAllVideos>>, Awaited<ReturnType<typeof getAllUsers>>];

		console.log(`Successfully fetched ${videos.length} videos and ${users.length} users.`);

		return {
			videos,
			users
		};
	} catch (error) {
		console.error('Failed to load initial data:', error);
		return {
			videos: [],
			users: [],
			error: error instanceof Error ? error.message : 'Failed to load content'
		};
	}
};
</file>

<file path="src/routes/+page.svelte.backup">
<script lang="ts">
</script>

<svelte:head>
  <title>rushes.fm - Global Video Archive</title>
  <meta name="description" content="A platform for finding and sharing unedited footage from users around the world. Discover connections through AI-powered content analysis." />
</svelte:head>

<div class="min-h-screen bg-white dark:bg-black">

</div>
</file>

<file path="src/routes/+page.svelte.dashboard-backup">
<script lang="ts">
	import { goto } from "$app/navigation";
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { slide } from "svelte/transition";
	import {
		dndzone,
		type DndEvent,
		SHADOW_ITEM_MARKER_PROPERTY_NAME,
	} from "svelte-dnd-action";
	import DashboardPanel from "$lib/components/dashboard/DashboardPanel.svelte";
	import type {
		DashboardComponentKey,
		DashboardItem,
		LatestLocationPin,
		LocationCenter,
		SortDirection,
		TableColumn,
		TableKey,
		TableState,
	} from "$lib/types/dashboard";
import { videosStore, usersStore } from "$lib/stores/library";

	const boardDndType = "dashboard-panels";
	const boardDropTargetClasses = ["dashboard-drop-target"];
	const boardFlipDurationMs = 200;

	const videos = $derived($videosStore);
	const users = $derived($usersStore);

	// State for draggable items in each column
	let itemsLeft = $state<DashboardItem[]>([{ id: 1, component: "videos" }, { id: 2, component: "sounds" }]);

	let itemsRight = $state<DashboardItem[]>([
		{ id: 5, component: "profile" },
		{ id: 6, component: "activity" },
		{ id: 7, component: "locations" },
		{ id: 3, component: "members" },
		{ id: 4, component: "keywords" },
	]);

	const sectionLabels: Record<DashboardComponentKey, string> = {
		videos: "Queue overview",
		profile: "Profile summary",
		activity: "Live activity",
		sounds: "Sounds",
		members: "Members",
		keywords: "Keywords",
		locations: "Latest locations",
	};

	function getSectionLabel(item: DashboardItem) {
		return sectionLabels[item.component] ?? "Dashboard section";
	}

	function updateLeftColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsLeft = event.detail.items as DashboardItem[];
	}

	function updateRightColumn(event: CustomEvent<DndEvent<DashboardItem>>) {
		itemsRight = event.detail.items as DashboardItem[];
	}

	const liveActivity = $state([
		{
			id: "act-1",
			user: "Inès Duarte",
			action: "liked",
			content: "Canal Footbridge Atmos",
			type: "like",
			time: "2m ago",
		},
		{
			id: "act-2",
			user: "Luca Van Eyck",
			action: "commented on",
			content: "Metro Brakes – Line 6",
			type: "comment",
			time: "5m ago",
		},
		{
			id: "act-3",
			user: "Aya Kakei",
			action: "liked",
			content: "Night Rain On Skylight",
			type: "like",
			time: "1h ago",
		},
		{
			id: "act-4",
			user: "Tom Schurr",
			action: "commented on",
			content: "Textile Rustle Layers",
			type: "comment",
			time: "3h ago",
		},
	]);

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	let collapsed = $state({
		videos: false,
		sounds: false,
		members: false,
		keywords: false,
		activity: false,
		locations: false,
	});

	function toggleCollapse(component: DashboardComponentKey) {
		collapsed[component] = !collapsed[component];
	}

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let tableState = $state({
		videos: {
			key: "videos",
			label: "Queue",
			sortKey: "uploaded",
			sortDirection: "desc",
			defaultSort: { key: "uploaded", direction: "desc" },
			columns: [],
		},
		sounds: {
			key: "sounds",
			label: "Sounds",
			sortKey: "captured",
			sortDirection: "desc",
			defaultSort: { key: "captured", direction: "desc" },
			columns: [
				{ key: "title", label: "CLIP" },
				{ key: "recordist", label: "CAPTURED_BY" },
				{ key: "captured", label: "CAPTURED", align: "right" },
				{ key: "duration", label: "DURATION", align: "right" },
			],
		},
		members: {
			key: "members",
			label: "MEMBERS",
			sortKey: "name",
			sortDirection: "asc",
			defaultSort: { key: "name", direction: "asc" },
			columns: [
				{ key: "name", label: "NAME" },
				{ key: "videos", label: "VIDEOS", align: "right" },
				{ key: "followers", label: "FOLLOWERS", align: "right" },
				{ key: "following", label: "FOLLOWING", align: "right" },
				{ key: "joined", label: "JOINED", align: "right" },
			],
		},
		keywords: {
			key: "keywords",
			label: "KEYWORDS",
			sortKey: "keyword",
			sortDirection: "asc",
			defaultSort: { key: "keyword", direction: "asc" },
			columns: [
				{ key: "keyword", label: "TERM" },
				{ key: "usage", label: "USAGE", align: "right" },
				{ key: "related", label: "RELATED_PROJECTS" },
			],
		},
	});

	function formatDate(iso?: string) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		return date.toISOString().split("T")[0];
	}

	function parseDuration(value?: string) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [h, m, s] = parts;
			return h * 3600 + m * 60 + s;
		}
		if (parts.length === 2) {
			const [m, s] = parts;
			return m * 60 + s;
		}
		return parts[0];
	}

	function formatViews(views?: number) {
		if (typeof views !== "number" || Number.isNaN(views)) return "—";
		if (views >= 1_000_000) return `${(views / 1_000_000).toFixed(1)}M`;
		if (views >= 1_000) return `${(views / 1_000).toFixed(1)}K`;
		return `${views}`;
	}

	function formatStat(num: number) {
		if (num >= 1000) return `${(num / 1000).toFixed(1)}k`;
		return num.toString();
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return 0;
	}

	function getLocationCoordinates(
		location: any,
	): { lat: number; lon: number } | null {
		if (
			typeof location?.mapLat === "number" &&
			typeof location?.mapLon === "number"
		) {
			return { lat: location.mapLat, lon: location.mapLon };
		}
		if (
			typeof location?.latitude === "number" &&
			typeof location?.longitude === "number"
		) {
			return { lat: location.latitude, lon: location.longitude };
		}
		if (
			Array.isArray(location?.coordinates) &&
			location.coordinates.length === 2
		) {
			const [lat, lon] = location.coordinates;
			if (typeof lat === "number" && typeof lon === "number") {
				return { lat, lon };
			}
		}
		return null;
	}

	function getKeywordsSummary() {
		const keywordMap = new Map<
			string,
			{ usage: number; related: Set<string> }
		>();
		for (const video of videos) {
			for (const key of video.keywords ?? []) {
				const entry = keywordMap.get(key) ?? {
					usage: 0,
					related: new Set<string>(),
				};
				entry.usage += 1;
				entry.related.add(video.title);
				keywordMap.set(key, entry);
			}
		}
		return Array.from(keywordMap.entries()).map(([keyword, info]) => ({
			keyword,
			usage: info.usage,
			related: Array.from(info.related).join(", "),
		}));
	}

	const tableData = $derived({
		videos: videos.map((video) => {
			const iso = video.timestamp ?? video.uploadDate ?? null;
			const uploadedLabel = iso
				? formatDate(iso)
				: (video.uploadedAt ?? "—");
			return {
				id: video.id,
				title: video.title,
				author: video.author,
				duration: video.duration ?? "0:00",
				durationValue: video.duration,
				uploaded: uploadedLabel,
				uploadedValue: iso ? Date.parse(iso) : Number.NEGATIVE_INFINITY,
				views: formatViews(video.views),
				viewsValue:
					typeof video.views === "number" ? video.views : null,
				original: video,
			};
		}),
		sounds: soundLibrary.map((clip) => ({
			id: clip.id,
			title: clip.title,
			location: clip.location,
			recordist: clip.recordist,
			project: clip.relatedProject,
			captured: formatDate(clip.capturedOn),
			capturedValue: Date.parse(clip.capturedOn),
			duration: clip.duration,
			durationValue: clip.duration,
		})),
		members: users.map((user) => ({
			id: user.id,
			name: user.name,
			videos: user.stats?.videos ?? 0,
			followers: user.stats?.followers ?? 0,
			following: user.stats?.following ?? 0,
			joined: user.joinedAt ? formatDate(user.joinedAt) : "—",
			joinedValue: user.joinedAt
				? Date.parse(user.joinedAt)
				: Number.NEGATIVE_INFINITY,
		})),
		keywords: getKeywordsSummary(),
	});

	const totalRuntimeSeconds = $derived(
		tableData.videos.reduce(
			(total, video) =>
				total +
				(typeof video.durationValue === "number"
					? video.durationValue
					: 0),
			0,
		),
	);
	const uniqueContributors = $derived(
		new Set(
			tableData.videos
				.map((video) => video.author)
				.filter((author) => Boolean(author)),
		).size,
	);
	const lastUploadedTimestamp = $derived(
		tableData.videos.reduce((latest, video) => {
			if (Number.isFinite(video.uploadedValue)) {
				return Math.max(latest, video.uploadedValue);
			}
			return latest;
		}, Number.NEGATIVE_INFINITY),
	);

	const lastUpdated = $derived(
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—",
	);
	const averageDurationLabel = $derived(() => {
		if (tableData.videos.length === 0) return "0m";
		const averageSeconds = Math.round(
			totalRuntimeSeconds / tableData.videos.length,
		);
		return formatRuntime(averageSeconds);
	});

	const latestLocations = $derived<LatestLocationPin[]>(() => {
		const pins: LatestLocationPin[] = [];
		for (const video of videos) {
			const locations = video.locations ?? [];
			if (!Array.isArray(locations) || locations.length === 0) continue;
			const timestampValue = getVideoTimestampValue(video);
			const isoCandidate =
				typeof (video.timestamp ?? video.uploadDate) === "string"
					? (video.timestamp ?? video.uploadDate)
					: null;
			const uploadedLabel =
				isoCandidate && !Number.isNaN(Date.parse(isoCandidate))
					? formatDate(isoCandidate)
					: typeof video.uploadedAt === "string"
						? video.uploadedAt
						: "—";
			locations.forEach((location, index) => {
				const coords = getLocationCoordinates(location);
				if (!coords) return;
				pins.push({
					id: `${video.id}-${index}`,
					videoId: video.id,
					videoTitle: video.title,
					videoAuthor: video.author,
					uploadedLabel,
					timestampValue,
					lat: coords.lat,
					lon: coords.lon,
					setting: location.setting ?? location.name,
					thumbnailUrl: video.thumbnailUrl,
				});
			});
		}
		return pins
			.sort((a, b) => b.timestampValue - a.timestampValue)
			.slice(0, 6);
	});

	const locationCenter = $derived<LocationCenter>(() => {
		if (latestLocations.length === 0) {
			return { lat: 20, lon: 0, zoom: 1.6 };
		}
		const totals = latestLocations.reduce(
			(acc, loc) => {
				acc.lat += loc.lat;
				acc.lon += loc.lon;
				return acc;
			},
			{ lat: 0, lon: 0 },
		);
		const lat = totals.lat / latestLocations.length;
		const lon = totals.lon / latestLocations.length;
		const zoom =
			latestLocations.length === 1
				? 5.5
				: latestLocations.length <= 3
					? 3.2
					: 2.4;
		return { lat, lon, zoom };
	});

	const heroMetrics = $derived([
		{
			label: "VIDEOS",
			value: tableData.videos.length.toString().padStart(2, "0"),
		},
		{
			label: "CURATORS",
			value: uniqueContributors.toString().padStart(2, "0"),
		},
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	]);

	const totalLikes = $derived(
		tableData.videos.reduce(
			(sum, video) => sum + (video.original.likes ?? 0),
			0,
		),
	);

	const profileStats = $derived({
		videos: tableData.videos.length,
		sounds: tableData.sounds.length,
		duration: formatRuntime(totalRuntimeSeconds),
		likes: totalLikes,
	});

	function getSortValue(
		row: any,
		tableKey: TableKey,
		key: string,
	): string | number {
		if (tableKey === "videos") {
			switch (key) {
				case "title":
					return row.title;
				case "author":
					return row.author;
				case "duration":
					return row.durationValue;
				case "uploaded":
					return row.uploadedValue;
				case "views":
					return row.viewsValue ?? -1;
				default:
					return "";
			}
		}
		if (tableKey === "sounds") {
			switch (key) {
				case "title":
					return row.title;
				case "recordist":
					return row.recordist;
				case "project":
					return row.project;
				case "captured":
					return row.capturedValue;
				case "duration":
					return row.durationValue;
				default:
					return "";
			}
		}
		if (tableKey === "members") {
			switch (key) {
				case "name":
					return row.name;
				case "videos":
					return row.videos;
				case "followers":
					return row.followers;
				case "following":
					return row.following;
				case "joined":
					return row.joinedValue;
				default:
					return "";
			}
		}
		if (tableKey === "keywords") {
			switch (key) {
				case "keyword":
					return row.keyword;
				case "usage":
					return row.usage;
				case "related":
					return row.related;
				default:
					return "";
			}
		}
		return "";
	}

	function sortRows(tableKey: TableKey) {
		const state = tableState[tableKey];
		if (!state) return [];
		const rows = [...(tableData[tableKey] as any[])];
		const direction = state.sortDirection === "asc" ? 1 : -1;

		return rows.sort((a, b) => {
			const aValue = getSortValue(a, tableKey, state.sortKey);
			const bValue = getSortValue(b, tableKey, state.sortKey);
			if (typeof aValue === "number" && typeof bValue === "number") {
				return (aValue - bValue) * direction;
			}
			const aStr = `${aValue ?? ""}`.toLowerCase();
			const bStr = `${bValue ?? ""}`.toLowerCase();
			return (
				aStr.localeCompare(bStr, undefined, {
					numeric: true,
					sensitivity: "base",
				}) * direction
			);
		});
	}

	function toggleSort(tableKey: TableKey, columnKey: string) {
		const current = tableState[tableKey];
		if (!current) return;
		if (current.sortKey === columnKey) {
			current.sortDirection =
				current.sortDirection === "asc" ? "desc" : "asc";
		} else {
			current.sortKey = columnKey;
			current.sortDirection = "asc";
		}
	}

	function openVideo(video: any, event?: MouseEvent) {
		if (event) {
			if (
				event.metaKey ||
				event.ctrlKey ||
				event.shiftKey ||
				event.button !== 0
			)
				return;
			event.preventDefault();
		}
		selectedVideo.selectVideo(video.id);
		// Keep in sidebar mode on home page
		actions.setExpanded(false);
	}

	function handleVideoRowKey(event: KeyboardEvent, video: any) {
		if (event.key === "Enter" || event.key === " ") {
			event.preventDefault();
			openVideo(video);
		}
	}

	const sortedVideoRows = $derived(sortRows("videos"));
	const sortedSoundRows = $derived(sortRows("sounds"));
	const sortedMemberRows = $derived(sortRows("members"));
	const sortedKeywordRows = $derived(sortRows("keywords"));
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta
		name="description"
		content="Terminal overview of the Rushes archive."
	/>
</svelte:head>

<div
	class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200"
>
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden border border-white/10 bg-white/[0.04] px-6 py-8 shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)] sm:px-8 sm:py-10"
		>
			<div
				class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"
			></div>
			<div
				class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"
			></div>
			<div
				class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-end md:justify-between"
			>
				<div class="min-w-0 space-y-3">
					<p
						class="text-[11px] uppercase tracking-[0.35em] text-slate-500"
					>
						Rushes.fm
					</p>
					<!-- <h1 class="text-2xl font-semibold text-white">
						Channel Overview
					</h1> -->
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						RUSHES.BE est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire d’expérimentation visuelle.

					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div
							class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner"
						>
							<p
								class="text-[10px] uppercase tracking-[0.3em] text-slate-500"
							>
								{metric.label}
							</p>
							<p class="mt-2 text-lg font-semibold text-white">
								{metric.value}
							</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<div class="grid gap-8 lg:grid-cols-2">
			<div
				class="column-container space-y-8"
				aria-label="Primary dashboard column"
				use:dndzone={{
					items: itemsLeft,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateLeftColumn}
				on:finalize={updateLeftColumn}
			>
				{#each itemsLeft as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>

			<div
				class="column-container space-y-8"
				aria-label="Secondary dashboard column"
				use:dndzone={{
					items: itemsRight,
					type: boardDndType,
					dropTargetClasses: boardDropTargetClasses,
					flipDurationMs: boardFlipDurationMs,
				}}
				on:consider={updateRightColumn}
				on:finalize={updateRightColumn}
			>
				{#each itemsRight as item (item.id + (item[SHADOW_ITEM_MARKER_PROPERTY_NAME] ? "-shadow" : ""))}
					{@const isShadow = Boolean(
						item[SHADOW_ITEM_MARKER_PROPERTY_NAME],
					)}
					<div
						class="draggable-item"
						data-is-dnd-shadow-item-hint={isShadow
							? "true"
							: undefined}
						aria-label={isShadow
							? undefined
							: getSectionLabel(item)}
					>
						<DashboardPanel
							{item}
							{collapsed}
							{toggleCollapse}
							{tableState}
							{sortedVideoRows}
							{sortedSoundRows}
							{sortedMemberRows}
							{sortedKeywordRows}
							{toggleSort}
							{openVideo}
							{handleVideoRowKey}
							{liveActivity}
							{formatStat}
							{latestLocations}
							{locationCenter}
							{profileStats}
						/>
					</div>
				{/each}
			</div>
		</div>
	</div>
</div>

<style>
	.column-container {
		transition:
			background-color 0.2s ease,
			border-color 0.2s ease;
		border-radius: 0.5rem;
		border: 1px solid transparent;
		min-height: min-content;
	}
	:global(.dashboard-drop-target) {
		background-color: rgba(56, 189, 248, 0.05);
		border-color: rgba(56, 189, 248, 0.2);
	}
	.draggable-item[data-is-dnd-shadow-item-hint="true"] {
		opacity: 0.65;
	}
</style>
</file>

<file path="src/routes/page copy.svelte">
<script lang="ts">
  import StatsSection from '$lib/components/home/StatsSection.svelte';
  import GeneratedChannels from '$lib/components/home/GeneratedChannels.svelte';
</script>

<svelte:head>
  <title>rushes.fm - Global Video Archive</title>
  <meta name="description" content="A platform for finding and sharing unedited footage from users around the world. Discover connections through AI-powered content analysis." />
</svelte:head>

<div class="min-h-screen bg-white dark:bg-black">
  <!-- Minimal Header -->
  <header class="border-b border-gray-100 dark:border-gray-900 bg-white/60 dark:bg-black/60 backdrop-blur-sm sticky top-0 z-10">
    <div class="mx-auto max-w-4xl px-6 py-3">
      <div class="flex items-center justify-between">
        <!-- Logo -->
        <a href="/" class="flex items-center gap-2 hover:opacity-80 transition-opacity">
          <div class="h-5 w-5 rounded bg-blue-600"></div>
          <span class="text-base font-medium text-gray-900 dark:text-white">rushes.fm</span>
        </a>

        <!-- Navigation -->
        <nav class="flex items-center gap-6 text-sm text-gray-600 dark:text-gray-400">
          <a href="/videos" class="hover:text-gray-900 dark:hover:text-white transition-colors">Browse</a>
          <a href="/keywords" class="hover:text-gray-900 dark:hover:text-white transition-colors">Keywords</a>
          <a href="/map" class="hover:text-gray-900 dark:hover:text-white transition-colors">Map</a>
          <a href="/about" class="hover:text-gray-900 dark:hover:text-white transition-colors">About</a>
        </nav>
      </div>
    </div>
  </header>

  <!-- Main Content -->
  <main class="mx-auto max-w-5xl px-6 py-12">
    <!-- Hero Section -->
    <div class="text-center mb-16">
      <h1 class="text-4xl font-bold text-gray-900 dark:text-white mb-6">
        rushes.fm
      </h1>
      <div class="max-w-3xl mx-auto">
        <p class="text-lg text-gray-600 dark:text-gray-400 leading-relaxed mb-8">
          rushes.fm is a platform for finding and sharing unedited footage from users around the world.
          Vector embeddings allow the platform to find connections between clips based on the content of the footage,
          as well as metadata such as keywords, transcriptions and location information.
          Each week the platform generates a new channel based on the content uploaded from the prior seven days.
        </p>

        <!-- Action Buttons -->
        <div class="flex items-center justify-center gap-4 mb-12">
          <a
            href="/videos"
            class="rounded-full bg-blue-600 px-6 py-3 text-sm font-semibold text-white hover:bg-blue-500 transition-colors"
          >
            Browse Archive
          </a>
          <a
            href="/keywords"
            class="rounded-full border border-gray-300 dark:border-gray-600 px-6 py-3 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors"
          >
            Explore Keywords
          </a>
        </div>
      </div>
    </div>

    <!-- Generated Channels -->
    <GeneratedChannels />

    <!-- Account Creation CTA -->
    <div class="rounded-2xl bg-gradient-to-br from-blue-50 to-purple-50 dark:from-gray-900 dark:to-gray-800 border border-gray-200 dark:border-gray-700 p-8 mb-16">
      <div class="text-center mb-8">
        <h2 class="text-2xl font-bold text-gray-900 dark:text-white mb-3">
          Unlock the Full Archive Experience
        </h2>
        <p class="text-gray-600 dark:text-gray-400 max-w-2xl mx-auto">
          Create an account to access advanced features, contribute your footage, and build your personal video vault
        </p>
      </div>

      <!-- Benefits Grid -->
      <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8">
        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-blue-100 dark:bg-blue-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-blue-600 dark:text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Upload & Archive</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Upload your unedited footage to the global archive</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-green-100 dark:bg-green-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-green-600 dark:text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Auto-Transcription</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Automatic speech-to-text for searchable content</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-purple-100 dark:bg-purple-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-purple-600 dark:text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Rich Metadata</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Location, keywords, and content analysis</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-orange-100 dark:bg-orange-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-orange-600 dark:text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Natural Language Search</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Search using everyday language and concepts</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-pink-100 dark:bg-pink-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-pink-600 dark:text-pink-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Create Channels</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Curate and subscribe to themed collections</p>
          </div>
        </div>

        <div class="flex items-start gap-3">
          <div class="flex-shrink-0 w-8 h-8 rounded-full bg-indigo-100 dark:bg-indigo-900 flex items-center justify-center">
            <svg class="w-4 h-4 text-indigo-600 dark:text-indigo-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
            </svg>
          </div>
          <div>
            <h4 class="font-semibold text-gray-900 dark:text-white text-sm">Personal Vault Export</h4>
            <p class="text-xs text-gray-600 dark:text-gray-400 mt-1">Download your data for local LLM RAG systems</p>
          </div>
        </div>
      </div>

      <!-- CTA Buttons -->
      <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
        <button class="w-full sm:w-auto rounded-full bg-blue-600 px-8 py-3 text-sm font-semibold text-white hover:bg-blue-500 transition-colors shadow-lg">
          Create Free Account
        </button>
        <button class="w-full sm:w-auto rounded-full border border-gray-300 dark:border-gray-600 px-8 py-3 text-sm font-semibold text-gray-700 dark:text-gray-300 hover:bg-gray-50 dark:hover:bg-gray-800 transition-colors">
          Learn More
        </button>
      </div>

      <!-- Trust Indicators -->
      <div class="mt-6 text-center">
        <p class="text-xs text-gray-500 dark:text-gray-400">
          Free account • No credit card required • Export your data anytime
        </p>
      </div>
    </div>
<!--  -->
  </main>

  <!-- Stats at Bottom -->
  <StatsSection />
</div>
</file>

<file path="src/app.css">
@import 'tailwindcss';
@plugin '@tailwindcss/forms';
@plugin '@tailwindcss/typography';

@theme {
  --color-white: 255 255 255;
  --color-black: 0 0 0;
  --color-gray-50: #f9fafb;
  --color-gray-100: #f3f4f6;
  --color-gray-200: #e5e7eb;
  --color-gray-300: #d1d5db;
  --color-gray-400: #9ca3af;
  --color-gray-500: #6b7280;
  --color-gray-600: #4b5563;
  --color-gray-700: #374151;
  --color-gray-800: #1f2937;
  --color-gray-900: #111827;
  --color-gray-950: #030712;
}
body {
    background: black;
    color: white;
}

@layer utilities {
  .border-white\/5 {
    border-color: rgb(255 255 255 / 0.05);
  }
  .border-white\/10 {
    border-color: rgb(255 255 255 / 0.1);
  }
  .border-white\/20 {
    border-color: rgb(255 255 255 / 0.2);
  }
  .bg-white\/5 {
    background-color: rgb(255 255 255 / 0.05);
  }
  .bg-white\/10 {
    background-color: rgb(255 255 255 / 0.1);
  }
  .bg-white\/20 {
    background-color: rgb(255 255 255 / 0.2);
  }
  .bg-black\/50 {
    background-color: rgb(0 0 0 / 0.5);
  }
  .bg-black\/60 {
    background-color: rgb(0 0 0 / 0.6);
  }
  .bg-black\/70 {
    background-color: rgb(0 0 0 / 0.7);
  }
  .bg-black\/20 {
    background-color: rgb(0 0 0 / 0.2);
  }
  .bg-black\/15 {
    background-color: rgb(0 0 0 / 0.15);
  }
}
</file>

<file path="src/app.d.ts">
// See https://svelte.dev/docs/kit/types#app.d.ts
// for information about these interfaces
declare global {
	namespace App {
		// interface Error {}
		// interface Locals {}
		// interface PageData {}
		// interface PageState {}
		interface Platform {
			env?: Record<string, string>;
		}
	}
}

export {};
</file>

<file path="src/app.html">
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		%sveltekit.head%
	</head>
	<body data-sveltekit-preload-data="hover">
		<div style="display: contents">%sveltekit.body%</div>
	</body>
</html>
</file>

<file path="static/.assetsignore">
_worker.js
_routes.json
</file>

<file path="static/robots.txt">
# allow crawling everything by default
User-agent: *
Disallow:
</file>

<file path="static/rushes.svg">
<svg class="w-4 h-4 mr-2" style="display: inline-block; top: -10px !important; margin-top: 2px;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 45.5 53.6"><g fill-rule="nonzero" fill="none"><path d="M44.8 44.4c0-.2-.3-.4-.5-.5-.4-.4-1-1.3-1.2-1.2-.2-.3-.5-.3-.7-.5-.1-.2-.4-.4-.7-.4-.2-.3-.4-.5-.8-.7L36 37.3l-1-.7-1-1c-1-.4-1.7-1.2-2.5-1.8-.2-.3-.1-.5-.6-.7 0 0 0-.3-.2-.3-.2-.1-1-.5-1-.8 0-.3-.8-.7-1-.9-.1-.2-.5-.2-.7-.5l-.1-.4c-.2-.1-.4 0-.6-.2 2-.5 4-.6 5.8-1l3.7-.9c2-.4 4.2-1.2 6.3-1.3 1 0 1.5-1.2 1.6-2 0-.4-.1-.6-.3-.9 0 0-.2-1.2-.6-.6-.1-.2.2-.3 0-.6 0-.3-.3-.4-.6-.4l-.6-.4c-.4-.2-.8-.3-1.2-.2-.8 0-1.6 0-2.3.3-.7.4-1.6.5-2.4.7l-2.2.5c-.7 0-1.4.4-2.1.4-.8 0-1.6.4-2.3.5-.6.1-1.3 0-2 .3l.4-1c.2 0 .4-.8.5-1l.5-1.3c0 .6.3-.6.3-.3l.3-.6c0-.4.2-.5.3-.8.2-.3.5-.9.5-1.2 0-.3.4-.7.6-1l.4-.8.9-1.8c.4-.5.6-1.4 1-1.9.2-.1.5-.7.5-.9 0-.2.3-.4.5-.6a34.3 34.3 0 0 0 2-4c.2-.1.3-.7.5-1l.5-1.2v-.5c.1-.1.4-.1.3-.4l.3-1.2c.2-.6.1-.8-.4-1.2-.3-.2-.5-.2-.6-.6 0-.1 0-.4-.2-.5-.2-.3-1-.3-1.3-.3-.5-.5-1.1-.2-1.7-.3-.2 0-.4.2-.5.4-.2.1-.4 0-.7.2-.6.3-.6.7-.9 1.4l-.8 2.7c-.5.4-.8 1.8-1.1 2.4-.1.2-.3.7-.5.8l-.1.4-.5.7-.5 1.1c0 .3-.5.8-.5 1.2-.2 0-.3.6-.3.8-.2.1-.6.7-.5.8-.1.4-.5.7-.6 1l-.2.7c-.2 0-.5.4-.5.6 0 .9-1 1.5-1 2.3l-.6 1a5 5 0 0 1-.4 1l-.6 1.1c-.2.4-.3 1-.5 1.2l-.5.8-.2.9c-.3 0-.3.3-.4.5l-.7-1.1-1.1-1.2c-.2-.5-.8-.7-1-1 0-.3-.5-1-.8-1 .2-.1-1-1.4-1-1.4-.2-.7-.9-1.1-1.3-1.6l-2-2.5c-.3-.5-1.1-1-1.2-1.5 0-.4-.5-.3-.5-.6 0-.2-.3-.5-.5-.6-.2-.2-.7-.6-.8-1 0-.5-.9-.9-1.2-1.3C9.5 8.7 9.1 8 8.5 8s-.7-.5-1.4-.5c-1.4 0-3.4.6-3 2.4.1.8.7 1.3 1.2 1.8l1.5 1.7c.2.2.1.4.4.5l.9 1.1c.2.3.7 1.2 1.1 1.3l.7.9c.2.2.5.4.6.7 0 .3.2.1.3.3.2.3.5.9.8 1 0 .3.8 1.3 1 1.4.6.3.8 1 1.3 1.5.4.3.7.9 1 1.3.3.5.8 1 1.3 1.4 0 .3.2.5.4.6l.5.8-2.9.7c-.7.2-1.5.6-2.2.6-.6 0-1.4.3-2 .4l-2.4.6-1.5.3-2.5.5-2.3.5c-.9.2-1.3 1-1.3 1.8 0 .5.3 1.2.8 1.5.3.2 1.2.8 1.6.8l.8.6c.5.2 1.1 0 1.7 0l2.4-.5c2-.5 4-1 5.9-1.3 1.6-.3 3.2-1 4.9-1.3l-1 1.9L16 36l-.5 1.1c0 .3-.3.5-.3.8-.2.2-.5 1.3-.5 1.6-.2.1-.5.7-.5 1 0 .3-.3.4-.2.8-.3.2-.4.8-.6 1.1l-.7 1.8c-.3.5-.5 1.4-.9 1.8-.3.2-.4.7-.6 1-.2.4-.2 1-.7 1.3-.1 0 0 .3-.2.5l-.4.6c-.2.4-.6.7-.8 1.2-.1.2-.2 1 0 1.3.2.2.4.8.7.8.4.2 1 .2 1.4.5.5.4 1 .4 1.5.3.5-.1 1.1 0 1.7-.2.2 0 .5-.7.6-.8l.6-1 .4-1c0-.4.5-.7.6-1l.8-1.6.4-1 .4-.7 1-2.5c.3-.2.4-.8.5-1.2l.7-1.4c.3-.8.5-1.8 1-2.5l1.3-3.3 1.1-2.2c.5.4.7 1 1.1 1.2l.5.5c.3.2.4 0 .7.4.3.3.5.6.8.7.3.3.2.5.6.7.6.3 1 1 1.6 1.4l2.8 2.3c.4.3 1 .6 1.3 1 .2.5 1.2 1 1.7 1.2.4.4.9 1 1.3 1.2.3.2.7.8 1 .8 0 .3.3.3.4.3l.5.5c0 .2 1 .7 1.1.8l1.8 1c.4 0 2.3.4 2.4.2.6-.7 1.4 0 1.5-1 0-.5 1-.9.6-1.6 0-.3-.3-.2-.6-.3Z" fill="#000"></path><path d="m17.1 26.2-2.9.7c-.7.2-1.5.6-2.2.6-.6 0-1.4.3-2 .4l-2.4.6-1.5.3-2.5.5-2.3.5c-.9.2-1.3 1-1.3 1.8 0 .5.3 1.2.8 1.5.3.2 1.2.8 1.6.8l.8.6c.5.2 1.1 0 1.7 0l2.4-.5c2-.5 4-1 5.9-1.3 1.6-.3 3.2-1 4.9-1.3-.3.7-1.2-5.4-1-5.2Z" fill="#FF9011"></path><path d="M44.8 45.4c0-.2-.3-.4-.5-.5-.4-.4-1-1.3-1.2-1.2-.2-.3-.5-.3-.7-.5-.1-.2-.4-.4-.7-.4-.2-.3-.4-.5-.8-.7L36 38.3l-1-.7-1-1c-1-.4-1.7-1.2-2.5-1.8-.2-.3-.1-.5-.6-.7 0 0 0-.3-.2-.3-.2-.1-1-.5-1-.8 0-.3-.8-.7-1-.9-.1-.2-.5-.2-.7-.5l-.1-.4c-.2-.1-.4 0-.6-.2 2-.5-4 3.9-3.6 3.1.5.4.7 1 1.1 1.2l.5.5c.3.2.4 0 .7.4.3.3.5.6.8.7.3.3.2.5.6.7.6.3 1 1 1.6 1.4l2.8 2.3c.4.3 1 .6 1.3 1 .2.5 1.2 1 1.7 1.2.4.4.9 1 1.3 1.2.3.2.7.8 1 .8 0 .3.3.3.4.3l.5.5c0 .2 1 .7 1.1.8l1.8 1c.4 0 2.3.4 2.4.2.6-.7 1.4 0 1.5-1 0-.5 1-.9.6-1.6 0-.3-.3-.2-.6-.3Z" fill="#8A00C2"></path><path d="M19 31.4c-.2.7-.5 1.3-.9 1.9L17 36l-.5 1.1c0 .3-.3.5-.3.8-.2.2-.5 1.3-.5 1.6-.2.1-.5.7-.5 1 0 .3-.3.4-.2.8-.3.2-.4.8-.6 1.1l-.7 1.8c-.3.5-.5 1.4-.9 1.8-.3.2-.4.7-.6 1-.2.4-.2 1-.7 1.3-.1 0 0 .3-.2.5l-.4.6c-.2.4-.6.7-.8 1.2-.1.2-.2 1 0 1.3.2.2.4.8.7.8.4.2 1 .2 1.4.5.5.4 1 .4 1.5.3.5-.1 1.1 0 1.7-.2.2 0 .5-.7.6-.8l.6-1 .4-1c0-.4.5-.7.6-1l.8-1.6.4-1 .4-.7 1-2.5c.3-.2.4-.8.5-1.2l.7-1.4c.3-.8.5-1.8 1-2.5l1.3-3.3 1.1-2.2c.5.4-7.3-1.3-5.6-1.7Z" fill="#2CBF00"></path><path d="m27.3 29.2 5.8-1 3.7-.8c2-.4 4.2-1.2 6.3-1.3 1 0 1.5-1.2 1.6-2 0-.4-.1-.6-.3-1 0 0-.2-1.2-.6-.5-.1-.2.2-.3 0-.7 0-.3-.3-.4-.6-.4l-.6-.3-1.2-.3c-.8.1-1.6 0-2.3.4-.7.3-1.6.4-2.4.6l-2.2.6c-.7 0-1.4.4-2.1.4-.8 0-1.6.3-2.3.5-.6 0-1.3 0-2 .3 0-.2-.6 5.7-.8 5.5Z" fill="#1700FF"></path><path d="m28.5 23.5.5-1.1.5-1.3c0 .6.3-.6.3-.3l.3-.6c0-.4.2-.5.3-.8.2-.3.5-.9.5-1.2 0-.3.4-.7.6-1l.4-.8.9-1.8c.4-.5.6-1.4 1-1.9.2-.1.5-.7.5-.9 0-.2.3-.4.5-.6a34.3 34.3 0 0 0 2-4c.2-.1.3-.7.5-1l.5-1.2v-.5c.1-.1.4-.1.3-.4l.3-1.2c.2-.6.1-.8-.4-1.2-.3-.2-.5-.2-.6-.6 0-.1 0-.4-.2-.5-.2-.3-1-.3-1.3-.3-.5-.5-1.1-.2-1.7-.3-.2 0-.4.2-.5.4-.2.1-.4 0-.7.2-.6.3-.6.7-.9 1.4l-.8 2.7c-.5.4-.8 1.8-1.1 2.4-.1.2-.3.7-.5.8l-.1.4-.5.7-.5 1.1c0 .3-.5.8-.5 1.2-.2 0-.3.6-.3.8-.2.1-.6.7-.5.8-.1.4-.5.7-.6 1l-.2.7c-.2 0-.5.4-.5.6 0 .9-1 1.5-1 2.3l-.6 1a5 5 0 0 1-.4 1l-.6 1.1c-.2.4-.3 1-.5 1.2l-.5.8c-.1.3 6 1 6 .9Z" fill="red"></path><path d="M21 22.9c-.2-.3-.7-1-1-1.2-.2-.5-.8-.7-1-1 0-.3-.5-1-.8-1 .2-.1-1-1.4-1-1.4-.2-.7-.9-1.1-1.3-1.6l-2-2.5c-.3-.5-1.1-1-1.2-1.5 0-.4-.5-.3-.5-.6 0-.2-.3-.5-.5-.6-.2-.2-.7-.6-.8-1 0-.5-.9-.9-1.2-1.3C9.5 8.7 9.1 8 8.5 8s-.7-.5-1.4-.5c-1.4 0-3.4.6-3 2.4.1.8.7 1.3 1.2 1.8l1.5 1.7c.2.2.1.4.4.5l.9 1.1c.2.3.7 1.2 1.1 1.3l.7.9c.2.2.5.4.6.7 0 .3.2.1.3.3.2.3.5.9.8 1 0 .3.8 1.3 1 1.4.6.3.8 1 1.3 1.5.4.3.7.9 1 1.3.3.5.8 1 1.3 1.4 0 .3.2.5.4.6.2.3 4.7-2.2 4.5-2.5Z" fill="#FFF900"></path></g></svg>
</file>

<file path=".env.example">
# Replace with your DB credentials!
DATABASE_URL="postgres://user:password@host:port/db-name"
</file>

<file path=".gitignore">
node_modules

# Output
.output
.vercel
.netlify
.wrangler
/.svelte-kit
/build

# OS
.DS_Store
Thumbs.db

# Env
.env
.env.*
!.env.example
!.env.test

# Vite
vite.config.js.timestamp-*
vite.config.ts.timestamp-*

.dev.vars*
!.dev.vars.example
</file>

<file path=".groupedtimelineinclude">
# Files to track with Grouped Timeline
# Add patterns for files you want included in the Grouped Timeline
# Use ! to exclude files/folders (anti-patterns)
# After changing this file, refresh the Grouped Timeline view to see the updates

# Track all files by default (commented out because it might be slow for large projects)
# *
# */**

# Common exclusions
!node_modules/**
!dist/**
!out/**
!build/**
!.git/**
!coverage/**
!.next/**
!.cache/**
!tmp/**
!temp/**

# Exclude common large/binary files
!*/**.exe
!*/**.dll
!*/**.zip
!*/**.tar
!*/**.gz
!*/**.rar
!*/**.7z
!*/**.iso
!*/**.bin
!*/**.log
</file>

<file path=".npmrc">
engine-strict=true
</file>

<file path=".prettierignore">
# Package Managers
package-lock.json
pnpm-lock.yaml
yarn.lock
bun.lock
bun.lockb

# Miscellaneous
/static/
/drizzle/
</file>

<file path=".prettierrc">
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte", "prettier-plugin-tailwindcss"],
	"overrides": [
		{
			"files": "*.svelte",
			"options": {
				"parser": "svelte"
			}
		}
	],
	"tailwindStylesheet": "./src/app.css"
}
</file>

<file path="drizzle.config.ts">
import { defineConfig } from 'drizzle-kit';
import 'dotenv/config';

if (!process.env.DATABASE_URL) throw new Error('DATABASE_URL is not set');

export default defineConfig({
	schema: './src/lib/server/db/schema.ts',
	dialect: 'postgresql',
	dbCredentials: {
		url: process.env.DATABASE_URL
	},
	verbose: true,
	strict: true
});
</file>

<file path="README.md">
# sv

Everything you need to build a Svelte project, powered by [`sv`](https://github.com/sveltejs/cli).

## Creating a project

If you're seeing this, you've probably already done this step. Congrats!

```sh
# create a new project in the current directory
npx sv create

# create a new project in my-app
npx sv create my-app
```

## Developing

Once you've created a project and installed dependencies with `npm install` (or `pnpm install` or `yarn`), start a development server:

```sh
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open
```

## Building

To create a production version of your app:

```sh
npm run build
```

You can preview the production build with `npm run preview`.

> To deploy your app, you may need to install an [adapter](https://svelte.dev/docs/kit/adapters) for your target environment.
</file>

<file path="svelte.config.js">
import adapter from '@sveltejs/adapter-cloudflare';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://svelte.dev/docs/kit/integrations
	// for more information about preprocessors
	preprocess: vitePreprocess(),
	kit: { adapter: adapter() }
};

export default config;
</file>

<file path="tsconfig.json">
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true,
		"moduleResolution": "bundler",
		"types": [
			"./src/worker-configuration.d.ts"
		]
	}
	// Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
	// except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
	//
	// To make changes to top-level options such as include and exclude, we recommend extending
	// the generated config; see https://svelte.dev/docs/kit/configuration#typescript
}
</file>

<file path="vite.config.ts">
import tailwindcss from '@tailwindcss/vite';
import { defineConfig } from 'vitest/config';
import { sveltekit } from '@sveltejs/kit/vite';

export default defineConfig({
	plugins: [tailwindcss(), sveltekit()],
	test: {
		expect: { requireAssertions: true },
		projects: [
			{
				extends: './vite.config.ts',
				test: {
					name: 'client',
					environment: 'browser',
					browser: {
						enabled: true,
						provider: 'playwright',
						instances: [{ browser: 'chromium' }]
					},
					include: ['src/**/*.svelte.{test,spec}.{js,ts}'],
					exclude: ['src/lib/server/**'],
					setupFiles: ['./vitest-setup-client.ts']
				}
			},
			{
				extends: './vite.config.ts',
				test: {
					name: 'server',
					environment: 'node',
					include: ['src/**/*.{test,spec}.{js,ts}'],
					exclude: ['src/**/*.svelte.{test,spec}.{js,ts}']
				}
			}
		]
	}
});
</file>

<file path="vitest-setup-client.ts">
/// <reference types="@vitest/browser/matchers" />
/// <reference types="@vitest/browser/providers/playwright" />
</file>

<file path="wrangler.toml">
# This file configures your Cloudflare Pages project
name = "rushes"
compatibility_date = "2024-04-05" # Use a recent date

# This is the line that fixes the error
compatibility_flags = ["nodejs_compat"]
</file>

<file path="src/lib/components/MuxVideoPlayer.svelte">
<script lang="ts">
    import { onMount, onDestroy, tick } from "svelte";
    import "media-chrome";
    import "hls-video-element";
    import { uiState, actions } from "../stores/appStore";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import { getPlayerState } from "$lib/stores/playerStore.svelte";
    import { videosStore } from "$lib/stores/library";
    import VideoTimeline from "./VideoTimeline.svelte";

    const {
        src = "",
        autoplayUserPreference = true,
        startTime = 0,
        playerKey = "",
    } = $props();
    const playerState = getPlayerState();

    let player: (HTMLVideoElement & { load?: () => void }) | undefined;
    let isMuted = true;
    let isExpanded = $state(false);
    let isHovering = $state(false);
    let isPaused = $state(true);
    const playlist = $derived($videosStore);
    const currentVideoId = $derived($selectedVideo.id);
    const currentIndex = $derived(
        playlist.findIndex((video) => video.id === currentVideoId),
    );

    $effect(() => {
        const unsubscribe = uiState.subscribe((state) => {
            isExpanded = state.isExpanded;
        });
        return () => unsubscribe();
    });

    function handleVideoEnded() {
        // Advance to the next video in the queue
        selectedVideo.playNext();
    }

    function togglePlay(event: MouseEvent) {
        event.stopPropagation();
        if (!player) return;
        if (player.paused) {
            player.play().catch(() => {});
        } else {
            player.pause();
        }
    }

    function stepQueue(offset: number, event: MouseEvent) {
        event.stopPropagation();
        if (!playlist.length) return;
        const length = playlist.length;
        const base =
            currentIndex === -1 ? (offset > 0 ? 0 : length - 1) : currentIndex;
        const next = (base + offset + length) % length;
        const target = playlist[next];
        if (target) {
            selectedVideo.selectVideo(target.id);
            tick().then(() => {
                player?.play().catch((err) => {
                    console.warn("Autoplay was prevented.", err);
                });
            });
        }
    }

    function goPrevious(event: MouseEvent) {
        stepQueue(-1, event);
    }

    function goNext(event: MouseEvent) {
        stepQueue(1, event);
    }

    function toggleFullscreen(event: MouseEvent) {
        event.stopPropagation();
        const next = !isExpanded;
        actions.setExpanded(next);
        selectedVideo.setFullScreen(next);
    }

    async function attemptAutoplay() {
        if (!player || !autoplayUserPreference) return;
        try {
            await player.play();
        } catch {
            // Autoplay can be blocked silently; no-op fallback
        }
    }

    onMount(() => {
        if (player) {
            player.muted = isMuted;
            if (startTime > 0) {
                player.currentTime = startTime;
            }
            if (autoplayUserPreference) {
                attemptAutoplay();
            }

            // Listen for play/pause events to update state
            player.addEventListener("play", () => {
                isPaused = false;
            });
            player.addEventListener("pause", () => {
                isPaused = true;
            });
            player.addEventListener("ended", handleVideoEnded);
            player.addEventListener("canplay", attemptAutoplay);

            isPaused = player.paused;
        }
    });

    onDestroy(() => {
        if (player) {
            // Clean up event listener
            player.removeEventListener("ended", handleVideoEnded);
            player.removeEventListener("canplay", attemptAutoplay);
            player.pause();
            player.removeAttribute("src");
        }
    });

    function toggleMute() {
        if (!player) return;
        isMuted = !isMuted;
        player.muted = isMuted;
        if (!isMuted && player.paused) {
            player.play().catch(() => {
                // Play after unmute failed - browser restriction
            });
        }
    }

    $effect(() => {
        if (!player) return;

        if (!src) {
            player.removeAttribute("src");
            return;
        }

        const currentSrc = player.getAttribute("src");
        if (currentSrc !== src) {
            player.src = src;
            player.load?.();
            attemptAutoplay();
        }
    });

    // Listen for seek requests from the player store
    $effect(() => {
        if (!player) return;

        const seekTime = playerState.seekRequested;
        if (seekTime !== null && isFinite(seekTime)) {
            // Only seek if the difference is significant (more than 0.5 seconds)
            if (Math.abs(player.currentTime - seekTime) > 0.5) {
                player.currentTime = seekTime;
            }
        }
    });

    $effect(() => {
        if (!player) return;
        if (!Number.isFinite(startTime)) return;
        const difference = Math.abs(player.currentTime - startTime);
        if (difference > 0.75) {
            player.currentTime = startTime;
        }
    });
</script>

<div
    class="video relative block"
    id="player-container"
    on:mouseenter={() => (isHovering = true)}
    on:mouseleave={() => (isHovering = false)}
>
    <div class="video-container absolute inset-0 bg-black overflow-hidden">
        <media-controller class="absolute inset-0">
            <hls-video
                slot="media"
                crossorigin="anonymous"
                playsinline
                autoplay
                muted
                bind:this={player}
            ></hls-video>
            <media-loading-indicator slot="centered-chrome" noautohide
            ></media-loading-indicator>
        </media-controller>
    </div>

    <!-- Hover controls overlay -->
    <div
        class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent opacity-0 transition-opacity duration-200 pointer-events-none {isHovering
            ? 'opacity-100'
            : ''}"
    >
        <!-- Fullscreen button in top-right corner -->
        <div class="absolute top-4 right-4 pointer-events-auto z-10">
            <button
                on:click={toggleFullscreen}
                aria-label={isExpanded ? "Shrink player" : "Expand player"}
                class="control-button"
                title={isExpanded ? "Shrink player" : "Expand player"}
            >
                {#if !isExpanded}
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="20"
                        height="20"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M1 1h5v1H2v4H1V1zm9 0h5v5h-1V2h-4V1zm5 9v5h-5v-1h4v-4h1zM6 14v1H1v-5h1v4h4z"
                        />
                    </svg>
                {:else}
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="20"
                        height="20"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                    >
                        <path
                            d="M5.828 10.172a.5.5 0 0 0-.707 0l-4.096 4.096V11.5a.5.5 0 0 0-1 0v3.975a.5.5 0 0 0 .5.5H4.5a.5.5 0 0 0 0-1H1.732l4.096-4.096a.5.5 0 0 0 0-.707zm4.344 0a.5.5 0 0 1 .707 0l4.096 4.096V11.5a.5.5 0 1 1 1 0v3.975a.5.5 0 0 1-.5.5H11.5a.5.5 0 0 1 0-1h2.768l-4.096-4.096a.5.5 0 0 1 0-.707zm0-4.344a.5.5 0 0 0 .707 0l4.096-4.096V4.5a.5.5 0 1 0 1 0V.525a.5.5 0 0 0-.5-.5H11.5a.5.5 0 0 0 0 1h2.768l-4.096 4.096a.5.5 0 0 0 0 .707zm-4.344 0a.5.5 0 0 1-.707 0L1.025 1.732V4.5a.5.5 0 0 1-1 0V.525a.5.5 0 0 1 .5-.5H4.5a.5.5 0 0 1 0 1H1.732l4.096 4.096a.5.5 0 0 1 0 .707z"
                        />
                    </svg>
                {/if}
            </button>
        </div>

        <!-- Bottom controls area with timeline and playback controls -->
        <div class="absolute bottom-0 left-0 right-0 pointer-events-auto">
            <!-- Timeline overlay at the bottom -->
            <div class="video-timeline-overlay px-6 pb-6">
                <VideoTimeline />
            </div>

            <!-- Playback controls centered above timeline -->
            <div
                class="flex hidden items-center justify-center gap-4 pb-4 px-6"
            >
                <!-- Previous button -->
                <button
                    on:click={goPrevious}
                    aria-label="Previous video"
                    class="control-button"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="20"
                        height="20"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                    >
                        <path d="M15 18 9 12l6-6v12zm-6 0H7V6h2v12z" />
                    </svg>
                </button>

                <!-- Play/Pause button -->
                <button
                    on:click={togglePlay}
                    aria-label={isPaused ? "Play" : "Pause"}
                    class="control-button-large"
                >
                    {#if isPaused}
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="32"
                            height="32"
                            viewBox="0 0 24 24"
                            fill="currentColor"
                        >
                            <path d="M8 5v14l11-7z" />
                        </svg>
                    {:else}
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="32"
                            height="32"
                            viewBox="0 0 24 24"
                            fill="currentColor"
                        >
                            <path d="M6 4h4v16H6zm8 0h4v16h-4z" />
                        </svg>
                    {/if}
                </button>

                <!-- Next button -->
                <button
                    on:click={goNext}
                    aria-label="Next video"
                    class="control-button"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="20"
                        height="20"
                        viewBox="0 0 24 24"
                        fill="currentColor"
                    >
                        <path d="m9 18 6-6-6-6v12zm6 0h2V6h-2v12z" />
                    </svg>
                </button>
            </div>
        </div>
    </div>
</div>

<style>
    .video {
        display: block;
        width: 100%;
        height: 100%;
    }
    .video-container {
        cursor: default;
        object-fit: cover;
        width: 100%;
        height: 100%;
        position: absolute;
        inset: 0;
    }

    .control-button {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: none;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(8px);
        color: white;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .control-button:hover {
        background: rgba(0, 0, 0, 0.8);
        transform: scale(1.1);
    }

    .control-button-large {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 64px;
        height: 64px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.3);
        background: rgba(0, 0, 0, 0.7);
        backdrop-filter: blur(8px);
        color: white;
        transition: all 0.2s ease;
        cursor: pointer;
    }

    .control-button-large:hover {
        background: rgba(233, 149, 12, 0.9);
        border-color: rgba(233, 149, 12, 1);
        transform: scale(1.1);
    }

    .video-timeline-overlay {
        background: linear-gradient(to top, rgba(0, 0, 0, 0.8) 0%, rgba(0, 0, 0, 0.5) 60%, transparent 100%);
        padding-top: 1rem;
    }

    /* Override VideoTimeline padding when used in overlay */
    .video-timeline-overlay :global(.px-8) {
        padding-left: 0;
        padding-right: 0;
    }

    /* Make timeline text readable on dark overlay */
    .video-timeline-overlay :global(.text-gray-700),
    .video-timeline-overlay :global(.text-gray-200) {
        color: rgba(255, 255, 255, 0.9) !important;
    }
    :global(media-controller) {
        --media-primary-color: lightpink;
        --media-secondary-color: rgb(27 54 93 / 0.85);
        --media-control-hover-background: rgb(128 0 0 / 0.85);
        --media-object-fit: cover;
        --media-object-position: center;
        object-fit: cover;
        width: 100%;
        height: 100%;
    }
    :global(media-controller) {
        position: absolute;
        inset: 0;
    }
    :global(media-controller [slot="media"]),
    :global(hls-video) {
        width: 100% !important;
        height: 100% !important;
        object-fit: cover;
    }
    .mute-toggle-button:hover {
        transform: scale(1.05);
    }
    :global(media-controller) {
        --media-control-background: transparent;
        --media-control-hover-background: rgba(0, 0, 0, 0.5);
        --media-control-active-background: rgba(0, 0, 0, 0.7);
        --media-control-color: white;
        --media-control-hover-color: white;
        --media-control-active-color: white;
        --media-control-border-radius: 4px;
        --media-control-padding: 8px;
        --media-control-margin: 4px;
        --media-control-font-size: 14px;
        --media-control-font-weight: 500;
        --media-control-letter-spacing: 0.5px;
        --media-control-text-transform: none;
        --media-control-text-decoration: none;
        --media-control-text-shadow: none;
        --media-control-box-shadow: none;
        --media-control-transition: all 0.2s ease;
    }
    :global(media-control-bar) {
        background: linear-gradient(transparent, rgba(0, 0, 0, 0.7));
        padding: 8px;
    }
    :global(media-progress-bar) {
        --media-progress-bar-height: 4px;
        --media-progress-bar-background: rgba(255, 255, 255, 0.3);
        --media-progress-bar-fill-background: white;
    }
    :global(media-volume-range) {
        --media-range-track-height: 4px;
        --media-range-track-background: rgba(255, 255, 255, 0.3);
        --media-range-track-fill-background: white;
    }
</style>
</file>

<file path="src/lib/components/Sidebar.svelte">
<script lang="ts">
    import { slide } from "svelte/transition";
    import { onMount, tick } from "svelte";
    import { page } from "$app/stores";
    // FIXED: This is the correct import for the component API you are using
    import { Tooltip } from "bits-ui";

    interface Props {
        isOpen?: boolean;
        onclose?: () => void;
    }

    let { isOpen = false, onclose }: Props = $props();

    function closeMobileSidebar() {
        onclose?.();
    }

    // REFACTORED: Added "Live" link to the navLinks array
    const navLinks = [
        { href: "/", label: "Home", icon: "live" },
        // { href: "/live", label: "Live", icon: "play" },
        { href: "/map", label: "Map", icon: "map" },
        { href: "/browse", label: "Browse", icon: "browse" },
        { href: "/account", label: "Upload", icon: "account" },
        { href: "/faq", label: "FAQ", icon: "faq" },
    ] as const;

    // --- State for Highlight Logic ---
    let navContainer = $state<HTMLDivElement | null>(null);
    let highlightContainer = $state<HTMLDivElement | null>(null);
    // REMOVED: liveLinkRef is no longer needed
    // let liveLinkRef = $state<HTMLAnchorElement | null>(null);

    // This array will now be 5 elements long, and navRefs[0] will be the "Live" link
    let navRefs: Array<HTMLAnchorElement | null> = $state(
        new Array(navLinks.length).fill(null),
    );
    let highlightY = $state(0);
    let highlightX = $state(0);
    let highlightWidth = $state(0);
    let highlightHeight = $state(0);
    let highlightVisible = $state(false);
    let highlightPulse = $state(false);
    let highlightElement: HTMLDivElement | null = null;
    let resizeHandler: (() => void) | null = null;

    function routeMatches(href: string | null, currentPath: string): boolean {
        if (!href) return false;
        return currentPath === href || currentPath.startsWith(`${href}/`);
    }

    async function refreshHighlight(currentPath: string) {
        await tick();
        if (!highlightContainer) {
            highlightVisible = false;
            return;
        }

        let target: HTMLElement | null = null;

        const activeIndex = navLinks.findIndex((link) =>
            routeMatches(link.href, currentPath),
        );
        if (activeIndex !== -1) {
            const candidate = navRefs[activeIndex];
            if (candidate instanceof HTMLElement) {
                target = candidate;
            }
        }

        if (!target) {
            highlightVisible = false;
            return;
        }

        const containerRect = highlightContainer.getBoundingClientRect();
        const targetRect = target.getBoundingClientRect();

        // UPDATED: Use the target's width and left directly.
        // Since the target <a> is h-12 w-12, this will result in a square.
        let width = targetRect.width;
        let left = targetRect.left - containerRect.left;

        // REMOVED: The block that calculated width based on the inner icon is gone.

        highlightY = targetRect.top - containerRect.top;
        highlightX = left;
        highlightWidth = width;
        highlightHeight = targetRect.height; // height will equal width (h-12)
        const isVisible = highlightHeight > 0 && highlightWidth > 0;

        if (!isVisible) {
            highlightVisible = false;
            highlightPulse = false;
            return;
        }

        highlightVisible = true;
        highlightPulse = false;
        await tick();
        highlightPulse = true;
    }

    onMount(() => {
        const handleResize = () => {
            refreshHighlight($page.url.pathname);
        };
        window.addEventListener("resize", handleResize);
        resizeHandler = handleResize;

        return () => {
            if (resizeHandler) {
                window.removeEventListener("resize", resizeHandler);
                resizeHandler = null;
            }
        };
    });

    // REFACTORED: Removed dependency on liveLinkRef
    $effect(() => {
        const path = $page.url.pathname;
        highlightContainer;
        navRefs.forEach((ref) => ref);
        refreshHighlight(path);
    });

    const icons = {
        home: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M3 9.75L12 3l9 6.75V21a.75.75 0 01-.75.75H15a.75.75 0 01-.75-.75v-4.5a.75.75 0 00-.75-.75h-3a.75.75 0 00-.75.75V21a.75.75 0 01-.75.75H3.75A.75.75 0 013 21V9.75z"/></svg>`,
        map: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M9 3.75l6 2.5 6-2.5v14.5l-6 2.5-6-2.5-6 2.5V6.25l6-2.5zM9 3.75v14.5m6-12v14.5"/></svg>`,
        play: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M5.25 5.653c0-.856.917-1.398 1.667-.986l11.54 6.348a1.125 1.125 0 010 1.971l-11.54 6.347c-.75.412-1.667-.13-1.667-.986V5.653z" /></svg>`,
        browse: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Tabler Icons by Paweł Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE --><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 15a4 4 0 1 0 8 0a4 4 0 1 0-8 0m7.5 3.5L21 21M4 6h16M4 12h4m-4 6h4"/></svg>`,
        users: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M16 7a4 4 0 11-8 0 4 4 0 018 0z"/><path stroke-linecap="round" stroke-linejoin="round" d="M6.5 21a5.5 5.5 0 0111 0M19.5 8.25a2.25 2.25 0 110 4.5M21 21a3 3 0 00-4-2.82"/></svg>`,
        account: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from HeroIcons by Refactoring UI Inc - https://github.com/tailwindlabs/heroicons/blob/master/LICENSE --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5"><path d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87q.11.06.22.127c.325.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 0 1 1.37.49l1.296 2.247a1.125 1.125 0 0 1-.26 1.431l-1.003.827c-.293.241-.438.613-.43.992a8 8 0 0 1 0 .255c-.008.378.137.75.43.991l1.004.827c.424.35.534.955.26 1.43l-1.298 2.247a1.125 1.125 0 0 1-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a7 7 0 0 1-.22.128c-.331.183-.581.495-.644.869l-.213 1.281c-.09.543-.56.94-1.11.94h-2.594c-.55 0-1.019-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a7 7 0 0 1-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 0 1-1.369-.49l-1.297-2.247a1.125 1.125 0 0 1 .26-1.431l1.004-.827c.292-.24.437-.613.43-.991a7 7 0 0 1 0-.255c.007-.38-.138-.751-.43-.992l-1.004-.827a1.125 1.125 0 0 1-.26-1.43l1.297-2.247a1.125 1.125 0 0 1 1.37-.491l1.216.456c.356.133.751.072 1.076-.124q.108-.066.22-.128c.332-.183.582-.495.644-.869z"/><path d="M15 12a3 3 0 1 1-6 0a3 3 0 0 1 6 0"/></g></svg>`,
        upload: `<svg class="h-5 w-5" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16.5v1.25A2.25 2.25 0 006.25 20h11.5A2.25 2.25 0 0020 17.75V16.5M8.75 9.75L12 6.5l3.25 3.25M12 6.5v9.75"/></svg>`,
        faq: `<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24"><!-- Icon from Tabler Icons by Paweł Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE --><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2"><path d="M19.875 6.27c.7.398 1.13 1.143 1.125 1.948v7.284c0 .809-.443 1.555-1.158 1.948l-6.75 4.27a2.27 2.27 0 0 1-2.184 0l-6.75-4.27A2.23 2.23 0 0 1 3 15.502V8.217c0-.809.443-1.554 1.158-1.947l6.75-3.98a2.33 2.33 0 0 1 2.25 0l6.75 3.98zM12 16v.01"/><path d="M12 13a2 2 0 0 0 .914-3.782a1.98 1.98 0 0 0-2.414.483"/></g></svg>`,
    } satisfies Record<string, string>;
</script>

<Tooltip.Provider delayDuration={100}>
    <aside
        class="hidden z-100 lg:flex lg:w-20 lg:flex-col transition-all duration-300 ease-in-out overflow-visible"
    >
        <div
            class="sidebar-shell relative flex flex-1 flex-col overflow-y-auto overflow-x-visible border-r border-white/10 bg-white/[0.02] backdrop-blur-md shadow-[0_32px_120px_-45px_rgba(15,23,42,0.9)]"
            bind:this={highlightContainer}
        >
            <div
                bind:this={highlightElement}
                class="nav-highlight"
                class:visible={highlightVisible}
                style={`--highlight-x: ${highlightX}px; --highlight-y: ${highlightY}px; height: ${highlightHeight}px; width: ${highlightWidth}px;`}
            >
                <div
                    class="nav-highlight-inner"
                    class:animate={highlightPulse}
                    on:animationend={() => {
                        highlightPulse = false;
                    }}
                ></div>
            </div>

            <nav class="mt-6 flex-1 flex justify-center px-4">
                <div class="space-y-1 nav-list" bind:this={navContainer}>
                    {#each navLinks as link, index}
                        <Tooltip.Root>
                            <Tooltip.Trigger asChild>
                                <a
                                    href={link.href}
                                    bind:this={navRefs[index]}
                                    class="nav-item flex h-10 w-10 items-center justify-center rounded-xl transition {link.icon ===
                                    'live'
                                        ? 'logo-link mb-10 '
                                        : 'text-white/70 hover:bg-white/10 hover:text-white'}"
                                    class:active={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )}
                                    aria-label={link.label}
                                    aria-current={routeMatches(
                                        link.href,
                                        $page.url.pathname,
                                    )
                                        ? "page"
                                        : undefined}
                                >
                                    {#if link.icon === "live"}

                                    
                                        <span
                                            class="logo-mark"
                                            aria-hidden="true"
                                        >
                                            <span
                                                class="logo-bar logo-bar--long"
                                            ></span>
                                            <span
                                                class="logo-bar logo-bar--medium"
                                            ></span>
                                         
                                            <span
                                                class="logo-bar logo-bar--short"
                                            ></span>
                                        </span>
                                    {:else}
                                        <span
                                            class="nav-icon text-white/80"
                                            aria-hidden="true"
                                            >{@html icons[link.icon]}</span
                                        >
                                    {/if}
                                </a>
                            </Tooltip.Trigger>

                            <Tooltip.Portal>
                                <Tooltip.Content
                                    side="right"
                                    align="center"
                                    sideOffset={3}
                                    class="tooltip-content"
                                >
                                    {link.label}
                                </Tooltip.Content>
                            </Tooltip.Portal>
                        </Tooltip.Root>
                    {/each}
                </div>
            </nav>
        </div>
    </aside>
</Tooltip.Provider>

<div class="lg:hidden">
    {#if isOpen}
        <aside
            class="fixed top-0 left-0 h-full w-64 bg-white dark:bg-black border-r border-gray-300 z-50"
            transition:slide={{ duration: 200, axis: "x" }}
        >
            <div class="flex flex-col flex-grow pt-5 pb-4 overflow-y-auto">
                <div
                    class="flex items-center justify-between flex-shrink-0 px-4"
                >
                    <h1
                        class="text-xl font-bold tracking-wider text-gray-900 dark:text-white"
                    >
                        RUSHES
                    </h1>
                    <button
                        on:click={closeMobileSidebar}
                        class="p-2 hover:bg-gray-100 dark:hover:bg-gray-900 rounded transition-colors"
                        aria-label="Close menu"
                    >
                        <svg
                            class="h-5 w-5 text-gray-900 dark:text-white"
                            fill="none"
                            stroke="currentColor"
                            viewBox="0 0 24 24"
                        >
                            <path
                                stroke-linecap="round"
                                stroke-linejoin="round"
                                stroke-width="2"
                                d="M6 18L18 6M6 6l12 12"
                            />
                        </svg>
                    </button>
                </div>
                <nav class="mt-8 flex-1 px-4 space-y-1">
                    {#each navLinks as link}
                        <a
                            href={link.href}
                            class="group flex items-center px-2 py-2 text-sm font-medium rounded-md text-gray-900 dark:text-white hover:bg-gray-100 dark:hover:bg-gray-900 transition-colors"
                            on:click={closeMobileSidebar}
                        >
                            {#if link.icon === "live"}
                                <span class="mr-3 h-5 w-5" aria-hidden="true">
                                    <span class="logo-mark !h-5 !w-5">
                                        <span
                                            class="logo-bar logo-bar--long bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--medium bg-gray-900 dark:bg-white"
                                        ></span>
                                        <span
                                            class="logo-bar logo-bar--short bg-gray-900 dark:bg-white"
                                        ></span>
                                    </span>
                                </span>
                            {:else}
                                <span
                                    class="mr-3 h-5 w-5 text-gray-900 dark:text-white"
                                    aria-hidden="true"
                                    >{@html icons[link.icon]}</span
                                >
                            {/if}
                            {link.label}
                        </a>
                    {/each}
                </nav>
            </div>
        </aside>
    {/if}
</div>

<style>
    .logo-mark {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 0.2rem;
        width: 1.5rem;
        height: 1.5rem;
    }

    .logo-bar {
        width: 0.2rem;
        border-radius: 9999px;
        background: white;
    }

    .logo-bar--long {
        height: 1.15rem;
    }

    .logo-bar--medium {
        height: 0.8rem;
    }

    .logo-bar--short {
        height: 0.5rem;
    }

    .logo-bar--circle {
        width: 0.4rem;
        height: 0.4rem;
        border-radius: 9999px;
        background: white;
    }

    .sidebar-shell {
        overflow-x: visible;
        overflow-y: auto;
    }

    .nav-list {
        position: relative;
        overflow: visible;
    }

    .nav-item {
        position: relative;
    }

    .nav-item.active {
        color: #f8fafc;
    }

    .nav-icon :global(svg) {
        display: block;
        height: 1.25rem;
        width: 1.25rem;
    }

    /* FIXED: Removed :global() and set z-index properly */
    :global(.tooltip-content) {
        background: rgba(255, 255, 255, 0.2);
        font-family: sans-serif;
        color: #f8fafc;
        padding: 0.35rem 0.6rem;
        border-radius: 0.55rem;
        font-size: 0.7rem;
        letter-spacing: 0.08em;
        white-space: nowrap;
        box-shadow: 0 18px 35px -24px rgba(15, 23, 42, 0.88);
        display: inline-flex;
        align-items: center;
        gap: 0.25rem;
        z-index: 9999999;
    }

    /* Added style for tooltip arrow */
    .tooltip-arrow {
        fill: rgba(15, 23, 42, 0.92);
    }

    .nav-highlight {
        position: absolute;
        left: 0;
        top: 0;

        border-radius: 10px;
        pointer-events: none;
        z-index: -1;
        transform: translate3d(var(--highlight-x, 0), var(--highlight-y, 0), 0);
        transition:
            transform 0.32s cubic-bezier(0.28, 0.94, 0.38, 1),
            height 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            width 0.22s cubic-bezier(0.3, 0.95, 0.4, 1),
            opacity 0.16s ease;
        opacity: 0;
    }

    .nav-highlight.visible {
        opacity: 1;
    }

    .nav-highlight-inner {
        position: absolute;
        inset: 0;
        border-radius: 10px;
        background: rgba(255, 255, 255, 0.18);
        transition: opacity 0.16s ease;
        opacity: 0.9;

        transform-origin: center;
    }

    .nav-highlight-inner.animate {
        animation: highlight-bounce 0.5s cubic-bezier(0.24, 1.58, 0.36, 1)
            forwards;
    }

    @keyframes highlight-bounce {
        0% {
            transform: scale(0.88);
        }
        45% {
            transform: scale(1.08);
        }
        70% {
            transform: scale(0.97);
        }
        100% {
            transform: scale(1);
        }
    }

    .nav-list a.active {
        color: orange;
    }

    .nav-list a.active span:first-child {
        color: orange;
    }

    a.active .logo-bar {
        background: orange !important;
    }
</style>
</file>

<file path="src/lib/components/VideoInfo.svelte">
<script lang="ts">
    import Map from "$lib/components/Map.svelte";
    import { getCommentsByVideoId } from "$lib/data/comments";
    import { videosStore } from "$lib/stores/library";
    import type { Video, Comment } from "$lib/types/content";
    import { goto } from "$app/navigation";

    interface VideoData {
        video: Video;
    }

    let { data } = $props<{ data: VideoData }>();

    // Use locations provided by the video record
    const dummyLocations = data.video.locations ?? [];

    const primaryLocation = dummyLocations[0];
    const initialCenterLat =
        primaryLocation?.latitude ??
        primaryLocation?.mapLat ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[0]
            : undefined) ??
        0;
    const initialCenterLon =
        primaryLocation?.longitude ??
        primaryLocation?.mapLon ??
        (Array.isArray(primaryLocation?.coordinates)
            ? primaryLocation?.coordinates[1]
            : undefined) ??
        0;
    const initialZoom = primaryLocation ? 8 : 2;

    // Row expand states
    let isSummaryOpen = $state(false);
    let isKeywordsOpen = $state(true);
    let isLocationOpen = $state(true);
    let isTranscriptOpen = $state(false);

    // Location name from reverse geocoding
    let locationName = $state<string | null>(null);

    // Get comments for this video
    const comments = getCommentsByVideoId(data.video.id);

    // Format upload date
    function formatUploadDate(date: string): string {
        const uploadDate = new Date(date);
        const now = new Date();
        const diffTime = Math.abs(now.getTime() - uploadDate.getTime());
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) return "Today";
        if (diffDays === 1) return "Yesterday";
        if (diffDays < 7) return `${diffDays} days ago`;
        if (diffDays < 30) return `${Math.floor(diffDays / 7)} weeks ago`;
        if (diffDays < 365) return `${Math.floor(diffDays / 30)} months ago`;
        return `${Math.floor(diffDays / 365)} years ago`;
    }

    // Format full date with time
    function formatFullDateWithTime(date: string): string {
        const uploadDate = new Date(date);
        const dateStr = uploadDate.toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
        });
        const timeStr = uploadDate.toLocaleTimeString("en-US", {
            hour: "numeric",
            minute: "2-digit",
            hour12: true,
        });
        return `${dateStr} at ${timeStr}`;
    }

    // Format date as slug for URL (YYYY-MM-DD)
    function getDateSlug(date: string): string {
        const uploadDate = new Date(date);
        const year = uploadDate.getFullYear();
        const month = String(uploadDate.getMonth() + 1).padStart(2, "0");
        const day = String(uploadDate.getDate()).padStart(2, "0");
        return `${year}-${month}-${day}`;
    }

    // Determine if video was created during day or night (6 AM - 6 PM = day)
    function isDayTime(date: string): boolean {
        const uploadDate = new Date(date);
        const hour = uploadDate.getHours();
        return hour >= 6 && hour < 18;
    }

    const uploadDateStr =
        data.video.uploadDate ||
        data.video.timestamp ||
        new Date().toISOString();
    const isDay = isDayTime(uploadDateStr);

    // Convert keyword to URL slug
    function keywordToSlug(keyword: string): string {
        return keyword
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "-")
            .replace(/^-+|-+$/g, "");
    }

    // Reverse geocoding to get location name
    async function fetchLocationName(lat: number, lon: number) {
        if (!lat || !lon) return;
        try {
            const response = await fetch(
                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10&addressdetails=1`,
                {
                    headers: {
                        "User-Agent": "Rushes Video App",
                    },
                },
            );
            const data = await response.json();
            if (data.address) {
                // Try to get city, then town, then village, then region
                const city =
                    data.address.city ||
                    data.address.town ||
                    data.address.village ||
                    data.address.municipality;
                const region = data.address.state || data.address.region;
                if (city && region) {
                    locationName = `${city}, ${region}`;
                } else if (city) {
                    locationName = city;
                } else if (region) {
                    locationName = region;
                } else {
                    locationName = data.address.country || "Unknown location";
                }
            }
        } catch (error) {
            console.warn("Failed to fetch location name:", error);
        }
    }

    // Fetch location name when component loads or location changes
    $effect(() => {
        if (dummyLocations.length > 0 && initialCenterLat !== 0 && initialCenterLon !== 0) {
            fetchLocationName(initialCenterLat, initialCenterLon);
        }
    });
</script>

<div class="w-full transition-colors" style="font-family: Arial, Helvetica, sans-serif;">
    <div class=" px-8">
        <div class="space-y-0">
            <!-- Author Row -->
            <div class="border-b border-white/10 py-3">
                <div class="flex items-center gap-2">
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                        class="text-white/70"
                    >
                        <path
                            d="M8 8a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm2-3a2 2 0 1 1-4 0 2 2 0 0 1 4 0zm4 8c0 1-1 1-1 1H3s-1 0-1-1 1-4 6-4 6 3 6 4zm-1-.004c-.001-.246-.154-.986-.832-1.664C11.516 10.68 10.289 10 8 10c-2.29 0-3.516.68-4.168 1.332-.678.678-.83 1.418-.832 1.664h10z"
                        />
                    </svg>
                    <span class="text-sm font-medium text-white/90">Author</span>
                    <a
                        href={`/users/${data.video.authorId}`}
                        class="text-sm text-white/70 hover:text-white transition-colors ml-auto"
                    >
                        {data.video.author}
                    </a>
                </div>
            </div>

            <!-- Date Row with Day/Night -->
            <div class="border-b border-white/10 py-3">
                <div class="flex items-center gap-2">
                    <!-- Calendar icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" class="w-4 h-4" viewBox="0 0 24 24"><!-- Icon from Tabler Icons by Paweł Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE --><path fill="currentColor" d="M12 19a1 1 0 0 1 .993.883L13 20v1a1 1 0 0 1-1.993.117L11 21v-1a1 1 0 0 1 1-1m6.313-2.09l.094.083l.7.7a1 1 0 0 1-1.32 1.497l-.094-.083l-.7-.7a1 1 0 0 1 1.218-1.567zm-11.306.083a1 1 0 0 1 .083 1.32l-.083.094l-.7.7a1 1 0 0 1-1.497-1.32l.083-.094l.7-.7a1 1 0 0 1 1.414 0M4 11a1 1 0 0 1 .117 1.993L4 13H3a1 1 0 0 1-.117-1.993L3 11zm17 0a1 1 0 0 1 .117 1.993L21 13h-1a1 1 0 0 1-.117-1.993L20 11zM6.213 4.81l.094.083l.7.7a1 1 0 0 1-1.32 1.497l-.094-.083l-.7-.7A1 1 0 0 1 6.11 4.74zm12.894.083a1 1 0 0 1 .083 1.32l-.083.094l-.7.7a1 1 0 0 1-1.497-1.32l.083-.094l.7-.7a1 1 0 0 1 1.414 0M12 2a1 1 0 0 1 .993.883L13 3v1a1 1 0 0 1-1.993.117L11 4V3a1 1 0 0 1 1-1m0 5a5 5 0 1 1-4.995 5.217L7 12l.005-.217A5 5 0 0 1 12 7"/></svg>
                  
                    <span class="text-sm font-medium text-white/90">Date</span>
                    <a
                        href="/date/{getDateSlug(uploadDateStr)}"
                        class="text-sm text-white/70 hover:text-white transition-colors ml-auto"
                    >
                        {formatFullDateWithTime(uploadDateStr)}
                    </a>
                </div>
            </div>

            <!-- Summary Row -->
            <div class="border-b border-white/10">
                <button
                    onclick={() => (isSummaryOpen = !isSummaryOpen)}
                    class="w-full py-3 flex items-center gap-2 hover:bg-white/5 transition-colors"
                >
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" class="w-4 h-4"   viewBox="0 0 24 24"><!-- Icon from Tabler Icons by Paweł Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE --><path fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h10M4 18h14"/></svg>
                    <span class="text-sm font-medium text-white/90">Summary</span>
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="14"
                        height="14"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                        class="text-white/70 ml-auto transition-transform {isSummaryOpen
                            ? 'rotate-45'
                            : ''}"
                    >
                        <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
                    </svg>
                </button>
                {#if isSummaryOpen}
                    <div class="pb-3 ">
                        {#if data.video.description}
                            <p class="text-sm text-white/70 leading-relaxed">
                                {data.video.description}
                            </p>
                        {:else}
                            <p class="text-sm text-white/50">
                                No description available.
                            </p>
                        {/if}
                    </div>
                {/if}
            </div>

            <!-- Keywords Row -->
            <div class="border-b border-white/10">
                <button
                    onclick={() => (isKeywordsOpen = !isKeywordsOpen)}
                    class="w-full py-3 flex items-center gap-2 hover:bg-white/5 transition-colors"
                >
                <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" class="w-4 h-4" viewBox="0 0 24 24"><!-- Icon from Tabler Icons by Paweł Kuna - https://github.com/tabler/tabler-icons/blob/master/LICENSE --><g fill="currentColor"><path d="M9.172 5a3 3 0 0 1 2.121.879l5.71 5.71a3.41 3.41 0 0 1 0 4.822l-3.592 3.592a3.41 3.41 0 0 1-4.822 0l-5.71-5.71A3 3 0 0 1 2 12.172V8a3 3 0 0 1 3-3zM7 9h-.01A1 1 0 1 0 7 11a1 1 0 0 0 0-2"/><path d="M14.293 5.293a1 1 0 0 1 1.414 0L20.3 9.885a5.82 5.82 0 0 1 0 8.23l-1.592 1.592a1 1 0 0 1-1.414-1.414l1.592-1.592a3.82 3.82 0 0 0 0-5.402l-4.592-4.592a1 1 0 0 1 0-1.414"/></g></svg>
                    <span class="text-sm font-medium text-white/90">Keywords</span>
                    <div class="flex items-center gap-2 ml-auto">
                        {#if (data.video.keywords ?? []).length > 0}
                            <span class="text-xs text-white/50">
                                {(data.video.keywords ?? []).length} keyword{(data.video.keywords ?? []).length === 1
                                    ? ""
                                    : "s"}
                            </span>
                        {/if}
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                            class="text-white/70 transition-transform {isKeywordsOpen
                                ? 'rotate-45'
                                : ''}"
                        >
                            <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
                        </svg>
                    </div>
                </button>
                {#if isKeywordsOpen}
                    <div class="pb-3 ">
                        {#if (data.video.keywords ?? []).length > 0}
                            <div class="flex flex-wrap gap-2">
                                    {#each data.video.keywords ?? [] as keyword}
                                        <a
                                            href="/browse/{keywordToSlug(keyword)}"
                                            class="px-3 py-1 text-sm border border-white/20 hover:bg-white/20 text-neutral-300 text-xs rounded-full transition-colors"
                                        >
                                        {keyword}
                                    </a>
                                {/each}
                            </div>
                        {:else}
                            <p class="text-sm text-white/50">
                                No keywords available.
                            </p>
                        {/if}
                    </div>
                {/if}
            </div>

            <!-- Location Row -->
            <div class="border-b border-white/10">
                <button
                    onclick={() => (isLocationOpen = !isLocationOpen)}
                    class="w-full py-3 flex items-center gap-3 hover:bg-white/5 transition-colors"
                >
                    <svg
                        xmlns="http://www.w3.org/2000/svg"
                        width="16"
                        height="16"
                        fill="currentColor"
                        viewBox="0 0 16 16"
                        class="text-white/70"
                    >
                        <path
                            d="M8 16s6-5.686 6-10A6 6 0 0 0 2 6c0 4.314 6 10 6 10zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6z"
                        />
                    </svg>
                    <span class="text-sm font-medium text-white/90">Location</span>
                    <div class="flex items-center gap-2 ml-auto">
                        {#if dummyLocations.length > 0}
                            <a
                                href={`/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`}
                                class="text-xs text-white/70 hover:text-white transition-colors cursor-pointer"
                                onclick={(e) => {
                                    e.stopPropagation();
                                }}
                            >
                                {locationName || `${initialCenterLat.toFixed(4)}, ${initialCenterLon.toFixed(4)}`}
                            </a>
                        {:else}
                            <span class="text-xs text-white/50">No location</span>
                        {/if}
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                            class="text-white/70 transition-transform {isLocationOpen
                                ? 'rotate-45'
                                : ''}"
                        >
                            <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
                        </svg>
                    </div>
                </button>
                {#if isLocationOpen}
                    <div class="pb-3 ">
                        {#if dummyLocations.length > 0}
                            <div
                                class="relative h-[300px] rounded-lg overflow-hidden cursor-pointer"
                                role="button"
                                tabindex="0"
                                onclick={() => {
                                    goto(`/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`);
                                }}
                                onkeydown={(e) => {
                                    if (e.key === "Enter" || e.key === " ") {
                                        e.preventDefault();
                                        goto(`/map?lat=${initialCenterLat}&lon=${initialCenterLon}&zoom=${initialZoom}`);
                                    }
                                }}
                            >
                                <Map
                                    locations={dummyLocations}
                                    {initialCenterLon}
                                    {initialCenterLat}
                                    {initialZoom}
                                />
                            </div>
                        {:else}
                            <p class="text-sm text-white/50">
                                No location data available for this video.
                            </p>
                        {/if}
                    </div>
                {/if}
            </div>

            <!-- Transcript Row -->
            {#if data.video.transcript}
                <div class="border-b border-white/10">
                    <button
                        onclick={() => (isTranscriptOpen = !isTranscriptOpen)}
                        class="w-full py-3 flex items-center gap-3 hover:bg-white/5 transition-colors"
                    >
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="16"
                            height="16"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                            class="text-white/70"
                        >
                            <path
                                d="M5 8.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0-2a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5z"
                            />
                            <path
                                d="M2 2a2 2 0 0 1 2-2h8a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2zm2-1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H4z"
                            />
                        </svg>
                        <span class="text-sm font-medium text-white/90">Transcript</span>
                        <svg
                            xmlns="http://www.w3.org/2000/svg"
                            width="14"
                            height="14"
                            fill="currentColor"
                            viewBox="0 0 16 16"
                            class="text-white/70 ml-auto transition-transform {isTranscriptOpen
                                ? 'rotate-45'
                                : ''}"
                        >
                            <path d="M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z" />
                        </svg>
                    </button>
                    {#if isTranscriptOpen}
                            <div class="text-sm text-white/70 leading-relaxed whitespace-pre-wrap">
                                {data.video.transcript}
                            </div>
                     
                    {/if}
                </div>
            {/if}
        </div>
    </div>
</div>
</file>

<file path="src/lib/components/VideoInfoContainer.svelte">
<script lang="ts">
    import VideoInfo from "$lib/components/VideoInfo.svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import {
        getVideoById as lookupVideo,
        videosStore,
    } from "$lib/stores/library";
    import type { Video } from "$lib/types/content";

    interface VideoData {
        video: Video;
    }

    const videosList = $derived($videosStore);

    function resolveVideo(id: string | null): VideoData | null {
        if (!id) return null;
        if (id === "home") {
            const fallback = videosList[0];
            return fallback ? { video: fallback } : null;
        }
        const video = lookupVideo(id);
        return video ? { video } : null;
    }

    let data = $state<VideoData | null>(null);
    let nextVideo = $state<Video | null>(null);

    $effect(() => {
        data = resolveVideo($selectedVideo.id);

        // Resolve next video data
        const nextId = selectedVideo.nextVideoId;
        nextVideo = nextId ? (lookupVideo(nextId) ?? null) : null;
    });

    function handlePlayNext() {
        selectedVideo.playNext();
    }
</script>

{#if data}
    <VideoInfo {data} />

  
{:else}{/if}

<style>
    .placeholder {
        border: 1px dashed rgba(148, 163, 184, 0.3);
        border-radius: 0.75rem;
        padding: 2rem;
        text-align: center;
        color: rgba(71, 85, 105, 0.8);
        background: rgba(15, 23, 42, 0.05);
    }

    .placeholder h2 {
        font-size: 1rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: inherit;
    }

    .placeholder p {
        font-size: 0.875rem;
        line-height: 1.4;
        margin: 0;
    }
</style>
</file>

<file path="src/routes/+layout.svelte">
<script lang="ts">
    import "../app.css";
    import { browser } from "$app/environment";
    import { theme } from "$lib/stores/theme";
    import { activeVideo } from "$lib/stores/video";
    import { onMount } from "svelte";
    import Header from "$lib/components/Header.svelte";
    import Sidebar from "$lib/components/Sidebar.svelte";
    import PersistentVideoPlayer from "$lib/components/PersistentVideoPlayer.svelte";
    import { page } from "$app/stores";
    import { afterNavigate } from "$app/navigation";
    import Playing from "$lib/components/Playing.svelte";
    import { selectedVideo } from "$lib/stores/selectedVideo";
    import MuxVideoPlayer from "$lib/components/MuxVideoPlayer.svelte";
    import VideoTimeline from "$lib/components/VideoTimeline.svelte";
    import VideoInfo from "$lib/components/VideoInfo.svelte";
    import QueueBanner from "$lib/components/QueueBanner.svelte";
    import type { LayoutData } from "./$types";
    import type { Video } from "$lib/types/content";
    import {
        initialiseLibrary,
        videosStore,
        getVideoById as lookupVideo,
    } from "$lib/stores/library";
    import { uiState, actions } from "$lib/stores/appStore";

    let { children, data } = $props<{
        children: () => any;
        data: LayoutData;
    }>();
    let isMobileSidebarOpen = $state(false);
    const videoLibrary = $derived($videosStore);
    const selectedVideoId = $derived($selectedVideo.id);
    const defaultVideo = $derived(videoLibrary[0] ?? null);

    function resolveVideo(id: string | null) {
        if (!id) return null;
        if (id === "home") {
            return defaultVideo;
        }
        return lookupVideo(id) ?? defaultVideo;
    }

    const currentVideo = $derived(resolveVideo($selectedVideo.id));

    // VideoInfo data logic (from VideoInfoContainer)
    interface VideoData {
        video: Video;
    }

    function resolveVideoData(id: string | null): VideoData | null {
        if (!id) return null;
        if (id === "home") {
            const fallback = videoLibrary[0];
            return fallback ? { video: fallback } : null;
        }
        const video = lookupVideo(id);
        return video ? { video } : null;
    }

    let videoInfoData = $state<VideoData | null>(null);
    let nextVideo = $state<Video | null>(null);

    $effect(() => {
        videoInfoData = resolveVideoData($selectedVideo.id);

        // Resolve next video data
        const nextId = selectedVideo.nextVideoId;
        nextVideo = nextId ? (lookupVideo(nextId) ?? null) : null;
    });

    function getVideoDuration(video: Video): number {
        const value = video.duration;
        if (typeof value === "number" && Number.isFinite(value) && value > 0) {
            return value;
        }
        // Fallback to three minutes if duration metadata is missing
        return 180;
    }

    function computeLivePlayback(
        videos: Video[],
        referenceTimestamp: number,
    ): { video: Video; startTime: number } | null {
        if (!videos.length) return null;
        const durations = videos.map(getVideoDuration);
        const totalDuration = durations.reduce((sum, value) => sum + value, 0);
        if (totalDuration <= 0) return null;

        const position = referenceTimestamp % totalDuration;
        let cursor = 0;
        for (let index = 0; index < videos.length; index += 1) {
            const nextCursor = cursor + durations[index];
            if (position < nextCursor) {
                return {
                    video: videos[index],
                    startTime: position - cursor,
                };
            }
            cursor = nextCursor;
        }
        return {
            video: videos[0]!,
            startTime: 0,
        };
    }

    let liveStartTime = $state(0);
    let liveTargetVideoId = $state<string | null>(null);
    let liveSourceSignature = $state("");

    // Track previous queue context state to detect when it's cleared
    let previousQueueContext = $state(false);
    
    $effect(() => {
        if (!browser) return;
        const videos = videoLibrary;
        if (!videos || videos.length === 0) return;
        
        const queueContext = $selectedVideo.queueContext;
        const queueContextWasCleared = previousQueueContext && !queueContext;
        previousQueueContext = !!queueContext;
        
        // Only compute live playback if there's no active queue context
        if (queueContext) {
            // When a queue context exists, don't compute live playback
            return;
        }

        const signature = videos
            .map((video) => `${video.id}:${getVideoDuration(video)}`)
            .join("|");
        
        // Always recompute if:
        // 1. Queue context was just cleared (force fresh timestamp)
        // 2. Signature doesn't match (video library changed)
        // 3. No target video set yet
        const shouldRecompute = queueContextWasCleared || 
                                liveSourceSignature !== signature || 
                                !liveTargetVideoId;

        if (shouldRecompute) {
            const now = Math.floor(Date.now() / 1000);
            const playback = computeLivePlayback(videos, now);
            if (!playback) return;

            liveStartTime = playback.startTime;
            liveTargetVideoId = playback.video.id;
            liveSourceSignature = signature;

            if (selectedVideoId !== playback.video.id) {
                selectedVideo.selectVideo(playback.video.id);
            }
        }
    });

    $effect(() => {
        if (data) {
            initialiseLibrary(data.videos, data.users);
            // Initialize the playback queue with all video IDs
            const videoIds = data.videos.map((v: Video) => v.id);
            selectedVideo.setQueue(videoIds);
        }
    });

    function shouldExpandPath(pathname: string) {
        return (
            pathname === "/live" ||
            (pathname.startsWith("/videos/") && pathname !== "/videos")
        );
    }

    $effect(() => {
        const unsubscribe = uiState.subscribe((state) => {
            selectedVideo.setFullScreen(state.isExpanded);
        });
        return () => unsubscribe();
    });


    onMount(() => {
        theme.init();
        const currentPath = $page.url.pathname;
        if (!currentPath.startsWith("/videos/")) {
            selectedVideo.selectVideo("home");
        }
        const initialExpanded = shouldExpandPath(currentPath);
        uiState.set({ isExpanded: initialExpanded });
        selectedVideo.setFullScreen(initialExpanded);
    });

    $effect(() => {
        const pathname = $page.url.pathname;
        if (pathname === "/live") {
            actions.setExpanded(true);
            return;
        }
        if (pathname.startsWith("/videos/") && pathname !== "/videos") {
            actions.setExpanded(true);
            return;
        }
        // All other routes should minimize the player to sidebar mode
        actions.setExpanded(false);
    });

    function toggleMobileSidebar() {
        isMobileSidebarOpen = !isMobileSidebarOpen;
    }

    function closeMobileSidebar() {
        isMobileSidebarOpen = false;
    }

    // Check if we're on the video page
    const isVideoPage = $derived(
        $page.url.pathname.startsWith("/videos/") ||
            $page.url.pathname === "/live",
    );
    const showPipPlayer = $derived(!isVideoPage && $activeVideo !== null);
    
    // Use startTime = 0 when a temporary queue is active, otherwise use live timestamp
    const videoStartTime = $derived(
        $selectedVideo.queueContext ? 0 : liveStartTime
    );
</script>

<svelte:head>
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
    />
    <title>Rushes</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Droid+Serif:ital,wght@0,400;0,700;1,400;1,700&family=Fira+Mono:wght@400;500;700&display=swap"
        rel="stylesheet"
    />
</svelte:head>

<!-- Persistent Video Player
{#if $activeVideo}
	<PersistentVideoPlayer />
{/if} -->

<div class="min-h-screen w-full overflow-x-hidden transition-colors">
    <div class="flex min-h-screen w-full relative overflow-visible">
        <!-- Sidebar -->
        <Sidebar isOpen={true} onclose={closeMobileSidebar} />

        <!-- Desktop Now Playing section, live like function with video queue -->
        <div
            id="scroll-view"
            class="hidden lg:flex h-screen flex-col w-[500px] max-w-[500px] shrink-0 border-l border-r border-gray-200/10 dark:border-neutral-100/10 bg-white dark:bg-white/2"
        >
            <div id="scroll-content" class="flex-1 overflow-y-auto">
                <div class="flex flex-col min-h-full gap-6">
                    <div class="flex-none" id="video-wrapper">
                        <QueueBanner />
                        <div
                            id="video-aspect-container"
                            class="relative aspect-video w-full border-b border-white/10 bg-black shadow-[0_24px_80px_-48px_rgba(8,47,73,0.85)]"
                        >
                            <div class="h-full w-full">
                                <MuxVideoPlayer
                                    src={currentVideo?.videoUrl}
                                    autoplayUserPreference={true}
                                    startTime={videoStartTime}
                                    playerKey={`sidebar-player-${currentVideo?.id ?? "none"}-${Math.floor(videoStartTime)}-${$selectedVideo.queueContext ? 'queue' : 'live'}`}
                                />
                            </div>
                        </div>
                    </div>

                    <!-- Video Info Container (like Sidebar content in Astro) -->
                    <div id="sidebar-details" class="flex-1">
                        {#if videoInfoData}
                            <VideoInfo data={videoInfoData} />
                        {/if}
                    </div>
                </div>
            </div>
        </div>

        <!-- Main content wrapper -->
        <div
            class="flex-1 flex flex-col w-full transition-all duration-200 min-h-0 overflow-hidden"
            class:translate-x-64={isMobileSidebarOpen}
        >
            <!-- Header -->
            <!-- <Header ontoggleSidebar={toggleMobileSidebar} /> -->

            <!-- Main content area -->
            <main
                class="flex-1 w-full max-w-full bg-white h-full overflow-scroll dark:bg-black min-h-0"
                style="height: 100vh; overflow-y: scroll;"
                style:view-transition-name="main-content"
            >
                {@render children()}
            </main>
        </div>
    </div>
</div>

<!-- Mobile-only playing overlay -->
<div class="lg:hidden">
    <Playing />
</div>

<style>
    :global(body) {
        font-family: "Droid Serif", serif;
        view-transition-name: none;
    }

    :global(::view-transition-old(main-content)),
    :global(::view-transition-new(main-content)) {
        animation: none;
        mix-blend-mode: normal;
    }

    :global(::view-transition-old(video-player)),
    :global(::view-transition-new(video-player)) {
        animation: none;
        mix-blend-mode: normal;
    }

    /* Player container styles from Astro layout */
    :global(#player-container) {
        will-change: transform;
        transform-style: preserve-3d;
        position: relative;
        width: 100%;
        height: 100%;
        margin: 0 auto;
        overflow: hidden;
        object-fit: cover !important;
        object-position: center center !important;
    }

    :global(#player-container.fullscreen) {
        position: fixed;
        will-change: transform;
        transform-style: preserve-3d;
        z-index: 999999;
        top: 2rem;
        border-radius: 0;
        left: calc(570px + 3rem);
        width: calc(100vw - 660px);
        height: calc(100vh - 3rem);
    }

    /* Collapse the video wrapper when player is fullscreen to remove aspect-ratio gap */
    :global(#video-wrapper:has(#player-container.fullscreen)) {
        height: 0 !important;
        min-height: 0 !important;
        padding: 0 !important;
        margin: 0 !important;
    }

    /* Remove aspect ratio and hide the container when player is fullscreen */
    :global(#video-aspect-container:has(#player-container.fullscreen)) {
        aspect-ratio: unset !important;
        height: 0 !important;
        min-height: 0 !important;
        padding: 0 !important;
        border: none !important;
    }

    /* Ensure video element stays above everything */
    :global(#player-container video) {
        width: 100%;
        height: 100%;
        position: relative;
        top: 0;
        left: 0;
    }
</style>
</file>

<file path="src/routes/+page.svelte">
<script lang="ts">
	import { actions } from "$lib/stores/appStore";
	import { selectedVideo } from "$lib/stores/selectedVideo";
	import { videosStore } from "$lib/stores/library";
	import type { Video } from "$lib/types/content";

	interface SoundClip {
		id: string;
		title: string;
		recordist: string;
		duration: string;
		capturedOn: string;
		location: string;
		relatedProject: string;
	}

	interface HeroMetric {
		label: string;
		value: string;
	}

	interface LatestVideoItem {
		id: string;
		title: string;
		author: string;
		date: string;
		timestampValue: number;
		location: string;
		thumbnailUrl: string;
	}

	interface LatestSoundItem {
		id: string;
		title: string;
		author: string;
		date: string;
		location: string;
		capturedValue: number;
	}

	const FALLBACK_THUMBNAIL = "https://placehold.co/200x112?text=Rushes";

	const soundLibrary: SoundClip[] = [
		{
			id: "amb-001",
			title: "Canal Footbridge Atmos",
			recordist: "Inès Duarte",
			duration: "01:22",
			capturedOn: "2024-03-12",
			location: "Quai des Péniches, Brussels",
			relatedProject: "Portrait of an Unknown Artist",
		},
		{
			id: "fx-014",
			title: "Metro Brakes – Line 6",
			recordist: "Luca Van Eyck",
			duration: "00:47",
			capturedOn: "2024-02-04",
			location: "Ribaucourt Station",
			relatedProject: "Urban Exploration",
		},
		{
			id: "amb-019",
			title: "Night Rain On Skylight",
			recordist: "Aya Kakei",
			duration: "02:08",
			capturedOn: "2024-01-23",
			location: "Ixelles Rooftop",
			relatedProject: "Neon Dreams",
		},
		{
			id: "vox-006",
			title: "Voice Memo — “Golden Hour”",
			recordist: "Leonie Saerens",
			duration: "00:36",
			capturedOn: "2023-12-17",
			location: "Signal de Botrange",
			relatedProject: "Sunset Timelapse",
		},
		{
			id: "foley-011",
			title: "Textile Rustle Layers",
			recordist: "Tom Schurr",
			duration: "01:04",
			capturedOn: "2024-03-04",
			location: "Studio 12B, Molenbeek",
			relatedProject: "Portrait of an Unknown Artist",
		},
	];

	let videos: Video[] = [];
	$: videos = $videosStore ?? [];

	let totalRuntimeSeconds = 0;
	let uniqueContributors = 0;
	let lastUploadedTimestamp = Number.NEGATIVE_INFINITY;
	let lastUpdated = "—";
	let heroMetrics: HeroMetric[] = [];
	let latestVideos: LatestVideoItem[] = [];
	let latestSounds: LatestSoundItem[] = [];

	function formatDate(iso?: string | null) {
		if (!iso) return "—";
		const date = new Date(iso);
		if (Number.isNaN(date.getTime())) return iso;
		const day = String(date.getDate()).padStart(2, '0');
		const month = String(date.getMonth() + 1).padStart(2, '0');
		const year = String(date.getFullYear()).slice(-2);
		return `${day}/${month}/${year}`;
	}

	function parseDuration(value?: string | null) {
		if (!value) return 0;
		const parts = value.split(":").map((n) => Number.parseInt(n, 10));
		if (parts.some((n) => Number.isNaN(n))) return 0;
		if (parts.length === 3) {
			const [hours, minutes, seconds] = parts;
			return hours * 3600 + minutes * 60 + seconds;
		}
		if (parts.length === 2) {
			const [minutes, seconds] = parts;
			return minutes * 60 + seconds;
		}
		return parts[0];
	}

	function coerceDurationSeconds(value?: number | string | null) {
		if (typeof value === "number" && Number.isFinite(value)) return value;
		if (typeof value === "string") return parseDuration(value);
		return 0;
	}

	function formatRuntime(totalSeconds: number) {
		if (!totalSeconds || Number.isNaN(totalSeconds)) return "0m";
		const hours = Math.floor(totalSeconds / 3600);
		const minutes = Math.floor((totalSeconds % 3600) / 60);
		if (hours > 0) {
			return `${hours}h ${minutes.toString().padStart(2, "0")}m`;
		}
		return `${minutes}m`;
	}

	function getVideoTimestampValue(video: any) {
		const candidate = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
		if (typeof candidate === "string") {
			const parsed = Date.parse(candidate);
			if (!Number.isNaN(parsed)) {
				return parsed;
			}
		}
		return Number.NEGATIVE_INFINITY;
	}

	function getPrimaryLocation(video: any) {
		const locations = video?.locations;
		if (Array.isArray(locations) && locations.length > 0) {
			const first = locations[0];
			const label =
				first?.setting ?? first?.name ?? first?.environment ?? first?.city ?? first?.country;
			if (label) return label;
		}
		if (typeof video?.location === "string" && video.location.trim().length > 0) {
			return video.location;
		}
		return "Unspecified location";
	}

	$: totalRuntimeSeconds = videos.reduce(
		(total, video) => total + coerceDurationSeconds(video.duration),
		0,
	);

	$: uniqueContributors = new Set(
		videos
			.map((video) => video.author)
			.filter((author) => Boolean(author)),
	).size;

	$: lastUploadedTimestamp = videos.reduce((latest, video) => {
		const timestampValue = getVideoTimestampValue(video);
		return timestampValue > latest ? timestampValue : latest;
	}, Number.NEGATIVE_INFINITY);

	$: lastUpdated =
		lastUploadedTimestamp !== Number.NEGATIVE_INFINITY
			? formatDate(new Date(lastUploadedTimestamp).toISOString())
			: "—";

	$: heroMetrics = [
		{ label: "VIDEOS", value: videos.length.toString().padStart(2, "0") },
		{ label: "CURATORS", value: uniqueContributors.toString().padStart(2, "0") },
		{ label: "RUNTIME", value: formatRuntime(totalRuntimeSeconds) },
		{ label: "LAST UPDATE", value: lastUpdated },
	];

	$: latestVideos = videos
		.map((video) => {
			const timestampValue = getVideoTimestampValue(video);
			const iso = video?.timestamp ?? video?.uploadDate ?? video?.uploadedAt ?? null;
			return {
				id: video.id,
				title: video.title ?? "Untitled",
				author: video.author ?? "Unknown author",
				date: iso ? formatDate(iso) : "—",
				timestampValue,
				location: getPrimaryLocation(video),
				thumbnailUrl: video.thumbnailUrl ?? FALLBACK_THUMBNAIL,
			};
		})
		.sort((a, b) => b.timestampValue - a.timestampValue)
		.slice(0, 6);

	$: latestSounds = soundLibrary
		.map((clip) => ({
			id: clip.id,
			title: clip.title,
			author: clip.recordist,
			date: formatDate(clip.capturedOn),
			location: clip.location,
			capturedValue: Date.parse(clip.capturedOn),
		}))
		.sort((a, b) => (b.capturedValue || 0) - (a.capturedValue || 0))
		.slice(0, 6);

	function openVideoById(id: string) {
		if (!id) return;
		selectedVideo.selectVideo(id);
		actions.setExpanded(false);
	}
</script>

<svelte:head>
	<title>Media Dashboard — Rushes</title>
	<meta name="description" content="Terminal overview of the Rushes archive." />
</svelte:head>

<div class="h-screen overflow-x-hidden overflow-y-scroll bg-[#05060c] font-sans text-[12px] text-slate-200">
	<div class="mx-auto w-full max-w-7xl space-y-12 px-6 py-12 lg:px-12">
		<header
			class="relative overflow-hidden"
		>
			<!-- <div class="pointer-events-none absolute -right-32 -top-32 h-72 w-72 rounded-full bg-sky-500/20 blur-3xl"></div>
			<div class="pointer-events-none absolute -bottom-24 -left-24 h-56 w-56 rounded-full bg-purple-500/10 blur-2xl"></div> -->
			<div class="relative flex min-w-0 flex-col gap-8 md:flex-row md:items-center md:justify-between">
				<div class="min-w-0 ">
					<p class="max-w-xl text-sm leading-relaxed text-slate-300">
						<b>RUSHES</b> est une plateforme collective dédiée aux cinéastes bruxellois. Elle cartographie les rushes — images
						non montées, fragments de tournage — pour nourrir une archive vivante, un espace de rencontre et un laboratoire
						d’expérimentation visuelle.
					</p>
				</div>
				<div class="grid min-w-0 gap-4 sm:grid-cols-2 md:grid-cols-5">
					{#each heroMetrics as metric (metric.label)}
						<div class="border-l border-white/10 bg-black/30 px-4 py-3 text-left shadow-inner">
							<p class="text-[10px] uppercase tracking-[0.3em] text-slate-500">{metric.label}</p>
							<p class="mt-2 text-lg font-semibold text-white">{metric.value}</p>
						</div>
					{/each}
				</div>
			</div>
		</header>

		<section class="grid gap-10 lg:grid-cols-2 lg:gap-0">
			<article class="space-y-4 lg:pr-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-2 text-sm font-bold border-b w-full pb-2  text-slate-300">
			

						<!-- <svg class="h-4 w-4 text-slate-200/90" fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"> <path d="M4 3H2v18h20V3H4zm16 2v14H4V5h16zm-6 4h-2v2h-2v2H8v2H6v2h2v-2h2v-2h2v-2h2v2h2v2h2v-2h-2v-2h-2V9zM8 7H6v2h2V7z" fill="currentColor"/> </svg>  -->
						Latest Videos
					</h2>
				</header>

				{#if latestVideos.length > 0}
					<ul class="space-y-4">
						{#each latestVideos as video (video.id)}
							<li
								class="group flex items-center gap-4 border-b pb-3 border-white/10 "
							>
								<img
									src={video.thumbnailUrl}
									alt={`Thumbnail for ${video.title}`}
									class="h-10 w-10 flex-shrink-0 overflow-hidden border border-white/10 object-cover"
									loading="lazy"
									onerror={(event) => ((event.currentTarget as HTMLImageElement).src = FALLBACK_THUMBNAIL)}
								/>
								<div class="flex flex-1 flex-col gap-1">
									<div class="flex items-center">
								
										<p class="truncate text-sm font-semibold text-white">
											{video.title}
										</p>
									</div>
									<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
										<span class="truncate text-slate-300/90 normal-case tracking-normal">{video.author}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="text-slate-400 normal-case tracking-normal">{video.date}</span>
										<span aria-hidden="true" class="text-slate-500">
											•
										</span>
										<span class="truncate text-slate-400 normal-case tracking-normal">{video.location}</span>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				{:else}
					<p class="rounded-lg border border-white/5 bg-black/20 p-6 text-center text-sm text-slate-400">
						No videos available yet.
					</p>
				{/if}
			</article>

			<article class="space-y-4 lg:pl-8">
				<header class="flex items-center justify-between">
					<h2 class="flex items-center gap-2 text-sm font-bold border-b w-full pb-2  text-slate-300">
						<!-- <svg
							class="h-4 w-4 text-orange"
							aria-hidden="true"
							xmlns="http://www.w3.org/2000/svg"
							viewBox="0 0 24 24"
						>
							<path
								fill="currentColor"
								d="M11 2h2v20h-2v-2H9v-2h2V6H9V4h2zM7 8V6h2v2zm0 8H3V8h4v2H5v4h2zm0 0v2h2v-2zm10-6h-2v4h2zm2-2h2v8h-2zm0 8v2h-4v-2zm0-10v2h-4V6z"
							/>
						</svg> -->
						Latest Sounds
					</h2>
				</header>

				<div class="lg:-ml-8 lg:mt-2 lg:border-l lg:border-[rgba(255,255,255,0.08)] lg:pl-8">
					<ul class="space-y-3">
						{#each latestSounds as sound (sound.id)}
							<li class="group flex items-center">
								<div class="flex flex-1 flex-col gap-2 border-b border-white/10 pb-4">
									<div class="flex items-center gap-3">
										<button
											type="button"
											class="flex h-9 w-9 items-center justify-center rounded-full border border-white/10 bg-white/5 text-slate-300 transition hover:border-sky-400 hover:text-white focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-sky-500/60"
											aria-label={`Play ${sound.title}`}
										>
											<svg class="h-3 w-3" viewBox="0 0 12 14" fill="currentColor" aria-hidden="true">
												<path d="M2 1.5v11l9-5.5-9-5.5z" />
											</svg>
										</button>
										<div class="flex flex-col">
											<p class="mb-1 truncate text-sm font-semibold text-white">
												{sound.title}
											</p>
											<div class="flex flex-wrap items-center gap-x-1 gap-y-1 text-[11px] uppercase tracking-[0.25em] text-slate-400">
												<span class="truncate text-slate-300/90 normal-case tracking-normal">{sound.author}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="text-slate-400 normal-case tracking-normal">{sound.date}</span>
												<span aria-hidden="true" class="text-slate-500">
													•
												</span>
												<span class="truncate text-slate-400 normal-case tracking-normal">{sound.location}</span>
											</div>
										</div>
									</div>
								</div>
							</li>
						{/each}
					</ul>
				</div>
			</article>
		</section>
	</div>
</div>
</file>

<file path="package.json">
{
	"name": "RUSHES",
	"private": true,
	"version": "0.0.1",
	"type": "module",
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "bun run build && bunx wrangler pages dev",
		"prepare": "svelte-kit sync || echo ''",
		"check": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json",
		"check:watch": "svelte-kit sync && svelte-check --tsconfig ./tsconfig.json --watch",
		"format": "prettier --write .",
		"lint": "prettier --check .",
		"test:unit": "vitest",
		"test": "bun run test:unit -- --run",
		"db:push": "bun --bun drizzle-kit push",
		"db:generate": "bun --bun drizzle-kit generate",
		"db:migrate": "bun --bun drizzle-kit migrate",
		"db:studio": "bun --bun drizzle-kit studio",
		"deploy": "bun run build && bunx wrangler pages deploy --branch=production",
		"deploy:cloudflare": "bun run build && bunx wrangler pages deploy --branch=production",
		"cf-typegen": "bunx wrangler types ./src/worker-configuration.d.ts"
	},
	"devEnvironment": {
		"PUBLIC_SUPABASE_URL": "https://jmpxnpndvgbbtmvfribf.supabase.co",
		"PUBLIC_SUPABASE_ANON_KEY": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImptcHhucG5kdmdiYnRtdmZyaWJmIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk3NTgyMzksImV4cCI6MjA3NTMzNDIzOX0.YFxW3EzucGfo9QSlH0Pcq44hjpXVHH3MDnCYUQj4Im0"
	},
	"devDependencies": {
		"@sveltejs/adapter-cloudflare": "^7.2.4",
		"@sveltejs/kit": "^2.43.2",
		"@sveltejs/vite-plugin-svelte": "^6.2.0",
		"@tailwindcss/forms": "^0.5.10",
		"@tailwindcss/typography": "^0.5.18",
		"@tailwindcss/vite": "^4.1.13",
		"@types/node": "^22",
		"@vitest/browser": "^3.2.4",
		"drizzle-kit": "^0.31.4",
		"drizzle-orm": "^0.44.5",
		"playwright": "^1.55.1",
		"prettier": "^3.6.2",
		"prettier-plugin-svelte": "^3.4.0",
		"prettier-plugin-tailwindcss": "^0.6.14",
		"svelte": "^5.39.5",
		"svelte-check": "^4.3.2",
		"tailwindcss": "^4.1.13",
		"typescript": "^5.9.2",
		"vite": "^7.1.7",
		"vitest": "^3.2.4",
		"vitest-browser-svelte": "^1.1.0",
		"wrangler": "^4.44.0"
	},
	"dependencies": {
		"@supabase/ssr": "^0.7.0",
		"@supabase/supabase-js": "^2.77.0",
		"bits-ui": "^2.14.0",
		"depcheck": "^1.4.7",
		"dotenv": "^17.2.3",
		"global": "^4.4.0",
		"gsap": "^3.13.0",
		"hls-video-element": "^1.5.8",
		"mapbox-gl": "^3.12.0",
		"media-chrome": "^4.14.0",
		"postgres": "^3.4.7",
		"svelte-dnd-action": "^0.9.65",
		"tus-js-client": "^4.3.1"
	}
}
</file>

</files>
